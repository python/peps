
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 793 – PyModExport: A new entry point for C extension modules | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0793/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 793 – PyModExport: A new entry point for C extension modules | peps.python.org'>
    <meta property="og:description" content="In this PEP, we propose a new entry point for C extension modules, by which one can define a module using an array of PyModuleDef_Slot structures without an enclosing PyModuleDef structure. This allows extension authors to avoid using a statically alloc...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0793/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="In this PEP, we propose a new entry point for C extension modules, by which one can define a module using an array of PyModuleDef_Slot structures without an enclosing PyModuleDef structure. This allows extension authors to avoid using a statically alloc...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 793</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 793 – PyModExport: A new entry point for C extension modules</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Petr Viktorin &lt;encukou&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/93444">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">23-May-2025</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.15</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/84498/" title="Discourse thread">14-Mar-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/93444/" title="Discourse thread">27-May-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background-motivation">Background &amp; Motivation</a><ul>
<li><a class="reference internal" href="#the-interpreter-switch">The interpreter switch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#using-slots-without-a-wrapper-struct">Using slots without a wrapper struct</a></li>
<li><a class="reference internal" href="#tokens">Tokens</a></li>
<li><a class="reference internal" href="#soft-deprecating-the-existing-export-hook">Soft-deprecating the existing export hook</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#the-export-hook">The export hook</a></li>
<li><a class="reference internal" href="#dynamic-creation">Dynamic creation</a></li>
<li><a class="reference internal" href="#pep793-token">Tokens</a></li>
<li><a class="reference internal" href="#new-slots">New slots</a></li>
<li><a class="reference internal" href="#bits-pieces">Bits &amp; Pieces</a></li>
<li><a class="reference internal" href="#id3">Soft-deprecating the existing export hook</a></li>
<li><a class="reference internal" href="#new-api-summary">New API summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#forward-compatibility">Forward compatibility</a></li>
<li><a class="reference internal" href="#porting-guide">Porting guide</a></li>
<li><a class="reference internal" href="#backwards-compatibility-shim">Backwards compatibility shim</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#exporting-a-data-pointer-rather-than-a-function">Exporting a data pointer rather than a function</a></li>
<li><a class="reference internal" href="#changing-pymoduledef-to-not-be-pyobject">Changing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> to not be <code class="docutils literal notranslate"><span class="pre">PyObject</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-future-directions">Possible Future Directions</a><ul>
<li><a class="reference internal" href="#improving-slots-in-general">Improving slots in general</a></li>
<li><a class="reference internal" href="#updating-defaults">Updating defaults</a></li>
<li><a class="reference internal" href="#the-inittab">The inittab</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>In this PEP, we propose a new entry point for C extension modules, by which
one can define a module using an array of <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> structures
without an enclosing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure.
This allows extension authors to avoid using a statically allocated
<code class="docutils literal notranslate"><span class="pre">PyObject</span></code>, lifting the most common obstacle to making one compiled library
file usable with both regular and free-threaded builds of CPython.</p>
<p>To make this viable, we also specify new module slot types to replace
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>’s fields, and to allow adding a <em>token</em> similar to the
<code class="docutils literal notranslate"><span class="pre">Py_tp_token</span></code> used for type objects.</p>
<p>We also add an API for defining modules from slots dynamically.</p>
<p>The existing API (<code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code>) is soft-deprecated.
(That is: it will continue to work without warnings, and it’ll be fully
documented and supported, but we plan to not add any new features to it.)</p>
</section>
<section id="background-motivation">
<h2><a class="toc-backref" href="#background-motivation" role="doc-backlink">Background &amp; Motivation</a></h2>
<p>The memory layout of Python objects differs between regular and free-threading
builds.
So, an ABI that supports both regular and free-threading builds cannot include
the current <code class="docutils literal notranslate"><span class="pre">PyObject</span></code> memory layout. To stay compatible with existing ABI
(and API), it cannot support statically allocated Python objects.</p>
<p>There is one type of object that is needed in most extension modules
and is allocated statically in virtually all cases: the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> returned
from the module export hooks (that is, <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> functions).</p>
<p>Module export hooks (<code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> functions) can return two kinds of objects:</p>
<ol class="arabic">
<li>A fully initialized module object (for so-called
<em>single-phase initialization</em>). This was the only option in 3.4 and below.
Modules created this way have surprising (but backwards-compatible)
behaviour around multiple interpreters or repeated loading.
(Specifically, the <em>contents</em> of such a module’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> are shared
across all instances of the module object.)<p>The module returned is typically created using the <code class="docutils literal notranslate"><span class="pre">PyModule_Create</span></code>
function, which requires a statically allocated (or at least long-lived)
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct.</p>
<p>It is possible to bypass this using the lower-level <code class="docutils literal notranslate"><span class="pre">PyModule_New*</span></code> API.
This avoids the need for <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, but offers much less functionality.</p>
</li>
<li>A <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object containing a description of how to create a module
object. This option, <em>multi-phase initialization</em>, was introduced in
<a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a>; see its motivation for why it exists.</li>
</ol>
<p>The interpreter cannot distinguish between these cases before the export hook
is called.</p>
<section id="the-interpreter-switch">
<h3><a class="toc-backref" href="#the-interpreter-switch" role="doc-backlink">The interpreter switch</a></h3>
<p>Python 3.12 added a way for modules to mark whether they may be
loaded in a subinterpreter: the <code class="docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code> slot.
Setting it to the “not supported” value signals that an extension
can only be loaded in the main interpreter.</p>
<p>Unfortunately, Python can only get this information by <em>calling</em> the
module export hook.
For single-phase modules, that creates the module object and runs arbitrary
initialization code.
For modules that set <code class="docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code> to “not supported”,
this initialization needs to happen in the main interpreter.</p>
<p>To make this work, if a new module is loaded in a sub-interpreter, Python
temporarily switches to the main interpreter, calls the export hook
there, and then either switches back and redoes the import, or fails.</p>
<p>This unnecessary and fragile extra work highlights the underlying design issue:
Python has no way to get information about an extension
before the extension can, potentially, fully initialize itself.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>For avoiding the module export hook requiring a statically allocated
<code class="docutils literal notranslate"><span class="pre">PyObject*</span></code>, two options come to mind:</p>
<ul>
<li>Returning a <em>dynamically</em> allocated object, whose ownership is transferred
to the interpreter. This stucture could be very similar to the existing
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, since it needs to contain the same data.
Unlike the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, this one would need to be
reference-counted so that it both outlives “its” module and does not leak.</li>
<li>Adding a new export hook, which does not return a <code class="docutils literal notranslate"><span class="pre">PyObject*</span></code>.<p>This was considered already for Python 3.5 in <a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a>, but rejected:</p>
<blockquote>
<div>Keeping only the PyInit hook name, even if it’s not entirely appropriate
for exporting a definition, yielded a much simpler solution.</div></blockquote>
<p>Alas, after a decade of fixing the implications of this choice, the solution
is no longer simple.</p>
</li>
</ul>
<p>A new hook will also allow Python to avoid the second issue mentioned in
Motivation – the interpreter switch.
Effectivelly, it will add a new phase to multi-phase initialization, in which
Python can check whether the module is compatible.</p>
<section id="using-slots-without-a-wrapper-struct">
<h3><a class="toc-backref" href="#using-slots-without-a-wrapper-struct" role="doc-backlink">Using slots without a wrapper struct</a></h3>
<p>The existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> is a struct with some fixed fields and
a “slots” array.
Unlike slots, the fixed fields cannot be individually deprecated and replaced.
This proposal does away with fixed fields and proposes using a slots array
directly, without a wrapper struct.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> struct does have some downsides compared to fixed fields.
We believe these are fixable, but leave that out of scope of this PEP
(see “Improving slots in general” in the Possible Future Directions section).</p>
</section>
<section id="tokens">
<h3><a class="toc-backref" href="#tokens" role="doc-backlink">Tokens</a></h3>
<p>A static <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> has another purpose besides describing
how a module should be created.
As a statically allocated singleton that remains attached to the module object,
it allows extension authors to check whether a given Python module is “theirs”:
if a module object has a known <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, its module state will have
a known memory layout.</p>
<p>An analogous issue was solved for types by adding <code class="docutils literal notranslate"><span class="pre">Py_tp_token</span></code>.
This proposal adds the same mechanism to modules.</p>
<p>Unlike types, the import mechanism often has a pointer that’s known to be
suitable as a token value; in these cases it can provide a default token.
Thus, module tokens do not need a variant of the inelegant <code class="docutils literal notranslate"><span class="pre">Py_TP_USE_SPEC</span></code>.</p>
<p>To help extensions that straddle Python versions, <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> addresses
are used as default tokens, and where it’s reasonable, they are made
interchangeable with tokens.</p>
</section>
<section id="soft-deprecating-the-existing-export-hook">
<h3><a class="toc-backref" href="#soft-deprecating-the-existing-export-hook" role="doc-backlink">Soft-deprecating the existing export hook</a></h3>
<p>The only reason for authors of <em>existing</em> extensions to switch to the
API proposed here is that it allows a single module for both free-threaded
and non-free-threaded builds.
It is important that Python <em>allows</em> that, but for many existing modules,
it is nowhere near worth losing compatibility with 3.14 and lower versions.</p>
<p>It is much too early to plan deprecation of the old API.</p>
<p>Instead, this PEP proposes to stop adding new features to the <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code>
scheme.
After all, the perfect time for extension authors to switch is when they want
to modify module initialization anyway.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="the-export-hook">
<h3><a class="toc-backref" href="#the-export-hook" role="doc-backlink">The export hook</a></h3>
<p>When importing an extension module, Python will now first look for an export hook
like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">PyModExport_</span><span class="o">&lt;</span><span class="n">NAME</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&lt;NAME&gt;</span></code> is the name of the module.
For non-ASCII names, it will instead look for <code class="docutils literal notranslate"><span class="pre">PyModExportU_&lt;NAME&gt;</span></code>,
with <code class="docutils literal notranslate"><span class="pre">&lt;NAME&gt;</span></code> encoded as for existing <code class="docutils literal notranslate"><span class="pre">PyInitU_*</span></code> hooks
(that is, <em>punycode</em>-encoded with hyphens replaced by underscores).</p>
<p>If not found, the import will continue as in previous Python versions (that is,
by looking up a <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> or <code class="docutils literal notranslate"><span class="pre">PyInitU_*</span></code> function).</p>
<p>If found, Python will call the hook with no arguments.</p>
<p>On failure, the export hook must return NULL with an exception set.
This will cause the import to fail.
(Python will not fall back to <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> on error.)</p>
<p>On success, the hook must return a pointer to an array of
<code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> structs.
Python will then create a module based on the given slots by calling functions
proposed below: <code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code> and <code class="docutils literal notranslate"><span class="pre">PyModule_Exec</span></code>.
See their description for requirements on the slots array.</p>
<p>The returned array and all data it points to (recursively) must remain valid
and constant until runtime shutdown.
(We expect functions to export a static constant, or one of several constants
chosen depending on, for example, <code class="docutils literal notranslate"><span class="pre">Py_Version</span></code>. Dynamic behaviour should
generally happen in the <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> and <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> functions.)</p>
</section>
<section id="dynamic-creation">
<h3><a class="toc-backref" href="#dynamic-creation" role="doc-backlink">Dynamic creation</a></h3>
<p>A new function will be added to create a module from an array of slots:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">PyModule_FromSlotsAndSpec</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">slots</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">spec</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>slots</em> argument must point to an array of <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> structures,
terminated by a slot with <code class="docutils literal notranslate"><span class="pre">slot=0</span></code> (typically written as <code class="docutils literal notranslate"><span class="pre">{0}</span></code> in C).
There are no required slots, though <em>slots</em> must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
It follows that minimal input contains only the terminator slot.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <a class="pep reference internal" href="../pep-0803/" title="PEP 803 – Stable ABI for Free-Threaded Builds">PEP 803</a> is accepted, the <code class="docutils literal notranslate"><span class="pre">Py_mod_abi</span></code> slot will be mandatory.</p>
</div>
<p>The <em>spec</em> argument is a duck-typed ModuleSpec-like object, meaning that any
attributes defined for <code class="docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code> have matching
semantics.
The <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute is required, but this limitation may be lifted in the
future.
The <code class="docutils literal notranslate"><span class="pre">name</span></code> will be used <em>instead of</em> the <code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code> slot (just like
<code class="docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec</span></code> ignores <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_name</span></code>).</p>
<p>The slots arrays for both <code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code> and the new export hook
will only allow up to one <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> slot.
Arrays in <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_slots</span></code> may have more; this will not change.
This limitation is easy to work around and multiple <code class="docutils literal notranslate"><span class="pre">exec</span></code> slots are rarely
used <a class="footnote-reference brackets" href="#multiexec" id="id1">[1]</a>.</p>
<p>For modules created without a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, the <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> function
will be called with <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for the second argument (<em>def</em>).
(In the future, if we find a use case for passing the input slots array, a new
slot with an updated signature can be added.)</p>
<p>Unlike the <code class="docutils literal notranslate"><span class="pre">PyModExport_*</span></code> hook, the <em>slots</em> array may be changed or
destroyed after the <code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code> call.
(That is, Python must take a copy of all input data.)
As an exception, any <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> array given by <code class="docutils literal notranslate"><span class="pre">Py_mod_methods</span></code>
must be statically allocated (or be otherwise guaranteed to outlive the
objects created from it). This limitation may be lifted in the future.</p>
<p>A new function, <code class="docutils literal notranslate"><span class="pre">PyModule_Exec</span></code>, will be added to run the <code class="docutils literal notranslate"><span class="pre">exec</span></code> slot(s) for a module.
This acts like <code class="docutils literal notranslate"><span class="pre">PyModule_ExecDef</span></code>, but supports modules created using slots,
and does not take an explicit <em>def</em>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">PyModule_Exec</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling this is required to fully initialize a module.
<code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code> will <em>not</em> run it (just like
<code class="docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec</span></code> does not call <code class="docutils literal notranslate"><span class="pre">PyModule_ExecDef</span></code>).</p>
<p>For modules created from a <em>def</em>, calling this is equivalent to
calling <code class="docutils literal notranslate"><span class="pre">PyModule_ExecDef(module,</span> <span class="pre">PyModule_GetDef(module))</span></code>.</p>
</section>
<section id="pep793-token">
<span id="id2"></span><h3><a class="toc-backref" href="#pep793-token" role="doc-backlink">Tokens</a></h3>
<p>Module objects will optionally store a “token”: a <code class="docutils literal notranslate"><span class="pre">void*</span></code> pointer
similar to <code class="docutils literal notranslate"><span class="pre">Py_tp_token</span></code> for types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is specialized functionality meant replace the
<code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> function; users that don’t need
<code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> will most likely not need tokens either.</p>
<p>This section contains the technical specification;
for an example of intended usage, see <code class="docutils literal notranslate"><span class="pre">exampletype_repr</span></code> in the
<a class="reference internal" href="#pep793-example"><span class="std std-ref">Example section</span></a>.</p>
</div>
<p>If specified, using a new <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> slot, the module token must:</p>
<ul class="simple">
<li>outlive the module, so it’s not reused for something else while the module
exists; and</li>
<li>“belong” to the extension module where the module lives, so it will not
clash with other extension modules.</li>
</ul>
<p>(Typically, it should be the slots array or <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> that a module is
created from, or another static constant for dynamically created modules.)</p>
<p>When the address of a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> is used as a module’s token,
the module should behave as if it was created from that <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>.
In particular, the module state must have matching layout and semantics.</p>
<p>Modules created using the <code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code> or the
<code class="docutils literal notranslate"><span class="pre">PyModExport_&lt;NAME&gt;</span></code> export hook can use a new <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> slot
to set the token.</p>
<p>Modules created from a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> will have the token set to that
definition. An explicit <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> slot will we rejected for these.
(This allows implementations to share storage for the token and def.)</p>
<p>For modules created via the new export hook, the token
will be set to the address of the slots array by default.
(This does <strong>not</strong> apply to modules created by <code class="docutils literal notranslate"><span class="pre">PyModule_FromSlotsAndSpec</span></code>,
as that function’s input might not outlive the module.)</p>
<p>The token will not be set for non-<code class="docutils literal notranslate"><span class="pre">PyModuleType</span></code> instances.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">PyModule_GetToken</span></code> function will be added to get the token.
Since the result may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, it will be passed via a pointer; the function
will return 0 on success and -1 on failure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">PyModule_GetToken</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">token_p</span><span class="p">)</span>
</pre></div>
</div>
<p>A new <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code> function will be added, with a signature
like the existing <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> but a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*token</span></code> argument,
and the same behaviour except matching tokens rather than only defs,
and returning a strong reference.</p>
<p>For easier backwards compatibility, the existing <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code>
will be changed to also allow a token (cast to a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span> <span class="pre">*</span></code> pointer) as
the <em>def</em> argument.
That is, <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code> and <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> will differ
only in the formal signature of the second argument and by returning a
borrowed vs. strong reference.
(The <code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code> function will not get a similar change, as users may
access members of its result.)</p>
</section>
<section id="new-slots">
<h3><a class="toc-backref" href="#new-slots" role="doc-backlink">New slots</a></h3>
<p>For each field of the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct, except ones from
<code class="docutils literal notranslate"><span class="pre">PyModuleDef_HEAD_INIT</span></code>, a new slot ID will be provided: <code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code>,
<code class="docutils literal notranslate"><span class="pre">Py_mod_doc</span></code>, <code class="docutils literal notranslate"><span class="pre">Py_mod_clear</span></code>, etc.
Slots related to the module state rather than the module object will
use a <code class="docutils literal notranslate"><span class="pre">Py_mod_state_</span></code> prefix.
See <a class="reference internal" href="#pep793-api-summary"><span class="std std-ref">New API summary</span></a> for a full list.</p>
<p>All new slots – these and <code class="docutils literal notranslate"><span class="pre">Py_tp_token</span></code> discussed above – may not be
repeated in the slots array, and may not be used in a
<code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_slots</span></code> array.
They may not have a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> value (instead, the slot can be omitted entirely).</p>
<p>Note that currently, for modules created from a <em>spec</em> (that is, using
<code class="docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec</span></code>), the <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_name</span></code> member is ignored
and the name from the spec is used instead.
All API proposed in this document creates modules from a <em>spec</em>, and it will
ignore <code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code> in the same way.
The slot will be optional, but extension authors are strongly encouraged to
include it for the benefit of future APIs, external tooling, debugging,
and introspection.</p>
</section>
<section id="bits-pieces">
<h3><a class="toc-backref" href="#bits-pieces" role="doc-backlink">Bits &amp; Pieces</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">PyMODEXPORT_FUNC</span></code> macro will be added, similar to the <code class="docutils literal notranslate"><span class="pre">PyMODINIT_FUNC</span></code>
macro but with <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span> <span class="pre">*</span></code> as the return type.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">PyModule_GetStateSize</span></code> function will be added to retrieve the size set
by <code class="docutils literal notranslate"><span class="pre">Py_mod_state_size</span></code> or <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_size</span></code>.
Since the result may be -1 (for single-phase-init modules), it will be output
via a pointer; the function will return 0 on success and -1 on failure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">PyModule_GetStateSize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Soft-deprecating the existing export hook</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> export hook will be
<a class="reference internal" href="../pep-0387/#pep387-soft-deprecation"><span class="std std-ref">soft-deprecated</span></a>.</p>
</section>
<section id="new-api-summary">
<span id="pep793-api-summary"></span><h3><a class="toc-backref" href="#new-api-summary" role="doc-backlink">New API summary</a></h3>
<p>Python will load a new module export hook, with two variants:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">PyModExport_</span><span class="o">&lt;</span><span class="n">NAME</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">PyModExportU_</span><span class="o">&lt;</span><span class="n">ENCODED_NAME</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>The following functions will be added:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">PyModule_FromSlotsAndSpec</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">PyModule_Exec</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">PyModule_GetToken</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">**</span><span class="p">)</span>
<span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">PyType_GetModuleByToken</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">token</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">PyModule_GetStateSize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>A new macro will be added:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyMODEXPORT_FUNC</span>
</pre></div>
</div>
<p>And new slot types (<code class="docutils literal notranslate"><span class="pre">#define</span></code>d names for small integers):</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_name</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_doc</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_doc</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_state_size</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_size</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_methods</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_methods</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_state_traverse</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_traverse</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_state_clear</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_clear</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_state_free</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_free</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> (see above)</li>
</ul>
<p>All this will be added to the Limited API.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>If an existing module is ported to use the new mechanism, then
<code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code> will start returning <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for it.
(This matches <code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code>’s current documentation.)
We claim that how a module was defined is an implementation detail of that
module, so this should not be considered a breaking change.</p>
<p>Similarly, the <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> function may stop matching modules
whose definition changed. Module authors may avoid this by explicitly
setting a <em>def</em> as the <em>token</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> will now accept a module token as the <em>def</em> argument.
We specify a suitable restriction on using <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> addresses as tokens,
and non-<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> pointers were previously invalid input,
so this is not a backwards-compatibility issue.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> function may now be called with <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for the second
argument.
This could trip people porting from <em>def</em> to <em>slots</em>, so it needs to be
mentioned in porting notes.</p>
<section id="forward-compatibility">
<h3><a class="toc-backref" href="#forward-compatibility" role="doc-backlink">Forward compatibility</a></h3>
<p>If a module defines the new export hook, CPython versions that implement this
PEP will ignore the traditional <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> hook.</p>
<p>Extensions that straddle Python versions are expected to define both hooks;
each build of CPython will “pick” the newest one that it supports.</p>
</section>
<section id="porting-guide">
<span id="pep793-porting-notes"></span><h3><a class="toc-backref" href="#porting-guide" role="doc-backlink">Porting guide</a></h3>
<p>Here is a guide to convert an existing module to the new API, including
some tricky edge cases.
It should be moved to a HOWTO in the documentation.</p>
<p>This guide is meant for hand-written modules. For code generators and language
wrappers, the <a class="reference internal" href="#pep793-shim"><span class="std std-ref">Backwards compatibility shim</span></a> below may be more useful.</p>
<ol class="arabic">
<li>Scan your code for uses of <code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code>. This function will
return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for modules that use the new mechanism. Instead:<ul class="simple">
<li>For getting the contents of the module’s <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, use the C struct
directly. Alternatively, get attributes from the module using, for
example, <code class="docutils literal notranslate"><span class="pre">PyModule_GetNameObject</span></code>, the <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> attribute, and
<code class="docutils literal notranslate"><span class="pre">PyModule_GetStateSize</span></code>.
(Note that Python code can mutate a module’s attributes.)</li>
<li>For testing if a module object is “yours”, use <code class="docutils literal notranslate"><span class="pre">PyModule_GetToken</span></code>
instead.
Later in this guide, you’ll set the token to <em>be</em> the existing
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure.</li>
</ul>
</li>
<li>Optionally, scan your code for uses of <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code>,
and replace them with <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code>.
Later in this guide, you’ll set the token to <em>be</em> the existing
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure.<p>(You may skip this step if targetting Python versions that don’t expose
<code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code>, since <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> is
backwards-compatible.)</p>
</li>
<li>Look at the function identified by <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code>, if any.
Make sure that it does not use its second argument (<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>),
as it will be called with <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
Instead of the argument, use the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct directly.</li>
<li>If using multiple <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> slots, consolidate them: pick one of
the functions, or write a new one, and call the others from it.
Remove all but one <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> slots.</li>
<li>Make a copy of the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> array pointed to by
the <code class="docutils literal notranslate"><span class="pre">m_slots</span></code> member of your <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>. If you don’t have an
existing slots array, create one like this:<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">module_slots</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Give this array a unique name.
Further examples will assume that you’ve named it <code class="docutils literal notranslate"><span class="pre">module_slots</span></code>.</p>
</li>
<li>Add slots for all members of the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure.
See <a class="reference internal" href="#pep793-api-summary"><span class="std std-ref">New API summary</span></a> for a list of the new slots.
For example, to add a name and docstring:<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">module_slots</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mymodule&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_doc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;my docstring&quot;</span><span class="p">)},</span>
<span class="w">    </span><span class="c1">// ... (keep existing slots here)</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li>If you switched from <code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code> to <code class="docutils literal notranslate"><span class="pre">PyModule_GetToken</span></code>,
and/or if you use <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByDef</span></code> or <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code>,
add a <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> slot pointing to the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct:<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">module_slots</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ... (keep existing slots here)</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_token</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">your_module_def</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li>Add a new export hook.<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyMODEXPORT_FUNC</span><span class="w"> </span><span class="nf">PyModExport_examplemodule</span><span class="p">(</span><span class="n">PyObject</span><span class="p">);</span>

<span class="n">PyMODEXPORT_FUNC</span>
<span class="nf">PyModExport_examplemodule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">module_slots</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<p>The new export hook will be used on Python 3.15 and above.
Once your module no longer supports lower versions:</p>
<ol class="arabic simple">
<li>Delete the <code class="docutils literal notranslate"><span class="pre">PyInit_</span></code> function.</li>
<li>If the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct is used <em>only</em> for <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleByToken</span></code>, you may remove the <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code>
line and replace <code class="docutils literal notranslate"><span class="pre">&amp;your_module_def</span></code> with <code class="docutils literal notranslate"><span class="pre">module_slots</span></code> everywhere else.</li>
<li>Delete any unused data.
The <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct and the original slots array are likely to be
unused.</li>
</ol>
</section>
<section id="backwards-compatibility-shim">
<span id="pep793-shim"></span><h3><a class="toc-backref" href="#backwards-compatibility-shim" role="doc-backlink">Backwards compatibility shim</a></h3>
<p>It is possible to write a generic function that implements the “old” export
hook (<code class="docutils literal notranslate"><span class="pre">PyInit_</span></code>) in terms of the API proposed here.</p>
<p>The following implementation can be copied and pasted to a project; only the
names <code class="docutils literal notranslate"><span class="pre">PyInit_examplemodule</span></code> (twice) and <code class="docutils literal notranslate"><span class="pre">PyModExport_examplemodule</span></code> should
need adjusting.</p>
<p>When added to the <a class="reference internal" href="#pep793-example"><span class="std std-ref">Example</span></a> below and compiled with a
non-free-threaded build of this PEP’s reference implementation, the resulting
extension is compatible with non-free-threading 3.9+ builds, in addition to a
free-threading build of the reference implementation.
(The module must be named without a version tag, e.g. <code class="docutils literal notranslate"><span class="pre">examplemodule.so</span></code>,
and be placed on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.)</p>
<p>Full support for creating such modules will require backports of some new
API, and support in build/install tools. This is out of scope of this PEP.
(In particular, the demo “cheats” by using a subset of Limited API 3.15 that
<em>happens to work</em> on 3.9; a proper implementation would use Limited API 3.9
with backport shims for new API like <code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code>.)</p>
<p>This implementation places a few additional requirements on the slots array:</p>
<ul class="simple">
<li>Slots that correspond to <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> members must come first.</li>
<li>A <code class="docutils literal notranslate"><span class="pre">Py_mod_name</span></code> slot is required.</li>
<li>Any <code class="docutils literal notranslate"><span class="pre">Py_mod_token</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">&amp;module_def_and_token</span></code>, defined here.</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="c1">     // memset</span>

<span class="n">PyMODINIT_FUNC</span><span class="w"> </span><span class="nf">PyInit_examplemodule</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="w"> </span><span class="n">module_def_and_token</span><span class="p">;</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_examplemodule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">slot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyModExport_examplemodule</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">module_def_and_token</span><span class="p">.</span><span class="n">m_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Take care to only set up the static PyModuleDef once.</span>
<span class="w">        </span><span class="c1">// (PyModExport might theoretically return different data each time.)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PyModuleDef_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_def_and_token</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">copying_slots</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="cm">/* slot set above */</span><span class="p">;</span><span class="w"> </span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span><span class="w"> </span><span class="n">slot</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Set PyModuleDef members from slots. These slots must come first.</span>
<span class="cp">#       define COPYSLOT_CASE(SLOT, MEMBER, TYPE)                            \</span>
<span class="cp">            case SLOT:                                                      \</span>
<span class="cp">                if (!copying_slots) {                                       \</span>
<span class="cp">                    PyErr_SetString(PyExc_SystemError,                      \</span>
<span class="cp">                                    #SLOT &quot; must be specified earlier&quot;);    \</span>
<span class="cp">                    goto error;                                             \</span>
<span class="cp">                }                                                           \</span>
<span class="cp">                module_def_and_token.MEMBER = (TYPE)(slot-&gt;value);          \</span>
<span class="cp">                break;                                                      \</span>
<span class="cp">            </span><span class="c1">/////////////////////////////////////////////////////////////////</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_name</span><span class="p">,</span><span class="w"> </span><span class="n">m_name</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_doc</span><span class="p">,</span><span class="w"> </span><span class="n">m_doc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_state_size</span><span class="p">,</span><span class="w"> </span><span class="n">m_size</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_methods</span><span class="p">,</span><span class="w"> </span><span class="n">m_methods</span><span class="p">,</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="o">*</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_state_traverse</span><span class="p">,</span><span class="w"> </span><span class="n">m_traverse</span><span class="p">,</span><span class="w"> </span><span class="n">traverseproc</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_state_clear</span><span class="p">,</span><span class="w"> </span><span class="n">m_clear</span><span class="p">,</span><span class="w"> </span><span class="n">inquiry</span><span class="p">)</span>
<span class="w">        </span><span class="n">COPYSLOT_CASE</span><span class="p">(</span><span class="n">Py_mod_state_free</span><span class="p">,</span><span class="w"> </span><span class="n">m_free</span><span class="p">,</span><span class="w"> </span><span class="n">freefunc</span><span class="p">)</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">Py_mod_token</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// With PyInit_, the PyModuleDef is used as the token.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module_def_and_token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_SystemError</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;Py_mod_token must be set to &quot;</span>
<span class="w">                                </span><span class="s">&quot;&amp;module_def_and_token&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span>
<span class="w">            </span><span class="c1">// The remaining slots become m_slots in the def.</span>
<span class="w">            </span><span class="c1">// (`slot` now points to the &quot;rest&quot; of the original</span>
<span class="w">            </span><span class="c1">//  zero-terminated array.)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copying_slots</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">module_def_and_token</span><span class="p">.</span><span class="n">m_slots</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slot</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">copying_slots</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">module_def_and_token</span><span class="p">.</span><span class="n">m_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// This function needs m_name as the &quot;is initialized&quot; marker.</span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_SystemError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Py_mod_name slot is required&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyModuleDef_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_def_and_token</span><span class="p">);</span>

<span class="nl">error</span><span class="p">:</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_def_and_token</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">module_def_and_token</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>None known</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>In addition to regular reference docs, the <a class="reference internal" href="#pep793-porting-notes"><span class="std std-ref">Porting guide</span></a> should
be added as a new HOWTO.</p>
</section>
<section id="example">
<span id="pep793-example"></span><h2><a class="toc-backref" href="#example" role="doc-backlink">Example</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">Example module with C-level module-global state, and</span>

<span class="cm">- a simple function that updates and queries the state</span>
<span class="cm">- a class wihose repr() queries the same module state (as an example of</span>
<span class="cm">  PyType_GetModuleByToken)</span>

<span class="cm">Once compiled and renamed to not include a version tag (for example</span>
<span class="cm">examplemodule.so on Linux), this will run succesfully on both regular</span>
<span class="cm">and free-threaded builds.</span>

<span class="cm">Python usage:</span>

<span class="cm">import examplemodule</span>
<span class="cm">print(examplemodule.increment_value())  # 0</span>
<span class="cm">print(examplemodule.increment_value())  # 1</span>
<span class="cm">print(examplemodule.increment_value())  # 2</span>
<span class="cm">print(examplemodule.increment_value())  # 3</span>


<span class="cm">class Subclass(examplemodule.ExampleType):</span>
<span class="cm">    pass</span>

<span class="cm">instance = Subclass()</span>
<span class="cm">print(instance)  # &lt;Subclass object; module value = 3&gt;</span>

<span class="cm">*/</span>

<span class="c1">// Avoid CPython-version-specific ABI (inline functions &amp; macros):</span>
<span class="cp">#define Py_LIMITED_API 0x030f0000  </span><span class="c1">// 3.15</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Python.h&gt;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">examplemodule_state</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">examplemodule_slots</span><span class="p">[];</span>

<span class="c1">// increment_value function</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">increment_value</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">_ignored</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">examplemodule_state</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="n">examplemodule_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;increment_value&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">increment_value</span><span class="p">,</span><span class="w"> </span><span class="n">METH_NOARGS</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ExampleType</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">exampletype_repr</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* To get module state, we cannot use PyModule_GetState(Py_TYPE(self)),</span>
<span class="cm">     * since Py_TYPE(self) might be a subclass defined in an unrelated module.</span>
<span class="cm">     * So, use PyType_GetModuleByToken.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GetModuleByToken</span><span class="p">(</span>
<span class="w">        </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">),</span><span class="w"> </span><span class="n">examplemodule_slots</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">module</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">examplemodule_state</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;&lt;%T object; module value = %d&gt;&quot;</span><span class="p">,</span>
<span class="w">                                </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyType_Spec</span><span class="w"> </span><span class="n">exampletype_spec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;examplemodule.ExampleType&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">slots</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyType_Slot</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="n">Py_tp_repr</span><span class="p">,</span><span class="w"> </span><span class="n">exampletype_repr</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Module</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">examplemodule_exec</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">examplemodule_state</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyTypeObject</span><span class="o">*</span><span class="p">)</span><span class="n">PyType_FromModuleAndSpec</span><span class="p">(</span>
<span class="w">        </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exampletype_spec</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyModule_AddType</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PyDoc_STRVAR</span><span class="p">(</span><span class="n">examplemodule_doc</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Example extension.&quot;</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">examplemodule_slots</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;examplemodule&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_doc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">examplemodule_doc</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_methods</span><span class="p">,</span><span class="w"> </span><span class="n">examplemodule_methods</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_state_size</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">examplemodule_state</span><span class="p">)},</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_exec</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">examplemodule_exec</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Avoid &quot;implicit declaration of function&quot; warning:</span>
<span class="n">PyMODEXPORT_FUNC</span><span class="w"> </span><span class="nf">PyModExport_examplemodule</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">PyMODEXPORT_FUNC</span>
<span class="nf">PyModExport_examplemodule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">examplemodule_slots</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A draft implementation is available in a
<a class="reference external" href="https://github.com/python/cpython/compare/main...encukou:cpython:modexport#files_bucket">GitHub branch</a>.</p>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h2>
<p>(Add yours!)</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="exporting-a-data-pointer-rather-than-a-function">
<h3><a class="toc-backref" href="#exporting-a-data-pointer-rather-than-a-function" role="doc-backlink">Exporting a data pointer rather than a function</a></h3>
<p>This proposes a new module export <em>function</em>, which is expected to
return static constant data.
That data could be exported directly as a data pointer.</p>
<p>With a function, we avoid dealing with a new kind of exported symbol.</p>
<p>A function also allows the extension to introspect its environment in a limited
way – for example, to tailor the returned data to the current Python version.</p>
</section>
<section id="changing-pymoduledef-to-not-be-pyobject">
<h3><a class="toc-backref" href="#changing-pymoduledef-to-not-be-pyobject" role="doc-backlink">Changing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> to not be <code class="docutils literal notranslate"><span class="pre">PyObject</span></code></a></h3>
<p>It is possible to change <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> to no longer include the <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>
header, and continue using the current <code class="docutils literal notranslate"><span class="pre">PyInit_*</span></code> hook.
There are several issues with this approach:</p>
<ul>
<li>The import machinery would need to examine bit-patterns in the objects to
distinguish between different memory layouts:<ul class="simple">
<li>the “old” <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>-based <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>, returned by current <code class="docutils literal notranslate"><span class="pre">abi3</span></code>
extensions,</li>
<li>the new <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">PyObject</span></code>-based module objects, for single-phase initialization.</li>
</ul>
<p>This is fragile, and places constraints on future changes to <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>:
the memory layouts need to stay <em>distinguishable</em> until both single-phase
initialization and the current Stable ABI are no longer supported.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">PyModuleDef_Init</span></code> is documented to “Ensure a module definition is a
properly initialized Python object that correctly reports its type and
a reference count.”
This would need to change without warning, breaking any user code that treats
<code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>s as Python objects.</li>
</ul>
</section>
</section>
<section id="possible-future-directions">
<h2><a class="toc-backref" href="#possible-future-directions" role="doc-backlink">Possible Future Directions</a></h2>
<p>These ideas are out of scope for <em>this</em> proposal.</p>
<section id="improving-slots-in-general">
<h3><a class="toc-backref" href="#improving-slots-in-general" role="doc-backlink">Improving slots in general</a></h3>
<p>Slots – and specifically the existing <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> – do have a few
shortcomings. The most important are:</p>
<ul>
<li>Type safety: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> is used for data pointers, function pointers
and small integers, requiring casting that is technically undefined
behaviour in C – but works in practice on all relevant architectures.
(For example: <code class="docutils literal notranslate"><span class="pre">Py_tp_doc</span></code> marks a string; <code class="docutils literal notranslate"><span class="pre">Py_mod_gil</span></code> an integer.)</li>
<li>Limited forward compatibility: if an extension provides a slot ID that’s
unknown to the current interpreter, module creation will fail.
This makes it cumbersome to use “optional” features – ones that should only
take effect if the interpreter supports them.
(The recently added slots <code class="docutils literal notranslate"><span class="pre">Py_mod_gil</span></code> and <code class="docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code>
are good examples.)<p>One workaround is to check <code class="docutils literal notranslate"><span class="pre">Py_Version</span></code> in the export function,
and return a slot array suitable for the current interpreter.</p>
</li>
</ul>
</section>
<section id="updating-defaults">
<h3><a class="toc-backref" href="#updating-defaults" role="doc-backlink">Updating defaults</a></h3>
<p>With a new API, we could update defaults for the
<code class="docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code> and <code class="docutils literal notranslate"><span class="pre">Py_mod_gil</span></code> slots.</p>
</section>
<section id="the-inittab">
<h3><a class="toc-backref" href="#the-inittab" role="doc-backlink">The inittab</a></h3>
<p>We’ll need to allow <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>-less slots in the inittab –
that is, add a new variant of <code class="docutils literal notranslate"><span class="pre">PyImport_ExtendInittab</span></code>.
Should that be part of this PEP?</p>
<p>The inittab is used for embedding, where a common/stable ABI is not that
important. So, it might be OK to leave this to a later change.</p>
</section>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="multiexec" role="doc-footnote">
<dt class="label" id="multiexec">[<a href="#id1">1</a>]</dt>
<dd>A <a class="reference external" href="https://github.com/python/peps/pull/4435#discussion_r2105731314">quick survey</a> of multiple <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> slots found zero
uses in the top 15,000 PyPI projects, and three in the stardard library
(including tests for the feature).
The easy workaround is consolidating the <code class="docutils literal notranslate"><span class="pre">exec</span></code> functions; see
<a class="reference internal" href="#pep793-porting-notes"><span class="std std-ref">Porting guide</span></a> for details.</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0793.rst">https://github.com/python/peps/blob/main/peps/pep-0793.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0793.rst">2025-10-16 14:03:05 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background-motivation">Background &amp; Motivation</a><ul>
<li><a class="reference internal" href="#the-interpreter-switch">The interpreter switch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#using-slots-without-a-wrapper-struct">Using slots without a wrapper struct</a></li>
<li><a class="reference internal" href="#tokens">Tokens</a></li>
<li><a class="reference internal" href="#soft-deprecating-the-existing-export-hook">Soft-deprecating the existing export hook</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#the-export-hook">The export hook</a></li>
<li><a class="reference internal" href="#dynamic-creation">Dynamic creation</a></li>
<li><a class="reference internal" href="#pep793-token">Tokens</a></li>
<li><a class="reference internal" href="#new-slots">New slots</a></li>
<li><a class="reference internal" href="#bits-pieces">Bits &amp; Pieces</a></li>
<li><a class="reference internal" href="#id3">Soft-deprecating the existing export hook</a></li>
<li><a class="reference internal" href="#new-api-summary">New API summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#forward-compatibility">Forward compatibility</a></li>
<li><a class="reference internal" href="#porting-guide">Porting guide</a></li>
<li><a class="reference internal" href="#backwards-compatibility-shim">Backwards compatibility shim</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#exporting-a-data-pointer-rather-than-a-function">Exporting a data pointer rather than a function</a></li>
<li><a class="reference internal" href="#changing-pymoduledef-to-not-be-pyobject">Changing <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> to not be <code class="docutils literal notranslate"><span class="pre">PyObject</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-future-directions">Possible Future Directions</a><ul>
<li><a class="reference internal" href="#improving-slots-in-general">Improving slots in general</a></li>
<li><a class="reference internal" href="#updating-defaults">Updating defaults</a></li>
<li><a class="reference internal" href="#the-inittab">The inittab</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0793.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>