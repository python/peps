
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 330 – Python Bytecode Verification | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0330/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 330 – Python Bytecode Verification | peps.python.org'>
    <meta property="og:description" content="If Python Virtual Machine (PVM) bytecode is not “well-formed” it is possible to crash or exploit the PVM by causing various errors such as under/overflowing the value stack or reading/writing into arbitrary areas of the PVM program space.  Most of these...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0330/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="If Python Virtual Machine (PVM) bytecode is not “well-formed” it is possible to crash or exploit the PVM by causing various errors such as under/overflowing the value stack or reading/writing into arbitrary areas of the PVM program space.  Most of these...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 330</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 330 – Python Bytecode Verification" data-pagefind-weight="10" class="visually-hidden">PEP 330 – Python Bytecode Verification</span>
            <section id="pep-content">
<h1 class="page-title">PEP 330 – Python Bytecode Verification</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Michel Pelletier &lt;michel&#32;&#97;t&#32;users.sourceforge.net&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Formally declined and will not be accepted">Rejected</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">17-Jun-2004</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">2.6</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement">Pronouncement</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instructions">Static Constraints on Bytecode Instructions</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instruction-operands">Static Constraints on Bytecode Instruction Operands</a></li>
<li><a class="reference internal" href="#structural-constraints-between-bytecode-instructions">Structural Constraints between Bytecode Instructions</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#verification-issues">Verification Issues</a></li>
<li><a class="reference internal" href="#required-changes">Required Changes</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>If Python Virtual Machine (PVM) bytecode is not “well-formed” it
is possible to crash or exploit the PVM by causing various errors
such as under/overflowing the value stack or reading/writing into
arbitrary areas of the PVM program space.  Most of these kinds of
errors can be eliminated by verifying that PVM bytecode does not
violate a set of simple constraints before execution.</p>
<p>This PEP proposes a set of constraints on the format and structure
of Python Virtual Machine (PVM) bytecode and provides an
implementation in Python of this verification process.</p>
</section>
<section id="pronouncement">
<h2><a class="toc-backref" href="#pronouncement" role="doc-backlink">Pronouncement</a></h2>
<p>Guido believes that a verification tool has some value.  If
someone wants to add it to <code class="docutils literal notranslate"><span class="pre">Tools/scripts</span></code>, no PEP is required.</p>
<p>Such a tool may have value for validating the output from
“bytecodehacks” or from direct edits of PYC files.  As security
measure, its value is somewhat limited because perfectly valid
bytecode can still do horrible things.  That situation could
change if the concept of restricted execution were to be
successfully resurrected.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The Python Virtual Machine executes Python programs that have been
compiled from the Python language into a bytecode representation.
The PVM assumes that any bytecode being executed is “well-formed”
with regard to a number implicit constraints.  Some of these
constraints are checked at run-time, but most of them are not due
to the overhead they would create.</p>
<p>When running in debug mode the PVM does do several run-time checks
to ensure that any particular bytecode cannot violate these
constraints that, to a degree, prevent bytecode from crashing or
exploiting the interpreter.  These checks add a measurable
overhead to the interpreter, and are typically turned off in
common use.</p>
<p>Bytecode that is not well-formed and executed by a PVM not running
in debug mode may create a variety of fatal and non-fatal errors.
Typically, ill-formed code will cause the PVM to seg-fault and
cause the OS to immediately and abruptly terminate the
interpreter.</p>
<p>Conceivably, ill-formed bytecode could exploit the interpreter and
allow Python bytecode to execute arbitrary C-level machine
instructions or to modify private, internal data structures in the
interpreter.  If used cleverly this could subvert any form of
security policy an application may want to apply to its objects.</p>
<p>Practically, it would be difficult for a malicious user to
“inject” invalid bytecode into a PVM for the purposes of
exploitation, but not impossible.  Buffer overflow and memory
overwrite attacks are commonly understood, particularly when the
exploit payload is transmitted unencrypted over a network or when
a file or network security permission weakness is used as a
foothold for further attacks.</p>
<p>Ideally, no bytecode should ever be allowed to read or write
underlying C-level data structures to subvert the operation of the
PVM, whether the bytecode was maliciously crafted or not.  A
simple pre-execution verification step could ensure that bytecode
cannot over/underflow the value stack or access other sensitive
areas of PVM program space at run-time.</p>
<p>This PEP proposes several validation steps that should be taken on
Python bytecode before it is executed by the PVM so that it
compiles with static and structure constraints on its instructions
and their operands.  These steps are simple and catch a large
class of invalid bytecode that can cause crashes.  There is also
some possibility that some run-time checks can be eliminated up
front by a verification pass.</p>
<p>There is, of course, no way to verify that bytecode is “completely
safe”, for every definition of complete and safe.  Even with
bytecode verification, Python programs can and most likely in the
future will seg-fault for a variety of reasons and continue to
cause many different classes of run-time errors, fatal or not.
The verification step proposed here simply plugs an easy hole that
can cause a large class of fatal and subtle errors at the bytecode
level.</p>
<p>Currently, the Java Virtual Machine (JVM) verifies Java bytecode
in a way very similar to what is proposed here.  The JVM
Specification version 2 <a class="footnote-reference brackets" href="#id2" id="id1">[1]</a>, Sections 4.8 and 4.9 were therefore
used as a basis for some of the constraints explained below.  Any
Python bytecode verification implementation at a minimum must
enforce these constraints, but may not be limited to them.</p>
</section>
<section id="static-constraints-on-bytecode-instructions">
<h2><a class="toc-backref" href="#static-constraints-on-bytecode-instructions" role="doc-backlink">Static Constraints on Bytecode Instructions</a></h2>
<ol class="arabic simple">
<li>The bytecode string must not be empty. (<code class="docutils literal notranslate"><span class="pre">len(co_code)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>).</li>
<li>The bytecode string cannot exceed a maximum size
(<code class="docutils literal notranslate"><span class="pre">len(co_code)</span> <span class="pre">&lt;</span> <span class="pre">sizeof(unsigned</span> <span class="pre">char)</span> <span class="pre">-</span> <span class="pre">1</span></code>).</li>
<li>The first instruction in the bytecode string begins at index 0.</li>
<li>Only valid byte-codes with the correct number of operands can
be in the bytecode string.</li>
</ol>
</section>
<section id="static-constraints-on-bytecode-instruction-operands">
<h2><a class="toc-backref" href="#static-constraints-on-bytecode-instruction-operands" role="doc-backlink">Static Constraints on Bytecode Instruction Operands</a></h2>
<ol class="arabic simple">
<li>The target of a jump instruction must be within the code
boundaries and must fall on an instruction, never between an
instruction and its operands.</li>
<li>The operand of a <code class="docutils literal notranslate"><span class="pre">LOAD_*</span></code> instruction must be a valid index into
its corresponding data structure.</li>
<li>The operand of a <code class="docutils literal notranslate"><span class="pre">STORE_*</span></code> instruction must be a valid index
into its corresponding data structure.</li>
</ol>
</section>
<section id="structural-constraints-between-bytecode-instructions">
<h2><a class="toc-backref" href="#structural-constraints-between-bytecode-instructions" role="doc-backlink">Structural Constraints between Bytecode Instructions</a></h2>
<ol class="arabic simple">
<li>Each instruction must only be executed with the appropriate
number of arguments in the value stack, regardless of the
execution path that leads to its invocation.</li>
<li>If an instruction can be executed along several different
execution paths, the value stack must have the same depth prior
to the execution of the instruction, regardless of the path
taken.</li>
<li>At no point during execution can the value stack grow to a
depth greater than that implied by <code class="docutils literal notranslate"><span class="pre">co_stacksize</span></code>.</li>
<li>Execution never falls off the bottom of <code class="docutils literal notranslate"><span class="pre">co_code</span></code>.</li>
</ol>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>This PEP is the working document for a Python bytecode
verification implementation written in Python.  This
implementation is not used implicitly by the PVM before executing
any bytecode, but is to be used explicitly by users concerned
about possibly invalid bytecode with the following snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">verify</span>
<span class="n">verify</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">verify</span></code> module provides a <code class="docutils literal notranslate"><span class="pre">verify</span></code> function which accepts the
same kind of arguments as <code class="docutils literal notranslate"><span class="pre">dis.dis</span></code>: classes, methods, functions,
or code objects.  It verifies that the object’s bytecode is
well-formed according to the specifications of this PEP.</p>
<p>If the code is well-formed the call to <code class="docutils literal notranslate"><span class="pre">verify</span></code> returns silently
without error.  If an error is encountered, it throws a
<code class="docutils literal notranslate"><span class="pre">VerificationError</span></code> whose argument indicates the cause of the
failure.  It is up to the programmer whether or not to handle the
error in some way or execute the invalid code regardless.</p>
<p>Phillip Eby has proposed a pseudo-code algorithm for bytecode
stack depth verification used by the reference implementation.</p>
</section>
<section id="verification-issues">
<h2><a class="toc-backref" href="#verification-issues" role="doc-backlink">Verification Issues</a></h2>
<p>This PEP describes only a small number of verifications.  While
discussion and analysis will lead to many more, it is highly
possible that future verification may need to be done or custom,
project-specific verifications.  For this reason, it might be
desirable to add a verification registration interface to the test
implementation to register future verifiers.  The need for this is
minimal since custom verifiers can subclass and extend the current
implementation for added behavior.</p>
</section>
<section id="required-changes">
<h2><a class="toc-backref" href="#required-changes" role="doc-backlink">Required Changes</a></h2>
<p>Armin Rigo noted that several byte-codes will need modification in
order for their stack effect to be statically analyzed.  These are
<code class="docutils literal notranslate"><span class="pre">END_FINALLY</span></code>, <code class="docutils literal notranslate"><span class="pre">POP_BLOCK</span></code>, and <code class="docutils literal notranslate"><span class="pre">MAKE_CLOSURE</span></code>.  Armin and Guido have
already agreed on how to correct the instructions.  Currently the
Python implementation punts on these instructions.</p>
<p>This PEP does not propose to add the verification step to the
interpreter, but only to provide the Python implementation in the
standard library for optional use.  Whether or not this
verification procedure is translated into C, included with the PVM
or enforced in any way is left for future discussion.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<dt class="label" id="id2">[<a href="#id1">1</a>]</dt>
<dd>The Java Virtual Machine Specification 2nd Edition
<a class="reference external" href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0330.rst">https://github.com/python/peps/blob/main/peps/pep-0330.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0330.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement">Pronouncement</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instructions">Static Constraints on Bytecode Instructions</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instruction-operands">Static Constraints on Bytecode Instruction Operands</a></li>
<li><a class="reference internal" href="#structural-constraints-between-bytecode-instructions">Structural Constraints between Bytecode Instructions</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#verification-issues">Verification Issues</a></li>
<li><a class="reference internal" href="#required-changes">Required Changes</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0330.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>