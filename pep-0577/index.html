
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 577 – Augmented Assignment Expressions | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0577/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 577 – Augmented Assignment Expressions | peps.python.org'>
    <meta property="og:description" content="This is a proposal to allow augmented assignments such as x += 1 to be used as expressions, not just statements.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0577/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This is a proposal to allow augmented assignments such as x += 1 to be used as expressions, not just statements.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 577</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 577 – Augmented Assignment Expressions" data-pagefind-weight="10" class="visually-hidden">PEP 577 – Augmented Assignment Expressions</span>
            <section id="pep-content">
<h1 class="page-title">PEP 577 – Augmented Assignment Expressions</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Removed from consideration by sponsor or authors">Withdrawn</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">14-May-2018</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.8</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even">22-May-2018</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#pep-withdrawal">PEP Withdrawal</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#syntax-and-semantics">Syntax and semantics</a><ul>
<li><a class="reference internal" href="#augmented-assignment-expressions">Augmented assignment expressions</a></li>
<li><a class="reference internal" href="#adding-an-inline-assignment-operator">Adding an inline assignment operator</a></li>
<li><a class="reference internal" href="#assignment-operator-precedence">Assignment operator precedence</a></li>
<li><a class="reference internal" href="#augmented-assignment-to-names-in-block-scopes">Augmented assignment to names in block scopes</a></li>
<li><a class="reference internal" href="#augmented-assignment-to-names-in-scoped-expressions">Augmented assignment to names in scoped expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design discussion</a><ul>
<li><a class="reference internal" href="#allowing-complex-assignment-targets">Allowing complex assignment targets</a></li>
<li><a class="reference internal" href="#augmented-assignment-or-name-binding-only">Augmented assignment or name binding only?</a></li>
<li><a class="reference internal" href="#postponing-a-decision-on-expression-level-target-declarations">Postponing a decision on expression level target declarations</a></li>
<li><a class="reference internal" href="#ignoring-scoped-expressions-when-determining-augmented-assignment-targets">Ignoring scoped expressions when determining augmented assignment targets</a></li>
<li><a class="reference internal" href="#treating-inline-assignment-as-an-augmented-assignment-variant">Treating inline assignment as an augmented assignment variant</a></li>
<li><a class="reference internal" href="#disallowing-augmented-assignments-in-class-level-scoped-expressions">Disallowing augmented assignments in class level scoped expressions</a></li>
<li><a class="reference internal" href="#comparison-operators-vs-assignment-operators">Comparison operators vs assignment operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#simplifying-retry-loops">Simplifying retry loops</a></li>
<li><a class="reference internal" href="#simplifying-if-elif-chains">Simplifying if-elif chains</a></li>
<li><a class="reference internal" href="#capturing-intermediate-values-from-comprehensions">Capturing intermediate values from comprehensions</a></li>
<li><a class="reference internal" href="#allowing-lambda-expressions-to-act-more-like-re-usable-code-thunks">Allowing lambda expressions to act more like re-usable code thunks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relationship-with-pep-572">Relationship with PEP 572</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="pep-withdrawal">
<h2><a class="toc-backref" href="#pep-withdrawal" role="doc-backlink">PEP Withdrawal</a></h2>
<p>While working on this PEP, I realised that it didn’t really address what was
actually bothering me about <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>’s proposed scoping rules for previously
unreferenced assignment targets, and also had some significant undesirable
consequences (most notably, allowing <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> as inline augmented
assignment operators that meant something entirely different from the <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>
and <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> comparison operators).</p>
<p>I also realised that even without dedicated syntax of their own, <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>
technically allows inline augmented assignments to be written using the
<code class="docutils literal notranslate"><span class="pre">operator</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">iadd</span>
<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">:=</span> <span class="n">iadd</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The restriction to simple names as inline assignment targets means that the
target expression can always be repeated without side effects, and thus avoids
the ambiguity that would arise from allowing actual embedded augmented
assignments (it’s still a bad idea, since it would almost certainly be hard
for humans to read, this note is just about the theoretical limits of language
level expressiveness).</p>
<p>Accordingly, I withdrew this PEP without submitting it for pronouncement. At
the time I also started writing a replacement PEP that focused specifically on
the handling of assignment targets which hadn’t already been declared as local
variables in the current scope (for both regular block scopes, and for scoped
expressions), but that draft never even reached a stage where <em>I</em> liked it
better than the ultimately accepted proposal in <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, so it was never
posted anywhere, nor assigned a PEP number.</p>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This is a proposal to allow augmented assignments such as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> to be
used as expressions, not just statements.</p>
<p>As part of this, <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> is proposed as an inline assignment expression
that uses the new augmented assignment scoping rules, rather than implicitly
defining a new local variable name the way that existing name binding
statements do. The question of allowing expression level local variable
declarations at function scope is deliberately separated from the question of
allowing expression level name bindings, and deferred to a later PEP.</p>
<p>This PEP is a direct competitor to <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> (although it borrows heavily from that
PEP’s motivation, and even shares the proposed syntax for inline assignments).
See <a class="reference internal" href="#relationship-with-pep-572">Relationship with PEP 572</a> for more details on the connections between
the two PEPs.</p>
<p>To improve the usability of the new expressions, a semantic split is proposed
between the handling of augmented assignments in regular block scopes (modules,
classes, and functions), and the handling of augmented assignments in scoped
expressions (lambda expressions, generator expressions, and comprehensions),
such that all inline assignments default to targeting the nearest containing
block scope.</p>
<p>A new compile time <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> is added as a subclass of <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>
to handle cases where it is deemed to be currently unclear which target is
expected to be rebound by an inline assignment, or else the target scope
for the inline assignment is considered invalid for another reason.</p>
</section>
<section id="syntax-and-semantics">
<h2><a class="toc-backref" href="#syntax-and-semantics" role="doc-backlink">Syntax and semantics</a></h2>
<section id="augmented-assignment-expressions">
<h3><a class="toc-backref" href="#augmented-assignment-expressions" role="doc-backlink">Augmented assignment expressions</a></h3>
<p>The language grammar would be adjusted to allow augmented assignments to
appear as expressions, where the result of the augmented assignment
expression is the same post-calculation reference as is being bound to the
given target.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">+=</span> <span class="mi">5</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">*=</span> <span class="mi">3</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">9</span>
</pre></div>
</div>
<p>For mutable targets, this means the result is always just the original object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">+=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Augmented assignments to attributes and container subscripts will be permitted,
with the result being the post-calculation reference being bound to the target,
just as it is for simple name targets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="n">step</span>
</pre></div>
</div>
<p>In these cases, <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> and <code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code> will <em>not</em> be called
after the assignment has already taken place (they will only be called as
needed to evaluate the in-place operation).</p>
</section>
<section id="adding-an-inline-assignment-operator">
<h3><a class="toc-backref" href="#adding-an-inline-assignment-operator" role="doc-backlink">Adding an inline assignment operator</a></h3>
<p>Given only the addition of augmented assignment expressions, it would be
possible to abuse a symbol like <code class="docutils literal notranslate"><span class="pre">|=</span></code> as a general purpose assignment
operator by defining a <code class="docutils literal notranslate"><span class="pre">Target</span></code> wrapper type that worked as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Target</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">Target</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Target</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">|=</span> <span class="mi">42</span>
<span class="go">&lt;__main__.Target object at 0x7f608caa8048&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">42</span>
</pre></div>
</div>
<p>This is similar to the way that storing a single reference in a list was long
used as a workaround for the lack of a <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> keyword, and can still be
used today (in combination with <code class="docutils literal notranslate"><span class="pre">operator.itemsetter</span></code>) to work around the
lack of expression level assignments.</p>
<p>Rather than requiring such workarounds, this PEP instead proposes that
<a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>’s “NAME := EXPR” syntax be adopted as a new inline assignment
expression that uses the augmented assignment scoping rules described below.</p>
<p>This cleanly handles cases where only the new value is of interest, and the
previously bound value (if any) can just be discarded completely.</p>
<p>Note that for both simple names and complex assignment targets, the inline
assignment operator does <em>not</em> read the previous reference before assigning
the new one. However, when used at function scope (either directly or inside
a scoped expression), it does <em>not</em> implicitly define a new local variable,
and will instead raise <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> (as described for augmented
assignments below).</p>
</section>
<section id="assignment-operator-precedence">
<h3><a class="toc-backref" href="#assignment-operator-precedence" role="doc-backlink">Assignment operator precedence</a></h3>
<p>To preserve the existing semantics of augmented assignment statements,
inline assignment operators will be defined as being of lower precedence
than all other operators, include the comma pseudo-operator. This ensures
that when used as a top level expression the entire right hand side of the
expression is still interpreted as the value to be processed (even when that
value is a tuple without parentheses).</p>
<p>The difference this introduces relative to <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> is that where
<code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">:=</span> <span class="pre">first,</span> <span class="pre">second)</span></code> sets <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">first</span></code> in <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, in this PEP it would set
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">(first,</span> <span class="pre">second)</span></code>, and getting the first meaning would require an extra
set of parentheses (<code class="docutils literal notranslate"><span class="pre">((n</span> <span class="pre">:=</span> <span class="pre">first),</span> <span class="pre">second)</span></code>).</p>
<p><a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> quite reasonably notes that this results in ambiguity when assignment
expressions are used as function call arguments. This PEP resolves that concern
a different way by requiring that assignment expressions be parenthesised
when used as arguments to a function call (unless they’re the sole argument).</p>
<p>This is a more relaxed version of the restriction placed on generator
expressions (which always require parentheses, except when they’re the sole
argument to a function call).</p>
</section>
<section id="augmented-assignment-to-names-in-block-scopes">
<h3><a class="toc-backref" href="#augmented-assignment-to-names-in-block-scopes" role="doc-backlink">Augmented assignment to names in block scopes</a></h3>
<p>No target name binding changes are proposed for augmented assignments at module
or class scope (this also includes code executed using “exec” or “eval”). These
will continue to implicitly declare a new local variable as the binding target
as they do today, and (if necessary) will be able to resolve the name from an
outer scope before binding it locally.</p>
<p>At function scope, augmented assignments will be changed to require that there
be either a preceding name binding or variable declaration to explicitly
establish the target name as being local to the function, or else an explicit
<code class="docutils literal notranslate"><span class="pre">global</span></code> or <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> declaration. <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>, a new
<code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> subclass, will be raised at compile time if no such binding or
declaration is present.</p>
<p>For example, the following code would compile and run as it does today:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Sets global &quot;x&quot; to 1</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Sets local &quot;x&quot; to 2, leaves global &quot;x&quot; alone</span>

<span class="k">def</span><span class="w"> </span><span class="nf">local_target</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Sets local &quot;x&quot; to 1, leaves global &quot;x&quot; alone</span>

<span class="k">def</span><span class="w"> </span><span class="nf">global_target</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">x</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Increments global &quot;x&quot; each time this runs</span>

<span class="k">def</span><span class="w"> </span><span class="nf">nonlocal_target</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Increments &quot;x&quot; in outer scope each time this runs</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
<p>The follow examples would all still compile and then raise an error at runtime
as they do today:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Raises NameError at runtime</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Raises NameError at runtime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">missing_global</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">n</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Raises NameError at runtime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">delayed_nonlocal_initialisation</span><span class="p">():</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">f</span><span class="p">()</span> <span class="c1"># Raises NameError at runtime</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">skipped_conditional_initialisation</span><span class="p">():</span>
    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Raises UnboundLocalError at runtime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">local_declaration_without_initial_assignment</span><span class="p">():</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Any</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Raises UnboundLocalError at runtime</span>
</pre></div>
</div>
<p>Whereas the following would raise a compile time <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code>
initially, and eventually change to report a compile time <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">missing_target</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Compile time TargetNameError due to ambiguous target scope</span>
           <span class="c1"># Is there a missing initialisation of &quot;x&quot; here? Or a missing</span>
           <span class="c1"># global or nonlocal declaration?</span>
</pre></div>
</div>
<p>As a conservative implementation approach, the compile time function name
resolution change would be introduced as a <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code> in Python
3.8, and then converted to <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> in Python 3.9. This avoids
potential problems in cases where an unused function would currently raise
<code class="docutils literal notranslate"><span class="pre">UnboundLocalError</span></code> if it was ever actually called, but the code is actually
unused - converting that latent runtime defect to a compile time error qualifies
as a backwards incompatible change that requires a deprecation period.</p>
<p>When augmented assignments are used as expressions in function scope (rather
than as standalone statements), there aren’t any backwards compatibility
concerns, so the compile time name binding checks would be enforced immediately
in Python 3.8.</p>
<p>Similarly, the new inline assignment expressions would always require explicit
predeclaration of their target scope when used as part of a function, at least
for Python 3.8. (See the design discussion section for notes on potentially
revisiting that restriction in the future).</p>
</section>
<section id="augmented-assignment-to-names-in-scoped-expressions">
<h3><a class="toc-backref" href="#augmented-assignment-to-names-in-scoped-expressions" role="doc-backlink">Augmented assignment to names in scoped expressions</a></h3>
<p>Scoped expressions is a new collective term being proposed for expressions that
introduce a new nested scope of execution, either as an intrinsic part of their
operation (lambda expressions, generator expressions), or else as a way of
hiding name binding operations from the containing scope (container
comprehensions).</p>
<p>Unlike regular functions, these scoped expressions can’t include explicit
<code class="docutils literal notranslate"><span class="pre">global</span></code> or <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> declarations to rebind names directly in an outer
scope.</p>
<p>Instead, their name binding semantics for augmented assignment expressions would
be defined as follows:</p>
<ul class="simple">
<li>augmented assignment targets used in scoped expressions are expected to either
be already bound in the containing block scope, or else have their scope
explicitly declared in the containing block scope. If no suitable name
binding or declaration can be found in that scope, then <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>
will be raised at compile time (rather than creating a new binding within
the scoped expression).</li>
<li>if the containing block scope is a function scope, and the target name is
explicitly declared as <code class="docutils literal notranslate"><span class="pre">global</span></code> or <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code>, then it will be use the
same scope declaration in the body of the scoped expression</li>
<li>if the containing block scope is a function scope, and the target name is
a local variable in that function, then it will be implicitly declared as
<code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> in the body of the scoped expression</li>
<li>if the containing block scope is a class scope, than <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> will
always be raised, with a dedicated message indicating that combining class
scopes with augmented assignments in scoped expressions is not currently
permitted.</li>
<li>if a name is declared as a formal parameter (lambda expressions), or as an
iteration variable (generator expressions, comprehensions), then that name
is considered local to that scoped expression, and attempting to use it as
the target of an augmented assignment operation in that scope, or any nested
scoped expression, will raise <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> (this is a restriction that
could potentially be lifted later, but is being proposed for now to simplify
the initial set of compile time and runtime semantics that needs to be
covered in the language reference and handled by the compiler and interpreter)</li>
</ul>
<p>For example, the following code would work as shown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">global_target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">incr_global_target</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">global_target</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">incr_global_target</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">incr_global_target</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_target</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">cumulative_sums</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">total</span> <span class="o">=</span> <span class="n">start</span>
<span class="gp">... </span>   <span class="k">yield from</span> <span class="p">(</span><span class="n">total</span> <span class="o">+=</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">total</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cumulative_sums</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
<span class="go">[0, 1, 3, 6, 10]</span>
</pre></div>
</div>
<p>While the following examples would all raise <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">cls_target</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">incr_cls_target</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">cls_target</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Error due to class scope</span>

<span class="k">def</span><span class="w"> </span><span class="nf">missing_target</span><span class="p">():</span>
    <span class="n">incr_x</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Error due to missing target &quot;x&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">late_target</span><span class="p">():</span>
    <span class="n">incr_x</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Error due to &quot;x&quot; being declared after use</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">arg</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Error due to attempt to target formal parameter</span>

<span class="p">[</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span> <span class="c1"># Error due to attempt to target iteration variable</span>
</pre></div>
</div>
<p>As augmented assignments currently can’t appear inside scoped expressions, the
above compile time name resolution exceptions would be included as part of the
initial implementation rather than needing to be phased in as a potentially
backwards incompatible change.</p>
</section>
</section>
<section id="design-discussion">
<h2><a class="toc-backref" href="#design-discussion" role="doc-backlink">Design discussion</a></h2>
<section id="allowing-complex-assignment-targets">
<h3><a class="toc-backref" href="#allowing-complex-assignment-targets" role="doc-backlink">Allowing complex assignment targets</a></h3>
<p>The initial drafts of this PEP kept <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>’s restriction to single name targets
when augmented assignments were used as expressions, allowing attribute and
subscript targets solely for the statement form.</p>
<p>However, enforcing that required varying the permitted targets based on whether
or not the augmented assignment was a top level expression or not, as well as
explaining why <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">+=</span> <span class="pre">1)</span></code>, and <code class="docutils literal notranslate"><span class="pre">self.n</span> <span class="pre">+=</span> <span class="pre">1</span></code> were all legal,
but <code class="docutils literal notranslate"><span class="pre">(self.n</span> <span class="pre">+=</span> <span class="pre">1)</span></code> was prohibited, so the proposal was simplified to allow
all existing augmented assignment targets for the expression form as well.</p>
<p>Since this PEP defines <code class="docutils literal notranslate"><span class="pre">TARGET</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> as a variant on augmented assignment,
that also gained support for assignment and subscript targets.</p>
</section>
<section id="augmented-assignment-or-name-binding-only">
<h3><a class="toc-backref" href="#augmented-assignment-or-name-binding-only" role="doc-backlink">Augmented assignment or name binding only?</a></h3>
<p><a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> makes a reasonable case that the potential use cases for inline
augmented assignment are notably weaker than those for inline assignment in
general, so it’s acceptable to require that they be spelled as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>,
bypassing any in-place augmented assignment methods.</p>
<p>While this is at least arguably true for the builtin types (where potential
counterexamples would probably need to focus on set manipulation use cases
that the PEP author doesn’t personally have), it would also rule out more
memory intensive use cases like manipulation of NumPy arrays, where the data
copying involved in out-of-place operations can make them impractical as
alternatives to their in-place counterparts.</p>
<p>That said, this PEP mainly exists because the PEP author found the inline
assignment proposal much easier to grasp as “It’s like <code class="docutils literal notranslate"><span class="pre">+=</span></code>, only skipping
the addition step”, and also liked the way that that framing provides an
actual semantic difference between <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> and <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> at
function scope.</p>
<p>That difference in target scoping behaviour means that the <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code>
syntax would be expected to have two primary use cases:</p>
<ul class="simple">
<li>as a way of allowing assignments to be embedded as an expression in an <code class="docutils literal notranslate"><span class="pre">if</span></code>
or <code class="docutils literal notranslate"><span class="pre">while</span></code> statement, or as part of a scoped expression</li>
<li>as a way of requesting a compile time check that the target name be previously
declared or bound in the current function scope</li>
</ul>
<p>At module or class scope, <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> and <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> would be
semantically equivalent due to the compiler’s lack of visibility into the set
of names that will be resolvable at runtime, but code linters and static
type checkers would be encouraged to enforce the same “declaration or assignment
required before use” behaviour for <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> as the compiler would
enforce at function scope.</p>
</section>
<section id="postponing-a-decision-on-expression-level-target-declarations">
<h3><a class="toc-backref" href="#postponing-a-decision-on-expression-level-target-declarations" role="doc-backlink">Postponing a decision on expression level target declarations</a></h3>
<p>At least for Python 3.8, usage of inline assignments (whether augmented or not)
at function scope would always require a preceding name binding or scope
declaration to avoid getting <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>, even when used outside a
scoped expression.</p>
<p>The intent behind this requirement is to clearly separate the following two
language design questions:</p>
<ol class="arabic simple">
<li>Can an expression rebind a name in the current scope?</li>
<li>Can an expression declare a new name in the current scope?</li>
</ol>
<p>For module global scopes, the answer to both of those questions is unequivocally
“Yes”, because it’s a language level guarantee that mutating the <code class="docutils literal notranslate"><span class="pre">globals()</span></code>
dict will immediately impact the runtime module scope, and <code class="docutils literal notranslate"><span class="pre">global</span> <span class="pre">NAME</span></code>
declarations inside a function can have the same effect (as can importing the
currently executing module and modifying its attributes).</p>
<p>For class scopes, the answer to both questions is also “Yes” in practice,
although less unequivocally so, since the semantics of <code class="docutils literal notranslate"><span class="pre">locals()</span></code> are
currently formally unspecified. However, if the current behaviour of <code class="docutils literal notranslate"><span class="pre">locals()</span></code>
at class scope is taken as normative (as <a class="pep reference internal" href="../pep-0558/" title="PEP 558 – Defined semantics for locals()">PEP 558</a> proposes), then this is
essentially the same scenario as manipulating the module globals, just using
<code class="docutils literal notranslate"><span class="pre">locals()</span></code> instead.</p>
<p>For function scopes, however, the current answers to these two questions are
respectively “Yes” and “No”. Expression level rebinding of function locals is
already possible thanks to lexically nested scopes and explicit <code class="docutils literal notranslate"><span class="pre">nonlocal</span> <span class="pre">NAME</span></code>
expressions. While this PEP will likely make expression level rebinding more
common than it is today, it isn’t a fundamentally new concept for the language.</p>
<p>By contrast, declaring a <em>new</em> function local variable is currently a statement
level action, involving one of:</p>
<ul class="simple">
<li>an assignment statement (<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code>, <code class="docutils literal notranslate"><span class="pre">OTHER_TARGET</span> <span class="pre">=</span> <span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code>, etc)</li>
<li>a variable declaration (<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:</span> <span class="pre">EXPR</span></code>)</li>
<li>a nested function definition</li>
<li>a nested class definition</li>
<li>a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop</li>
<li>a <code class="docutils literal notranslate"><span class="pre">with</span></code> statement</li>
<li>an <code class="docutils literal notranslate"><span class="pre">except</span></code> clause (with limited scope of access)</li>
</ul>
<p>The historical trend for the language has actually been to <em>remove</em> support for
expression level declarations of function local names, first with the
introduction of “fast locals” semantics (which made the introduction of names
via <code class="docutils literal notranslate"><span class="pre">locals()</span></code> unsupported for function scopes), and again with the hiding
of comprehension iteration variables in Python 3.0.</p>
<p>Now, it may be that in Python 3.9, we decide to revisit this question based on
our experience with expression level name binding in Python 3.8, and decide that
we really do want expression level function local variable declarations as well,
and that we want <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> to be the way we spell that (rather than,
for example, spelling inline declarations more explicitly as
<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span> <span class="pre">given</span> <span class="pre">NAME</span></code>, which would permit them to carry type annotations,
and also permit them to declare new local variables in scoped expressions,
rather than having to pollute the namespace in their containing scope).</p>
<p>But the proposal in this PEP is that we explicitly give ourselves a full
release to decide how much we want that feature, and exactly where we find
its absence irritating. Python has survived happily without expression level
name bindings <em>or</em> declarations for decades, so we can afford to give ourselves
a couple of years to decide if we really want <em>both</em> of those, or if expression
level bindings are sufficient.</p>
</section>
<section id="ignoring-scoped-expressions-when-determining-augmented-assignment-targets">
<h3><a class="toc-backref" href="#ignoring-scoped-expressions-when-determining-augmented-assignment-targets" role="doc-backlink">Ignoring scoped expressions when determining augmented assignment targets</a></h3>
<p>When discussing possible binding semantics for <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>’s assignment expressions,
Tim Peters made a plausible case <a class="footnote-reference brackets" href="#id5" id="id1">[1]</a>, <a class="footnote-reference brackets" href="#id6" id="id2">[2]</a>, <a class="footnote-reference brackets" href="#id7" id="id3">[3]</a> for assignment expressions targeting
the containing block scope, essentially ignoring any intervening scoped
expressions.</p>
<p>This approach allows use cases like cumulative sums, or extracting the final
value from a generator expression to be written in a relatively straightforward
way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">partial_sums</span> <span class="o">=</span> <span class="p">[</span><span class="n">total</span> <span class="o">:=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span> <span class="o">:=</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">small_primes</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">//=</span> <span class="n">factor</span>
</pre></div>
</div>
<p>Guido also expressed his approval for this general approach <a class="footnote-reference brackets" href="#id8" id="id4">[4]</a>.</p>
<p>The proposal in this PEP differs from Tim’s original proposal in three main
areas:</p>
<ul class="simple">
<li>it applies the proposal to all augmented assignment operators, not just a
single new name binding operator</li>
<li>as far as is practical, it extends the augmented assignment requirement that
the name already be defined to the new name binding operator (raising
<code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code> rather than implicitly declaring new local variables at
function scope)</li>
<li>it includes lambda expressions in the set of scopes that get ignored for
target name binding purposes, making this transparency to assignments common
to all of the scoped expressions rather than being specific to comprehensions
and generator expressions</li>
</ul>
<p>With scoped expressions being ignored when calculating binding targets, it’s
once again difficult to detect the scoping difference between the outermost
iterable expressions in generator expressions and comprehensions (you have to
mess about with either class scopes or attempting to rebind iteration Variables
to detect it), so there’s also no need to tinker with that.</p>
</section>
<section id="treating-inline-assignment-as-an-augmented-assignment-variant">
<h3><a class="toc-backref" href="#treating-inline-assignment-as-an-augmented-assignment-variant" role="doc-backlink">Treating inline assignment as an augmented assignment variant</a></h3>
<p>One of the challenges with <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> is the fact that <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> and
<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> are entirely semantically equivalent at every scope. This
makes the two forms hard to teach, since there’s no inherent nudge towards
choosing one over the other at the statement level, so you end up having to
resort to “<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> is preferred because it’s been around longer”
(and <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> proposes to enforce that historical idiosyncrasy at the compiler
level).</p>
<p>That semantic equivalence is difficult to avoid at module and class scope while
still having <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR:</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR:</span></code> work sensibly, but
at function scope the compiler’s comprehensive view of all local names makes
it possible to require that the name be assigned or declared before use,
providing a reasonable incentive to continue to default to using the
<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> form when possible, while also enabling the use of the
<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> as a kind of simple compile time assertion (i.e. explicitly
indicating that the targeted name has already been bound or declared and hence
should already be known to the compiler).</p>
<p>If Guido were to declare that support for inline declarations was a hard
design requirement, then this PEP would be updated to propose that
<code class="docutils literal notranslate"><span class="pre">EXPR</span> <span class="pre">given</span> <span class="pre">NAME</span></code> also be introduced as a way to support inline name declarations
after arbitrary expressions (this would allow the inline name declarations to be
deferred until the end of a complex expression rather than needing to be
embedded in the middle of it, and <a class="pep reference internal" href="../pep-0008/" title="PEP 8 – Style Guide for Python Code">PEP 8</a> would gain a recommendation encouraging
that style).</p>
</section>
<section id="disallowing-augmented-assignments-in-class-level-scoped-expressions">
<h3><a class="toc-backref" href="#disallowing-augmented-assignments-in-class-level-scoped-expressions" role="doc-backlink">Disallowing augmented assignments in class level scoped expressions</a></h3>
<p>While modern classes do define an implicit closure that’s visible to method
implementations (in order to make <code class="docutils literal notranslate"><span class="pre">__class__</span></code> available for use in zero-arg
<code class="docutils literal notranslate"><span class="pre">super()</span></code> calls), there’s no way for user level code to explicitly add
additional names to that scope.</p>
<p>Meanwhile, attributes defined in a class body are ignored for the purpose of
defining a method’s lexical closure, which means adding them there wouldn’t
work at an implementation level.</p>
<p>Rather than trying to resolve that inherent ambiguity, this PEP simply
prohibits such usage, and requires that any affected logic be written somewhere
other than directly inline in the class body (e.g. in a separate helper
function).</p>
</section>
<section id="comparison-operators-vs-assignment-operators">
<h3><a class="toc-backref" href="#comparison-operators-vs-assignment-operators" role="doc-backlink">Comparison operators vs assignment operators</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">OP=</span></code> construct as an expression currently indicates a comparison
operation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="c1"># Equals</span>
<span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="c1"># Greater-than-or-equal-to</span>
<span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="c1"># Less-than-or-equal-to</span>
</pre></div>
</div>
<p>Both this PEP and <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> propose adding at least one operator that’s somewhat
similar in appearance, but defines an assignment instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">:=</span> <span class="n">y</span> <span class="c1"># Becomes</span>
</pre></div>
</div>
<p>This PEP then goes much further and allows all <em>13</em> augmented assignment symbols
to be uses as binary operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+=</span>  <span class="n">y</span> <span class="c1"># In-place add</span>
<span class="n">x</span> <span class="o">-=</span>  <span class="n">y</span> <span class="c1"># In-place minus</span>
<span class="n">x</span> <span class="o">*=</span>  <span class="n">y</span> <span class="c1"># In-place multiply</span>
<span class="n">x</span> <span class="o">@=</span>  <span class="n">y</span> <span class="c1"># In-place matrix multiply</span>
<span class="n">x</span> <span class="o">/=</span>  <span class="n">y</span> <span class="c1"># In-place division</span>
<span class="n">x</span> <span class="o">//=</span> <span class="n">y</span> <span class="c1"># In-place int division</span>
<span class="n">x</span> <span class="o">%=</span>  <span class="n">y</span> <span class="c1"># In-place mod</span>
<span class="n">x</span> <span class="o">&amp;=</span>  <span class="n">y</span> <span class="c1"># In-place bitwise and</span>
<span class="n">x</span> <span class="o">|=</span>  <span class="n">y</span> <span class="c1"># In-place bitwise or</span>
<span class="n">x</span> <span class="o">^=</span>  <span class="n">y</span> <span class="c1"># In-place bitwise xor</span>
<span class="n">x</span> <span class="o">&lt;&lt;=</span> <span class="n">y</span> <span class="c1"># In-place left shift</span>
<span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">y</span> <span class="c1"># In-place right shift</span>
<span class="n">x</span> <span class="o">**=</span> <span class="n">y</span> <span class="c1"># In-place power</span>
</pre></div>
</div>
<p>Of those additional binary operators, the most questionable would be the
bitshift assignment operators, since they’re each only one doubled character
away from one of the inclusive ordered comparison operators.</p>
</section>
</section>
<section id="examples">
<h2><a class="toc-backref" href="#examples" role="doc-backlink">Examples</a></h2>
<section id="simplifying-retry-loops">
<h3><a class="toc-backref" href="#simplifying-retry-loops" role="doc-backlink">Simplifying retry loops</a></h3>
<p>There are currently a few different options for writing retry loops, including:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Post-decrementing a counter</span>
<span class="n">remaining_attempts</span> <span class="o">=</span> <span class="n">MAX_ATTEMPTS</span>
<span class="k">while</span> <span class="n">remaining_attempts</span><span class="p">:</span>
    <span class="n">remaining_attempts</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">attempt_operation</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">continue</span> <span class="c1"># Failed, so try again</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Succeeded after </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span>
    <span class="k">break</span> <span class="c1"># Success!</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">OperationFailed</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed after </span><span class="si">{</span><span class="n">MAX_ATTEMPTS</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>

<span class="c1"># Loop-and-a-half with a pre-incremented counter</span>
<span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;</span> <span class="n">MAX_ATTEMPTS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">OperationFailed</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed after </span><span class="si">{</span><span class="n">MAX_ATTEMPTS</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">attempt_operation</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">continue</span> <span class="c1"># Failed, so try again</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Succeeded after </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span>
    <span class="k">break</span> <span class="c1"># Success!</span>
</pre></div>
</div>
<p>Each of the available options hides some aspect of the intended loop structure
inside the loop body, whether that’s the state modification, the exit condition,
or both.</p>
<p>The proposal in this PEP allows both the state modification and the exit
condition to be included directly in the loop header:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_ATTEMPTS</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">attempt_operation</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">continue</span> <span class="c1"># Failed, so try again</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Succeeded after </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span>
    <span class="k">break</span> <span class="c1"># Success!</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">OperationFailed</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed after </span><span class="si">{</span><span class="n">MAX_ATTEMPTS</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>
</pre></div>
</div>
</section>
<section id="simplifying-if-elif-chains">
<h3><a class="toc-backref" href="#simplifying-if-elif-chains" role="doc-backlink">Simplifying if-elif chains</a></h3>
<p>if-elif chains that need to rebind the checked condition currently need to
be written using nested if-else statements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">other_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">yet_another_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="o">...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="o">...</span>
</pre></div>
</div>
<p>As with <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, this PEP allows the else/if portions of that chain to be
condensed, making their consistent and mutually exclusive structure more
readily apparent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">other_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">yet_another_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Unlike <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, this PEP requires that the assignment target be explicitly
indicated as local before the first use as a <code class="docutils literal notranslate"><span class="pre">:=</span></code> target, either by
binding it to a value (as shown above), or else by including an appropriate
explicit type declaration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">Match</span>
<span class="k">if</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">other_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">yet_another_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="capturing-intermediate-values-from-comprehensions">
<h3><a class="toc-backref" href="#capturing-intermediate-values-from-comprehensions" role="doc-backlink">Capturing intermediate values from comprehensions</a></h3>
<p>The proposal in this PEP makes it straightforward to capture and reuse
intermediate values in comprehensions and generator expressions by
exporting them to the containing block scope:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">factor</span><span class="p">:</span> <span class="nb">int</span>
<span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span> <span class="o">:=</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">small_primes</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">//=</span> <span class="n">factor</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">partial_sums</span> <span class="o">=</span> <span class="p">[</span><span class="n">total</span> <span class="o">+=</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="allowing-lambda-expressions-to-act-more-like-re-usable-code-thunks">
<h3><a class="toc-backref" href="#allowing-lambda-expressions-to-act-more-like-re-usable-code-thunks" role="doc-backlink">Allowing lambda expressions to act more like re-usable code thunks</a></h3>
<p>This PEP allows the classic closure usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">make_counter</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">counter</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">step</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">counter</span>
</pre></div>
</div>
<p>To be abbreviated as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">make_counter</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">step</span>
</pre></div>
</div>
<p>While the latter form is still a conceptually dense piece of code, it can be
reasonably argued that the lack of boilerplate (where the “def”, “nonlocal”,
and “return” keywords and two additional repetitions of the “x” variable name
have been replaced with the “lambda” keyword) may make it easier to read in
practice.</p>
</section>
</section>
<section id="relationship-with-pep-572">
<h2><a class="toc-backref" href="#relationship-with-pep-572" role="doc-backlink">Relationship with PEP 572</a></h2>
<p>The case for allowing inline assignments at all is made in <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>. This
competing PEP was initially going to propose an alternate surface syntax
(<code class="docutils literal notranslate"><span class="pre">EXPR</span> <span class="pre">given</span> <span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code>), while retaining the expression semantics from
<a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, but that changed when discussing one of the initial motivating use
cases for allowing embedded assignments at all: making it possible to easily
calculate cumulative sums in comprehensions and generator expressions.</p>
<p>As a result of that, and unlike <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, this PEP focuses primarily on use
cases for inline augmented assignment. It also has the effect of converting
cases that currently inevitably raise <code class="docutils literal notranslate"><span class="pre">UnboundLocalError</span></code> at function call
time to report a new compile time <code class="docutils literal notranslate"><span class="pre">TargetNameError</span></code>.</p>
<p>New syntax for a name rebinding expression (<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">TARGET</span></code>) is then added
not only to handle the same use cases as are identified in <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, but also
as a lower level primitive to help illustrate, implement and explain
the new augmented assignment semantics, rather than being the sole change being
proposed.</p>
<p>The author of this PEP believes that this approach makes the value of the new
flexibility in name rebinding clearer, while also mitigating many of the
potential concerns raised with <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a> around explaining when to use
<code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">EXPR</span></code> over <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> (and vice-versa), without resorting to
prohibiting the bare statement form of <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> outright (such
that <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">:=</span> <span class="pre">EXPR</span></code> is a compile error, but <code class="docutils literal notranslate"><span class="pre">(NAME</span> <span class="pre">:=</span> <span class="pre">EXPR)</span></code> is permitted).</p>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>The PEP author wishes to thank Chris Angelico for his work on <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, and his
efforts to create a coherent summary of the great many sprawling discussions
that spawned on both python-ideas and python-dev, as well as Tim Peters for
the in-depth discussion of parent local scoping that prompted the above
scoping proposal for augmented assignments inside scoped expressions.</p>
<p>Eric Snow’s feedback on a pre-release version of this PEP helped make it
significantly more readable.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<dt class="label" id="id5">[<a href="#id1">1</a>]</dt>
<dd>The beginning of Tim’s genexp &amp; comprehension scoping thread
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2018-May/050367.html">https://mail.python.org/pipermail/python-ideas/2018-May/050367.html</a>)</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<dt class="label" id="id6">[<a href="#id2">2</a>]</dt>
<dd>Reintroducing the original cumulative sums use case
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2018-May/050544.html">https://mail.python.org/pipermail/python-ideas/2018-May/050544.html</a>)</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<dt class="label" id="id7">[<a href="#id3">3</a>]</dt>
<dd>Tim’s language reference level explanation of his proposed scoping semantics
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2018-May/050729.html">https://mail.python.org/pipermail/python-ideas/2018-May/050729.html</a>)</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<dt class="label" id="id8">[<a href="#id4">4</a>]</dt>
<dd>Guido’s endorsement of Tim’s proposed genexp &amp; comprehension scoping
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2018-May/050411.html">https://mail.python.org/pipermail/python-ideas/2018-May/050411.html</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0577.rst">https://github.com/python/peps/blob/main/peps/pep-0577.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0577.rst">2025-02-01 08:55:40 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#pep-withdrawal">PEP Withdrawal</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#syntax-and-semantics">Syntax and semantics</a><ul>
<li><a class="reference internal" href="#augmented-assignment-expressions">Augmented assignment expressions</a></li>
<li><a class="reference internal" href="#adding-an-inline-assignment-operator">Adding an inline assignment operator</a></li>
<li><a class="reference internal" href="#assignment-operator-precedence">Assignment operator precedence</a></li>
<li><a class="reference internal" href="#augmented-assignment-to-names-in-block-scopes">Augmented assignment to names in block scopes</a></li>
<li><a class="reference internal" href="#augmented-assignment-to-names-in-scoped-expressions">Augmented assignment to names in scoped expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design discussion</a><ul>
<li><a class="reference internal" href="#allowing-complex-assignment-targets">Allowing complex assignment targets</a></li>
<li><a class="reference internal" href="#augmented-assignment-or-name-binding-only">Augmented assignment or name binding only?</a></li>
<li><a class="reference internal" href="#postponing-a-decision-on-expression-level-target-declarations">Postponing a decision on expression level target declarations</a></li>
<li><a class="reference internal" href="#ignoring-scoped-expressions-when-determining-augmented-assignment-targets">Ignoring scoped expressions when determining augmented assignment targets</a></li>
<li><a class="reference internal" href="#treating-inline-assignment-as-an-augmented-assignment-variant">Treating inline assignment as an augmented assignment variant</a></li>
<li><a class="reference internal" href="#disallowing-augmented-assignments-in-class-level-scoped-expressions">Disallowing augmented assignments in class level scoped expressions</a></li>
<li><a class="reference internal" href="#comparison-operators-vs-assignment-operators">Comparison operators vs assignment operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#simplifying-retry-loops">Simplifying retry loops</a></li>
<li><a class="reference internal" href="#simplifying-if-elif-chains">Simplifying if-elif chains</a></li>
<li><a class="reference internal" href="#capturing-intermediate-values-from-comprehensions">Capturing intermediate values from comprehensions</a></li>
<li><a class="reference internal" href="#allowing-lambda-expressions-to-act-more-like-re-usable-code-thunks">Allowing lambda expressions to act more like re-usable code thunks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relationship-with-pep-572">Relationship with PEP 572</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0577.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>