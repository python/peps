
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 810 – Explicit lazy imports | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0810/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 810 – Explicit lazy imports | peps.python.org'>
    <meta property="og:description" content="This PEP introduces syntax for lazy imports as an explicit language feature:">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0810/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP introduces syntax for lazy imports as an explicit language feature:">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 810</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 810 – Explicit lazy imports</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Pablo Galindo &lt;pablogsal&#32;&#97;t&#32;python.org&gt;,
Germán Méndez Bravo &lt;german.mb&#32;&#97;t&#32;gmail.com&gt;,
Thomas Wouters &lt;thomas&#32;&#97;t&#32;python.org&gt;,
Dino Viehland &lt;dinoviehland&#32;&#97;t&#32;gmail.com&gt;,
Brittany Reynoso &lt;brittanyrey&#32;&#97;t&#32;gmail.com&gt;,
Noah Kim &lt;noahbkim&#32;&#97;t&#32;gmail.com&gt;,
Tim Stumbaugh &lt;me&#32;&#97;t&#32;tjstum.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/104131">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">02-Oct-2025</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.15</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/104131" title="Discourse thread">03-Oct-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#other-design-decisions">Other design decisions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar">Grammar</a><ul>
<li><a class="reference internal" href="#syntax-restrictions">Syntax restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#lazy-objects">Lazy objects</a></li>
<li><a class="reference internal" href="#lazy-import-mechanism">Lazy import mechanism</a></li>
<li><a class="reference internal" href="#reification">Reification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#bytecode-and-adaptive-specialization">Bytecode and adaptive specialization</a></li>
<li><a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a></li>
<li><a class="reference internal" href="#global-lazy-imports-control">Global lazy imports control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#unchanged-semantics">Unchanged semantics</a></li>
<li><a class="reference internal" href="#observable-behavioral-shifts-opt-in-only">Observable behavioral shifts (opt-in only)</a></li>
<li><a class="reference internal" href="#thread-safety-and-reification">Thread-safety and reification</a></li>
<li><a class="reference internal" href="#performance">Performance</a><ul>
<li><a class="reference internal" href="#runtime-performance">Runtime performance</a></li>
<li><a class="reference internal" href="#filter-function-performance">Filter function performance</a></li>
<li><a class="reference internal" href="#startup-time-improvements">Startup time improvements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#typing-and-tools">Typing and tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#how-does-this-differ-from-the-rejected-pep-690">How does this differ from the rejected PEP 690?</a></li>
<li><a class="reference internal" href="#what-changes-at-reification-time-what-stays-the-same">What changes at reification time? What stays the same?</a></li>
<li><a class="reference internal" href="#what-happens-when-lazy-imports-encounter-errors">What happens when lazy imports encounter errors?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects">How do lazy imports affect modules with import-time side effects?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-with-from-import-statements">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></li>
<li><a class="reference internal" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></li>
<li><a class="reference internal" href="#what-about-type-annotations-and-type-checking-imports">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></li>
<li><a class="reference internal" href="#what-s-the-performance-overhead-of-lazy-imports">What’s the performance overhead of lazy imports?</a></li>
<li><a class="reference internal" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module">Can I mix lazy and eager imports of the same module?</a></li>
<li><a class="reference internal" href="#how-do-i-migrate-existing-code-to-use-lazy-imports">How do I migrate existing code to use lazy imports?</a></li>
<li><a class="reference internal" href="#what-about-star-imports-from-module-import">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">How do lazy imports interact with import hooks and custom loaders?</a></li>
<li><a class="reference internal" href="#what-happens-in-multi-threaded-environments">What happens in multi-threaded environments?</a></li>
<li><a class="reference internal" href="#can-i-force-reification-of-a-lazy-import-without-using-it">Can I force reification of a lazy import without using it?</a></li>
<li><a class="reference internal" href="#why-not-use-importlib-util-lazyloader-instead">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></li>
<li><a class="reference internal" href="#will-this-break-tools-like-isort-or-black">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></li>
<li><a class="reference internal" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports">How do I know if a library is compatible with lazy imports?</a></li>
<li><a class="reference internal" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-inside-functions">Can I use lazy imports inside functions?</a></li>
<li><a class="reference internal" href="#what-about-forwards-compatibility-with-older-python-versions">What about forwards compatibility with older Python versions?</a></li>
<li><a class="reference internal" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></li>
<li><a class="reference internal" href="#do-lazy-imports-work-with-circular-imports">Do lazy imports work with circular imports?</a></li>
<li><a class="reference internal" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths">Will lazy imports affect the performance of my hot paths?</a></li>
<li><a class="reference internal" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></li>
<li><a class="reference internal" href="#does-lazy-from-future-import-feature-work">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></li>
<li><a class="reference internal" href="#why-did-you-choose-lazy-as-the-keyword-name">Why did you choose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-ideas">Deferred Ideas</a><ul>
<li><a class="reference internal" href="#alternative-syntax-and-ergonomic-improvements">Alternative syntax and ergonomic improvements</a></li>
<li><a class="reference internal" href="#automatic-lazy-imports-for-if-type-checking-blocks">Automatic lazy imports for <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code> blocks</a></li>
<li><a class="reference internal" href="#module-level-lazy-import-mode">Module-level lazy import mode</a></li>
<li><a class="reference internal" href="#package-metadata-for-lazy-safe-declarations">Package metadata for lazy-safe declarations</a></li>
<li><a class="reference internal" href="#c-api-for-lazy-imports">C API for lazy imports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-implementation-ideas">Alternate Implementation Ideas</a><ul>
<li><a class="reference internal" href="#leveraging-a-subclass-of-dict">Leveraging a subclass of dict</a></li>
<li><a class="reference internal" href="#alternate-keyword-names">Alternate keyword names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#making-the-new-behavior-the-default">Making the new behavior the default</a></li>
<li><a class="reference internal" href="#disallowing-lazy-imports-inside-with-blocks">Disallowing lazy imports inside <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks</a></li>
<li><a class="reference internal" href="#forcing-eager-imports-in-with-blocks-under-the-global-flag">Forcing eager imports in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks under the global flag</a></li>
<li><a class="reference internal" href="#modification-of-the-dict-object">Modification of the dict object</a></li>
<li><a class="reference internal" href="#making-lazy-imports-find-the-module-without-loading-it">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-at-the-end-of-import-statements">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></li>
<li><a class="reference internal" href="#adding-an-explicit-eager-keyword">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></li>
<li><a class="reference internal" href="#allowing-the-filter-to-force-lazy-imports-even-when-globally-disabled">Allowing the filter to force lazy imports even when globally disabled</a></li>
<li><a class="reference internal" href="#using-underscore-prefixed-names-for-advanced-features">Using underscore-prefixed names for advanced features</a></li>
<li><a class="reference internal" href="#using-a-decorator-syntax-for-lazy-imports">Using a decorator syntax for lazy imports</a></li>
<li><a class="reference internal" href="#using-a-context-manager-instead-of-a-new-soft-keyword">Using a context manager instead of a new soft keyword</a></li>
<li><a class="reference internal" href="#returning-a-proxy-dict-from-globals">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></li>
<li><a class="reference internal" href="#automatically-reifying-on-dict-or-globals-access">Automatically reifying on <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> or <code class="docutils literal notranslate"><span class="pre">globals()</span></code> access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces syntax for lazy imports as an explicit language feature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumps</span>
</pre></div>
</div>
<p>Lazy imports defer the loading and execution of a module until the first time
the imported name is used, in contrast to ‘normal’ imports, which eagerly load
and execute a module at the point of the import statement.</p>
<p>By allowing developers to mark individual imports as lazy with explicit
syntax, Python programs can reduce startup time, memory usage, and unnecessary
work. This is particularly beneficial for command-line tools, test suites, and
applications with large dependency graphs.</p>
<p>This proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly
requested.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The dominant convention in Python code is to place all imports at the module
level, typically at the beginning of the file. This avoids repetition, makes
import dependencies clear and minimizes runtime overhead by only evaluating an
import statement once per module.</p>
<p>A major drawback with this approach is that importing the first module for an
execution of Python (the “main” module) often triggers an immediate cascade of
imports, and optimistically loads many dependencies that may never be used.
The effect is especially costly for command-line tools with multiple
subcommands, where even running the command with <code class="docutils literal notranslate"><span class="pre">--help</span></code> can load dozens of
unnecessary modules and take several seconds. This basic example demonstrates
what must be loaded just to get helpful feedback to the user on how to run the
program at all. Inefficiently, the user incurs this overhead again when they
figure out the command they want and invoke the program “for real.”</p>
<p>A somewhat common way to delay imports is to move the imports into functions
(inline imports), but this practice requires more work to implement and
maintain, and can be subverted by a single inadvertent top-level import.
Additionally, it obfuscates the full set of dependencies for a module.
Analysis of the Python standard library shows that approximately 17% of all
imports outside tests (nearly 3500 total imports across 730 files) are already
placed inside functions or methods specifically to defer their execution. This
demonstrates that developers are already manually implementing lazy imports in
performance-sensitive code, but doing so requires scattering imports
throughout the codebase and makes the full dependency graph harder to
understand at a glance.</p>
<p>The standard library provides the <a class="reference external" href="https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyLoader</span></code></a> class to
solve some of these inefficiency problems. It permits imports at the module
level to work <em>mostly</em> like inline imports do. Many scientific Python
libraries have adopted a similar pattern, formalized in
<a class="reference external" href="https://scientific-python.org/specs/spec-0001/">SPEC 1</a>.
There’s also the third-party <a class="extlink-pypi reference external" href="https://pypi.org/project/lazy_loader/">lazy_loader</a> package, yet another
implementation of lazy imports. Imports used solely for static type checking
are another source of potentially unneeded imports, and there are similarly
disparate approaches to minimizing the overhead. The various approaches used
here to defer or remove eager imports do not cover all potential use-cases for
a general lazy import mechanism. There is no clear standard, and there are
several drawbacks including runtime overhead in unexpected places, or worse
runtime introspection.</p>
<p>This proposal introduces syntax for lazy imports with a design that is local,
explicit, controlled, and granular. Each of these qualities is essential to
making the feature predictable and safe to use in practice.</p>
<p>The behavior is <strong>local</strong>: laziness applies only to the specific import marked
with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code>
is an isolated decision each time it is used, not a global shift in semantics.</p>
<p>The semantics are <strong>explicit</strong>. When a name is imported lazily, the binding is
created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the
binding is indistinguishable from one created by a normal import. This clarity
reduces surprises and makes the feature accessible to developers who may not
be deeply familiar with Python’s import machinery.</p>
<p>Lazy imports are <strong>controlled</strong>, in the sense that lazy loading is only
triggered by the importing code itself. In the general case, a library will
only experience lazy imports if its own authors choose to mark them as such.
This avoids shifting responsibility onto downstream users and prevents
accidental surprises in library behavior. Since library authors typically
manage their own import subgraphs, they retain predictable control over when
and how laziness is applied.</p>
<p>The mechanism is also <strong>granular</strong>. It is introduced through explicit syntax
on individual imports, rather than a global flag or implicit setting. This
allows developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. As this feature is introduced to
the community, we want to make the experience of onboarding optional,
progressive, and adaptable to the needs of each project.</p>
<p>Lazy imports provide several concrete advantages:</p>
<ul class="simple">
<li>Command-line tools are often invoked directly by a user, so latency – in
particular startup latency – is quite noticeable. These programs are also
typically short-lived processes (contrasted with, e.g., a web server). With
lazy imports, only the code paths actually reached will import a module.
This can reduce startup time by 50-70% in practice, providing a significant
improvement to a common user experience and improving Python’s
competitiveness in domains where fast startup matters most.</li>
<li>Type annotations frequently require imports that are never used at runtime.
The common workaround is to wrap them in <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING:</span></code> blocks
<a class="footnote-reference brackets" href="#f1" id="id1">[1]</a>. With lazy imports, annotation-only imports impose no runtime
penalty, eliminating the need for such guards and making annotated codebases
cleaner.</li>
<li>Large applications often import thousands of modules, and each module
creates function and type objects, incurring memory costs. In long-lived
processes, this noticeably raises baseline memory usage. Lazy imports defer
these costs until a module is needed, keeping unused subsystems unloaded.
Memory savings of 30-40% have been observed in real workloads.</li>
</ul>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The design of this proposal is centered on clarity, predictability, and ease
of adoption. Each decision was made to ensure that lazy imports provide
tangible benefits without introducing unnecessary complexity into the language
or its runtime.</p>
<p>It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for
a different technical path that still preserves the same core semantics or
there is fundamental disagreement over the specific option, we have included
the brainstorming we have already completed in preparation for this proposal
as reference.</p>
<p>The choice to introduce a new <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword reflects the need for explicit
syntax. Lazy imports have different semantics from normal imports: errors and
side effects occur at first use rather than at the import statement. This
semantic difference makes it critical that laziness is visible at the import
site itself, not hidden in global configuration or distant module-level
declarations. The <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword provides local reasoning about import
behavior, avoiding the need to search elsewhere in the code to understand
whether an import is deferred. The rest of the import semantics remain
unchanged: the same import machinery, module finding, and loading mechanisms
are used.</p>
<p>Another important decision is to represent lazy imports with proxy objects in
the module’s namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
dictionary is a fundamental data structure in Python – literally every object
is built on top of dicts – and adding hooks to dictionaries would prevent
critical optimizations and complicate the entire runtime. The proxy approach
is simpler: it behaves like a placeholder until first use, at which point it
resolves the import and rebinds the name. From then on, the binding is
indistinguishable from a normal import. This makes the mechanism easy to
explain and keeps the rest of the interpreter unchanged.</p>
<p>Compatibility for library authors was also a key concern. Many maintainers
need a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> global as a transitional mechanism. A module can
declare which imports should be treated as lazy (by listing the module names
as strings), and on Python 3.15 or later those imports will become lazy
automatically, as if they were imported with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword. On earlier
versions the declaration is ignored, leaving imports eager. This gives authors
a practical bridge until they can rely on the keyword as the canonical syntax.</p>
<p>Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. Notably, the adoption can
also be done from the “outside in”, permitting CLI authors to introduce lazy
imports and speed up user-facing tools, without requiring changes to every
library the tool might use.</p>
<section id="other-design-decisions">
<h3><a class="toc-backref" href="#other-design-decisions" role="doc-backlink">Other design decisions</a></h3>
<ul class="simple">
<li>The scope of laziness is deliberately local and non-recursive. A lazy import
only affects the specific statement where it appears; it does not cascade
into other modules or submodules. This choice is crucial for predictability.
When developers read code, they can reason about import behavior line by
line, without worrying about hidden laziness deeper in the dependency graph.
The result is a feature that is powerful but still easy to understand in
context.</li>
<li>In addition, it is useful to provide a mechanism to activate or deactivate
lazy imports for all code running in the interpreter
(referred to in this PEP as the ‘global lazy imports flag’).
While the primary design centers the explicit <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax,
there are scenarios – such as large applications, testing environments,
or frameworks – where enabling laziness consistently across
many modules provides the most benefit. A global switch makes it easy to
experiment with or enforce consistent behavior, while still working in
combination with the filtering API to respect exclusions or tool-specific
configuration. This ensures that global adoption can be practical without
reducing flexibility or control.</li>
</ul>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="grammar">
<h3><a class="toc-backref" href="#grammar" role="doc-backlink">Grammar</a></h3>
<p>A new soft keyword <code class="docutils literal notranslate"><span class="pre">lazy</span></code> is added. A soft keyword is a context-sensitive
keyword that only has special meaning in specific grammatical contexts;
elsewhere it can be used as a regular identifier (e.g., as a variable name).
The <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword only has special meaning when it appears before import
statements:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>import_name:
    | &#39;lazy&#39;? &#39;import&#39; dotted_as_names

import_from:
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)* dotted_name &#39;import&#39; import_from_targets
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)+ &#39;import&#39; import_from_targets
</pre></div>
</div>
<section id="syntax-restrictions">
<h4><a class="toc-backref" href="#syntax-restrictions" role="doc-backlink">Syntax restrictions</a></h4>
<p>The soft keyword is only allowed at the global (module) level, <strong>not</strong> inside
functions, class bodies, <code class="docutils literal notranslate"><span class="pre">try</span></code> blocks, or <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code>. Import
statements that use the soft keyword are <em>potentially lazy</em>. Imports that
can’t be lazy are unaffected by the global lazy imports flag, and instead are
always eager. Additionally, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> statements cannot be
lazy.</p>
<p>Examples of syntax errors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># SyntaxError: lazy import not allowed inside functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># SyntaxError: lazy import not allowed inside classes</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="p">:</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># SyntaxError: lazy import not allowed inside try/except blocks</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># SyntaxError: lazy from ... import * is not allowed</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="c1"># SyntaxError: lazy from __future__ import is not allowed</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
</pre></div>
</div>
</section>
</section>
<section id="semantics">
<h3><a class="toc-backref" href="#semantics" role="doc-backlink">Semantics</a></h3>
<p>When the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword is used, the import becomes <em>potentially lazy</em>
(see <a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a> for advanced override mechanisms). The module is not
loaded immediately at the import statement; instead, a lazy proxy object is
created and bound to the name. The actual module is loaded on first use of
that name.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code>, <strong>each imported name</strong> is bound to a lazy
proxy object. The first access to <strong>any</strong> of these names triggers loading of
the entire module and reifies <strong>only that specific name</strong> to its actual value.
Other names remain as lazy proxies until they are accessed. The interpreter’s
adaptive specialization will optimize away the lazy checks after a few accesses.</p>
<p>Example with <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False - module not loaded yet</span>

<span class="c1"># First use triggers loading</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True - now loaded</span>
</pre></div>
</div>
<p>Example with <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumps</span><span class="p">,</span> <span class="n">loads</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>           <span class="c1"># False - module not loaded yet</span>

<span class="c1"># First use of &#39;dumps&#39; triggers loading json and reifies ONLY &#39;dumps&#39;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>           <span class="c1"># True - module now loaded</span>

<span class="c1"># Accessing &#39;loads&#39; now reifies it (json already loaded, no re-import)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>A module may contain a <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute, which is a
sequence of fully qualified module names (strings) to make <em>potentially lazy</em>
(as if the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword was used). This attribute is checked on each
<code class="docutils literal notranslate"><span class="pre">import</span></code> statement to determine whether the import should be made
<em>potentially lazy</em>. When a module is made lazy this way, from-imports using
that module are also lazy, but not necessarily imports of sub-modules.</p>
<p>The normal (non-lazy) import statement will check the global lazy imports
flag. If it is “all”, all imports are <em>potentially lazy</em> (except for
imports that can’t be lazy, as mentioned above.)</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">__lazy_modules__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True</span>
</pre></div>
</div>
<p>If the global lazy imports flag is set to “none”, no <em>potentially lazy</em>
import is ever imported lazily, and the behavior is equivalent to a regular
import statement: the import is <em>eager</em> (as if the lazy keyword was not used).</p>
<p>Finally, the application may use a custom filter function on all <em>potentially
lazy</em> imports to determine if they should be lazy or not (this is an advanced
feature, see <a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a>). If a filter function is set, it will be
called with the name of the module doing the import, the name of the module
being imported, and (if applicable) the fromlist. An import remains lazy only
if the filter function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>. If no lazy import filter is set, all
<em>potentially lazy</em> imports are lazy.</p>
</section>
<section id="lazy-objects">
<h3><a class="toc-backref" href="#lazy-objects" role="doc-backlink">Lazy objects</a></h3>
<p>Lazy modules, as well as names lazy imported from modules, are represented
by <code class="xref py py-class docutils literal notranslate"><span class="pre">types.LazyImportType</span></code> instances, which are resolved to the real
object (reified) before they can be used. This reification is usually done
automatically (see below), but can also be done by calling the lazy object’s
<code class="docutils literal notranslate"><span class="pre">resolve</span></code> method.</p>
</section>
<section id="lazy-import-mechanism">
<h3><a class="toc-backref" href="#lazy-import-mechanism" role="doc-backlink">Lazy import mechanism</a></h3>
<p>When an import is lazy, <code class="docutils literal notranslate"><span class="pre">__lazy_import__</span></code> is called instead of
<code class="docutils literal notranslate"><span class="pre">__import__</span></code>. <code class="docutils literal notranslate"><span class="pre">__lazy_import__</span></code> has the same function signature as
<code class="docutils literal notranslate"><span class="pre">__import__</span></code>. It adds the module name to <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code>, a set of
fully-qualified module names which have been lazily imported at some point
(primarily for diagnostics and introspection), and returns a
<code class="xref py py-class docutils literal notranslate"><span class="pre">types.LazyImportType</span></code> object for the module.</p>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> (the <code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code> bytecode
implementation) checks if the module it’s fetching from is a lazy module
object, and if so, returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">types.LazyImportType</span></code> for each name
instead.</p>
<p>The end result of this process is that lazy imports (regardless of how they
are enabled) result in lazy objects being assigned to global variables.</p>
<p>Lazy module objects do not appear in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>, they’re just listed in
the <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> set. Under normal operation lazy objects should only
end up stored in global variables, and the common ways to access those
variables (regular variable access, module attributes) will resolve lazy
imports (reify) and replace them when they’re accessed.</p>
<p>It is still possible to expose lazy objects through other means, like
debuggers. This is not considered a problem.</p>
</section>
<section id="reification">
<h3><a class="toc-backref" href="#reification" role="doc-backlink">Reification</a></h3>
<p>When a lazy object is used, it needs to be reified. This means resolving the
import at that point in the program and replacing the lazy object with the
concrete one. Reification imports the module at that point in the program.
Notably, reification still calls <code class="docutils literal notranslate"><span class="pre">__import__</span></code> to resolve the import, which
uses the state of the import system (e.g. <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code>,
<code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> and <code class="docutils literal notranslate"><span class="pre">__import__</span></code>) at <strong>reification</strong> time, <strong>not</strong> the
state when the <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> statement was evaluated.</p>
<p>When the module is reified, it’s removed from <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> (even if
there are still other unreified lazy references to it). When a package is
reified and submodules in the package were also previously lazily imported,
those submodules are <em>not</em> automatically reified but they <em>are</em> added to the
reified package’s globals (unless the package already assigned something
else to the name of the submodule).</p>
<p>If reification fails (e.g., due to an <code class="docutils literal notranslate"><span class="pre">ImportError</span></code>), the lazy object is
<em>not</em> reified or replaced. Subsequent uses of the lazy object will re-try
the reification. Exceptions that happen during reification are raised as
normal, but the exception is enhanced with chaining to show both where the
lazy import was defined and where it was accessed (even though it propagates
from the code that triggered reification). This provides clear debugging
information:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># app.py - has a typo in the import</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumsp</span>  <span class="c1"># Typo: should be &#39;dumps&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;App started successfully&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing data...&quot;</span><span class="p">)</span>

<span class="c1"># Error occurs here on first use</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dumsp</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>The traceback shows both locations:</p>
<div class="highlight-pytb notranslate"><div class="highlight"><pre><span></span><span class="x">App started successfully</span>
<span class="x">Processing data...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;app.py&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumsp</span>
<span class="gr">ImportError</span>: <span class="n">lazy import of &#39;json.dumsp&#39; raised an exception during resolution</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;app.py&quot;</span>, line <span class="m">8</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">result</span> <span class="o">=</span> <span class="n">dumsp</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
<span class="w">             </span><span class="pm">^^^^^</span>
<span class="gr">ImportError</span>: <span class="n">cannot import name &#39;dumsp&#39; from &#39;json&#39;. Did you mean: &#39;dump&#39;?</span>
</pre></div>
</div>
<p>This exception chaining clearly shows:</p>
<ol class="arabic simple">
<li>where the lazy import was defined,</li>
<li>that the module was not eagerly imported, and</li>
<li>where the actual access happened that triggered the error.</li>
</ol>
<p>Reification does <strong>not</strong> automatically occur when a module that was previously
lazily imported is subsequently eagerly imported. Reification does <strong>not</strong>
immediately resolve all lazy objects (e.g. <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span></code> statements) that
referenced the module. It <strong>only</strong> resolves the lazy object being accessed.</p>
<p>Accessing a lazy object (from a global variable or a module attribute) reifies
the object.</p>
<p>However, calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or accessing a module’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> does
<strong>not</strong> trigger reification – they return the module’s dictionary, and
accessing lazy objects through that dictionary still returns lazy proxy
objects that need to be manually reified upon use. A lazy object can be
resolved explicitly by calling the <code class="docutils literal notranslate"><span class="pre">resolve</span></code> method. Calling <code class="docutils literal notranslate"><span class="pre">dir()</span></code> at
the global scope will not reify the globals, nor will calling <code class="docutils literal notranslate"><span class="pre">dir(mod)</span></code>
(through special-casing in <code class="docutils literal notranslate"><span class="pre">mod.__dir__</span></code>.) Other, more indirect ways of
accessing arbitrary globals (e.g. inspecting <code class="docutils literal notranslate"><span class="pre">frame.f_globals</span></code>) also do
<strong>not</strong> reify all the objects.</p>
<p>Example using <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># my_module.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># Calling globals() does NOT trigger reification</span>
<span class="n">g</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False - still lazy</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;LazyImport&#39;&gt;</span>

<span class="c1"># Accessing __dict__ also does NOT trigger reification</span>
<span class="n">d</span> <span class="o">=</span> <span class="vm">__dict__</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;LazyImport&#39;&gt;</span>

<span class="c1"># Explicitly reify using the resolve() method</span>
<span class="n">resolved</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">resolved</span><span class="p">))</span>  <span class="c1"># &lt;class &#39;module&#39;&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True - now loaded</span>
</pre></div>
</div>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementation is available at:
<a class="reference external" href="https://github.com/LazyImportsCabal/cpython/tree/lazy">https://github.com/LazyImportsCabal/cpython/tree/lazy</a></p>
<p>A demo is available (not necessarily synced with the latest PEP) for
evaluation purposes at: <a class="reference external" href="https://lazy-import-demo.pages.dev/">https://lazy-import-demo.pages.dev/</a></p>
<section id="bytecode-and-adaptive-specialization">
<h3><a class="toc-backref" href="#bytecode-and-adaptive-specialization" role="doc-backlink">Bytecode and adaptive specialization</a></h3>
<p>Lazy imports are implemented through modifications to four bytecode
instructions: <code class="docutils literal notranslate"><span class="pre">IMPORT_NAME</span></code>, <code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code>, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>, and
<code class="docutils literal notranslate"><span class="pre">LOAD_NAME</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lazy</span></code> syntax sets a flag in the <code class="docutils literal notranslate"><span class="pre">IMPORT_NAME</span></code> instruction’s oparg
(<code class="docutils literal notranslate"><span class="pre">oparg</span> <span class="pre">&amp;</span> <span class="pre">0x01</span></code>). The interpreter checks this flag and calls
<code class="docutils literal notranslate"><span class="pre">_PyEval_LazyImportName()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">_PyEval_ImportName()</span></code>, creating a
lazy import object rather than executing the import immediately. The
<code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code> instruction checks whether its source is a lazy import
(<code class="docutils literal notranslate"><span class="pre">PyLazyImport_CheckExact()</span></code>) and creates a lazy object for the attribute
rather than accessing it immediately.</p>
<p>When a lazy object is accessed, it must be reified. The <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>
instruction (used in function scopes) and <code class="docutils literal notranslate"><span class="pre">LOAD_NAME</span></code> instruction (used at
module and class level) both check whether the object being loaded is a lazy
import. If so, they call <code class="docutils literal notranslate"><span class="pre">_PyImport_LoadLazyImportTstate()</span></code> to perform the
actual import and store the module in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<p>This check incurs a very small cost on each access. However, Python’s adaptive
interpreter can specialize <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> after observing that a lazy import
has been reified. After several executions, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>, which accesses the module dictionary directly without
checking for lazy imports.</p>
<p>Examples of the bytecode generated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>  <span class="c1"># IMPORT_NAME with flag set</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IMPORT_NAME              1 (json + lazy)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumps</span>  <span class="c1"># IMPORT_NAME + IMPORT_FROM</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IMPORT_NAME              1 (json + lazy)
IMPORT_FROM              1 (dumps)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">json</span>  <span class="c1"># Module-level access</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_NAME                0 (json)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">use_json</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({})</span>  <span class="c1"># Function scope</span>
</pre></div>
</div>
<p>Before any calls:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)
</pre></div>
</div>
<p>After several calls, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> specializes to <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
</section>
<section id="lazy-imports-filter">
<h3><a class="toc-backref" href="#lazy-imports-filter" role="doc-backlink">Lazy imports filter</a></h3>
<p><em>Note: This is an advanced feature. These are intended for specialized/advanced
users who need fine-grained control over lazy import behavior when using the
global flags. Library developers are discouraged from using these functions as
they can affect the runtime execution of applications (similar to
``sys.setrecursionlimit()``, ``sys.setswitchinterval()``, or
``gc.set_threshold()``).</em></p>
<p>This PEP adds the following new functions to the <code class="docutils literal notranslate"><span class="pre">sys</span></code> module to manage the
lazy imports filter:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter(func)</span></code> - Sets the filter function. If
<code class="docutils literal notranslate"><span class="pre">func=None</span></code> then the import filter is removed. The <code class="docutils literal notranslate"><span class="pre">func</span></code> parameter must
have the signature: <code class="docutils literal notranslate"><span class="pre">func(importer:</span> <span class="pre">str,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">fromlist:</span> <span class="pre">tuple[str,</span> <span class="pre">...]</span> <span class="pre">|</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">sys.get_lazy_imports_filter()</span></code> - Returns the currently installed
filter function, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no filter is set.</li>
<li><code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports(mode,</span> <span class="pre">/)</span></code> - Programmatic API for
controlling lazy imports at runtime. The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter can be
<code class="docutils literal notranslate"><span class="pre">&quot;normal&quot;</span></code> (respect <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword only), <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code> (force all imports to be
potentially lazy), or <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code> (force all imports to be eager).</li>
</ul>
<p>The filter function is called for every potentially lazy import, and must
return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the import should be lazy. This allows for fine-grained
control over which imports should be lazy, useful for excluding modules with
known side-effect dependencies or registration patterns. The filter function
is called at the point of execution of the lazy import or lazy from import
statement, not at the point of reification. The filter function may be
called concurrently.</p>
<p>The filter mechanism serves as a foundation that tools, debuggers, linters,
and other ecosystem utilities can leverage to provide better lazy import
experiences. For example, static analysis tools could detect modules with side
effects and automatically configure appropriate filters. <strong>In the future</strong>
(out of scope for this PEP), this foundation may enable better ways to
declaratively specify which modules are safe for lazy importing, such as
package metadata, type stubs with lazy-safety annotations, or configuration
files. The current filter API is designed to be flexible enough to accommodate
such future enhancements without requiring changes to the core language
specification.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">exclude_side_effect_modules</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter function to exclude modules with import-time side effects.</span>

<span class="sd">    Args:</span>
<span class="sd">        importer: Name of the module doing the import</span>
<span class="sd">        name: Name of the module being imported</span>
<span class="sd">        fromlist: Tuple of names being imported (for &#39;from&#39; imports), or None</span>

<span class="sd">    Returns:</span>
<span class="sd">        True to allow lazy import, False to force eager import</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Modules known to have important import-time side effects</span>
    <span class="n">side_effect_modules</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;legacy_plugin_system&#39;</span><span class="p">,</span> <span class="s1">&#39;metrics_collector&#39;</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">side_effect_modules</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Force eager import</span>

    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Allow lazy import</span>

<span class="c1"># Install the filter</span>
<span class="n">sys</span><span class="o">.</span><span class="n">set_lazy_imports_filter</span><span class="p">(</span><span class="n">exclude_side_effect_modules</span><span class="p">)</span>

<span class="c1"># These imports are checked by the filter</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">data_processor</span>        <span class="c1"># Filter returns True -&gt; stays lazy</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">legacy_plugin_system</span>  <span class="c1"># Filter returns False -&gt; imported eagerly</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data_processor&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>       <span class="c1"># False - still lazy</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;legacy_plugin_system&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span> <span class="c1"># True - loaded eagerly</span>

<span class="c1"># First use of data_processor triggers loading</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">data_processor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data_processor&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>       <span class="c1"># True - now loaded</span>
</pre></div>
</div>
</section>
<section id="global-lazy-imports-control">
<h3><a class="toc-backref" href="#global-lazy-imports-control" role="doc-backlink">Global lazy imports control</a></h3>
<p><em>Note: This is an advanced feature. This is intended for application developers
and framework authors who need to control lazy imports across their entire
application. Library developers are discouraged from using the global activation
mechanism as it can affect the runtime execution of applications (similar to
``sys.setrecursionlimit()``, ``sys.setswitchinterval()``, or
``gc.set_threshold()``).</em></p>
<p>The global lazy imports flag can be controlled through:</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">lazy_imports=&lt;mode&gt;</span></code> command-line option</li>
<li>The <code class="docutils literal notranslate"><span class="pre">PYTHON_LAZY_IMPORTS=&lt;mode&gt;</span></code> environment variable</li>
<li>The <code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports(mode)</span></code> function (primarily for testing)</li>
</ul>
<p>Where <code class="docutils literal notranslate"><span class="pre">&lt;mode&gt;</span></code> can be:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;normal&quot;</span></code> (or unset): Only explicitly marked lazy imports are lazy</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>: All module-level imports (except in <code class="docutils literal notranslate"><span class="pre">try</span></code>
blocks and <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code>) become <em>potentially lazy</em></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code>: No imports are lazy, even those explicitly marked with
<code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword</li>
</ul>
<p>When the global flag is set to <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>, all imports at the global level
of all modules are <em>potentially lazy</em> <strong>except</strong> for those inside a <code class="docutils literal notranslate"><span class="pre">try</span></code>
block or any wild card (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></code>) import.</p>
<p>If the global lazy imports flag is set to <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code>, no <em>potentially
lazy</em> import is ever imported lazily, the import filter is never called, and
the behavior is equivalent to a regular <code class="docutils literal notranslate"><span class="pre">import</span></code> statement: the import is
<em>eager</em> (as if the lazy keyword was not used).</p>
<p>Python code can run the <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_lazy_imports()</span></code> function to override
the state of the global lazy imports flag inherited from the environment or CLI.
This is especially useful if an application needs to ensure that all imports
are evaluated eagerly, via <code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports(&quot;none&quot;)</span></code>.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>Lazy imports are <strong>opt-in</strong>. Existing programs continue to run unchanged
unless a project explicitly enables laziness (via <code class="docutils literal notranslate"><span class="pre">lazy</span></code> syntax,
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>, or an interpreter-wide switch).</p>
<section id="unchanged-semantics">
<h3><a class="toc-backref" href="#unchanged-semantics" role="doc-backlink">Unchanged semantics</a></h3>
<ul class="simple">
<li>Regular <code class="docutils literal notranslate"><span class="pre">import</span></code> and <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements remain eager
unless explicitly made <em>potentially lazy</em> by the local or global mechanisms
provided.</li>
<li>Dynamic import APIs remain eager and unchanged: <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> and
<code class="docutils literal notranslate"><span class="pre">importlib.import_module()</span></code>.</li>
<li>Import hooks and loaders continue to run under the standard import protocol
when a lazy object is reified.</li>
</ul>
</section>
<section id="observable-behavioral-shifts-opt-in-only">
<h3><a class="toc-backref" href="#observable-behavioral-shifts-opt-in-only" role="doc-backlink">Observable behavioral shifts (opt-in only)</a></h3>
<p>These changes are limited to bindings explicitly made lazy:</p>
<ul>
<li><strong>Error timing.</strong> Exceptions that would have occurred during an eager import
(for example <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> or <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> for a missing member) now
occur at the <em>use</em> of the lazy name.<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># With eager import - error at import statement</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>  <span class="c1"># ImportError raised here</span>

<span class="c1"># With lazy import - error deferred</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Import succeeded&quot;</span><span class="p">)</span>
<span class="n">broken_module</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>  <span class="c1"># ImportError raised here on use</span>
</pre></div>
</div>
</li>
<li><strong>Side-effect timing.</strong> Import-time side effects in lazily imported modules
occur at first use of the binding, not at module import time.</li>
<li><strong>Import order.</strong> Because modules are imported on first use, the order in
which modules are imported may differ from how they appear in code.</li>
<li><strong>Presence in ``sys.modules``.</strong> A lazily imported module does not appear in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> until first use. After reification, it must appear in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>. If some other code eagerly imports the same module before
first use, the lazy binding resolves to that existing (lazy) module object
when it is first used.</li>
<li><strong>Proxy visibility.</strong> Before first use, the bound name refers to a lazy
proxy. Indirect introspection that touches the value may observe a proxy
lazy object representation. After first use (provided the module was
imported successfully), the name is rebound to the real object and becomes
indistinguishable from an eager import.</li>
</ul>
</section>
<section id="thread-safety-and-reification">
<h3><a class="toc-backref" href="#thread-safety-and-reification" role="doc-backlink">Thread-safety and reification</a></h3>
<p>Reification follows the existing import-lock discipline. Exactly one thread
performs the import and <strong>atomically rebinds</strong> the importing module’s global
to the resolved object. Concurrent readers thereafter observe the real
object.</p>
<p>Lazy imports are thread-safe and have no special considerations for
free-threading. A module that would normally be imported in the main thread
may be imported in a different thread if that thread triggers the first access
to the lazy import. This is not a problem: the import lock ensures thread
safety regardless of which thread performs the import.</p>
<p>Subinterpreters are supported. Each subinterpreter maintains its own
<code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> and import state, so lazy imports in one subinterpreter
do not affect others.</p>
</section>
<section id="performance">
<h3><a class="toc-backref" href="#performance" role="doc-backlink">Performance</a></h3>
<p>Lazy imports have <strong>no measurable performance overhead</strong>. The implementation
is designed to be performance-neutral for both code that uses lazy imports and
code that doesn’t.</p>
<section id="runtime-performance">
<h4><a class="toc-backref" href="#runtime-performance" role="doc-backlink">Runtime performance</a></h4>
<p>After reification (provided the import was successful), lazy imports have
<strong>zero overhead</strong>. The adaptive interpreter specializes the bytecode
(typically after 2-3 accesses), eliminating any checks. For example,
<code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> becomes <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>, which directly accesses the
module identically to normal imports.</p>
<p>The <a class="reference external" href="https://github.com/facebookexperimental/free-threading-benchmarking/blob/main/results/bm-20250922-3.15.0a0-27836e5/bm-20250922-vultr-x86_64-DinoV-lazy_imports-3.15.0a0-27836e5-vs-base.svg">pyperformance suite</a> confirms the implementation is performance-neutral.</p>
</section>
<section id="filter-function-performance">
<h4><a class="toc-backref" href="#filter-function-performance" role="doc-backlink">Filter function performance</a></h4>
<p>The filter function (set via <code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter()</span></code>) is called for
every <em>potentially lazy</em> import to determine whether it should actually be
lazy. When no filter is set, this is simply a NULL check (testing whether a
filter function has been registered), which is a highly predictable branch that
adds essentially no overhead. When a filter is installed, it is called for each
potentially lazy import, but this still has <strong>almost no measurable performance
cost</strong>. To measure this, we benchmarked importing all 278 top-level importable
modules from the Python standard library (which transitively loads 392 total
modules including all submodules and dependencies), then forced reification of
every loaded module to ensure everything was fully materialized.</p>
<p>Note that these measurements establish the baseline overhead of the filter
mechanism itself. Of course, any user-defined filter function that performs
additional work beyond a trivial check will add overhead proportional to the
complexity of that work. However, we expect that in practice this overhead
will be dwarfed by the performance benefits gained from avoiding unnecessary
imports. The benchmarks below measure the minimal cost of the filter dispatch
mechanism when the filter function does essentially nothing.</p>
<p>We compared four different configurations:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head">Configuration</th>
<th class="head">Mean ± Std Dev (ms)</th>
<th class="head">Overhead vs Baseline</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><strong>Eager imports</strong> (baseline)</td>
<td>161.2 ± 4.3</td>
<td>0%</td>
</tr>
<tr class="row-odd"><td><strong>Lazy + filter forcing eager</strong></td>
<td>161.7 ± 4.2</td>
<td>+0.3% ± 3.7%</td>
</tr>
<tr class="row-even"><td><strong>Lazy + filter allowing lazy + reification</strong></td>
<td>162.0 ± 4.0</td>
<td>+0.5% ± 3.7%</td>
</tr>
<tr class="row-odd"><td><strong>Lazy + no filter + reification</strong></td>
<td>161.4 ± 4.3</td>
<td>+0.1% ± 3.8%</td>
</tr>
</tbody>
</table>
<p>The four configurations:</p>
<ol class="arabic simple">
<li><strong>Eager imports (baseline)</strong>: Normal Python imports with no lazy machinery.
Standard Python behavior.</li>
<li><strong>Lazy + filter forcing eager</strong>: Filter function returns <code class="docutils literal notranslate"><span class="pre">False</span></code> for all
imports, forcing eager execution, then all imports are reified at script
end. Measures pure filter calling overhead since every import goes through
the filter but executes eagerly.</li>
<li><strong>Lazy + filter allowing lazy + reification</strong>: Filter function returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> for all imports, allowing lazy execution. All imports are reified
at script end. Measures filter overhead when imports are actually lazy.</li>
<li><strong>Lazy + no filter + reification</strong>: No filter installed, imports are lazy
and reified at script end. Baseline for lazy behavior without filter.</li>
</ol>
<p>The benchmarks used <a class="reference external" href="https://github.com/sharkdp/hyperfine">hyperfine</a>,
testing 278 standard library modules. Each ran in a fresh Python process.
All configurations force the import of exactly the same set of modules
(all modules loaded by the eager baseline) to ensure a fair comparison.</p>
<p>The benchmark environment used CPU isolation with 32 logical CPUs (0-15 at
3200 MHz, 16-31 at 2400 MHz), the performance scaling governor, Turbo Boost
disabled, and full ASLR randomization. The overhead error bars are computed
using standard error propagation for the formula <code class="docutils literal notranslate"><span class="pre">(value</span> <span class="pre">-</span> <span class="pre">baseline)</span> <span class="pre">/</span>
<span class="pre">baseline</span></code>, accounting for uncertainties in both the measured value and the
baseline.</p>
</section>
<section id="startup-time-improvements">
<h4><a class="toc-backref" href="#startup-time-improvements" role="doc-backlink">Startup time improvements</a></h4>
<p>The primary performance benefit of lazy imports is reduced startup time by
loading only the modules actually used at runtime, rather than optimistically
loading entire dependency trees at startup.</p>
<p>Real-world deployments at scale have demonstrated that the benefits can be
massive, though of course this depends on the specific codebase and usage
patterns. Organizations with large, interconnected codebases have reported
substantial reductions in server reload times, ML training initialization,
command-line tool startup, and Jupyter notebook loading. Memory usage
improvements have also been observed as unused modules remain unloaded.</p>
<p>For detailed case studies and performance data from production deployments,
see:</p>
<ul class="simple">
<li><a class="reference external" href="https://developers.facebook.com/blog/post/2022/06/15/python-lazy-imports-with-cinder/">Python Lazy Imports With Cinder</a>
(Meta Instagram Server)</li>
<li><a class="reference external" href="https://engineering.fb.com/2024/01/18/developer-tools/lazy-imports-cinder-machine-learning-meta/">Lazy is the new fast: How Lazy Imports and Cinder accelerate machine
learning at Meta</a>
(Meta ML Workloads)</li>
<li><a class="reference external" href="https://www.hudsonrivertrading.com/hrtbeat/inside-hrts-python-fork/">Inside HRT’s Python Fork</a>
(Hudson River Trading)</li>
<li><a class="reference external" href="https://bugreports.qt.io/browse/PYSIDE-2404">Create an On-Demand Initializer for PySide</a>
(Qt for Python/PySide) - Christian Tismer’s implementation of lazy
initialization for PySide6 based on ideas from <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>, showing 10-20%
startup time improvement for PySide applications. This demonstrates the
particular value of lazy imports for frameworks with extensive
initialization at import time.</li>
</ul>
<p>The benefits scale with codebase complexity: the larger and more
interconnected the codebase, the more dramatic the improvements. The
PySide implementation particularly highlights how frameworks with heavy
initialization overhead can benefit significantly from opt-in lazy loading.</p>
</section>
</section>
<section id="typing-and-tools">
<h3><a class="toc-backref" href="#typing-and-tools" role="doc-backlink">Typing and tools</a></h3>
<p>Type checkers and static analyzers may treat <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
<code class="docutils literal notranslate"><span class="pre">lazy</span></code> to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.</p>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>Tools that install packages while performing imports from that the same
environment should ensure all modules are imported eagerly, or reified, before
the installation step, to avoid newly installed distributions from shadowing
them.</p>
<p>Such tools can use <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_lazy_imports()</span></code> with <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code> to
force eager evaluation, or provide a <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter()</span></code> function for
fine-grained control.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>The new <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword will be documented as part of the language standard.</p>
<p>As this feature is opt-in, new Python users should be able to continue using
the language as they are used to. For experienced developers, we expect them
to leverage lazy imports for the variety of benefits listed above (decreased
latency, decreased memory usage, etc) on a case-by-case basis. Developers
interested in the performance of their Python binary will likely leverage
profiling to understand the import time overhead in their codebase and mark
the necessary imports as <code class="docutils literal notranslate"><span class="pre">lazy</span></code>. In addition, developers can mark imports
that will only be used for type annotations as <code class="docutils literal notranslate"><span class="pre">lazy</span></code>.</p>
<p>Additional documentation will be added to the Python documentation, including
guidance, a dedicated how-to guide, and updates to the import system
documentation covering: identifying slow-loading modules with profiling tools
(such as <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">importtime</span></code>), migration strategies for existing codebases, best
practices for avoiding common pitfalls with import-time side effects, and
patterns for using lazy imports effectively with type annotations and circular
imports.</p>
<p>Below is guidance on how to best take advantage of lazy imports and how to
avoid incompatibilities:</p>
<ul>
<li>When adopting lazy imports, users should be aware that eliding an import
until it is used will result in side effects not being executed. In turn,
users should be wary of modules that rely on import time side effects.
Perhaps the most common reliance on import side effects is the registry
pattern, where population of some external registry happens implicitly
during the importing of modules, often via decorators but sometimes
implemented via metaclasses or <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. Instead, registries of
objects should be constructed via explicit discovery processes (e.g. a
well-known function to call).<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Problematic: Plugin registers itself on import</span>
<span class="c1"># my_plugin.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">plugin_registry</span><span class="w"> </span><span class="kn">import</span> <span class="n">register_plugin</span>

<span class="nd">@register_plugin</span><span class="p">(</span><span class="s2">&quot;MyPlugin&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyPlugin</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># In main code:</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">my_plugin</span>
<span class="c1"># Plugin NOT registered yet - module not loaded!</span>

<span class="c1"># Better: Explicit discovery</span>
<span class="c1"># plugin_registry.py</span>
<span class="k">def</span><span class="w"> </span><span class="nf">discover_plugins</span><span class="p">():</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">my_plugin</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyPlugin</span>
    <span class="n">register_plugin</span><span class="p">(</span><span class="n">MyPlugin</span><span class="p">)</span>

<span class="c1"># In main code:</span>
<span class="n">plugin_registry</span><span class="o">.</span><span class="n">discover_plugins</span><span class="p">()</span>  <span class="c1"># Explicit loading</span>
</pre></div>
</div>
</li>
<li>Always import needed submodules explicitly. It is not enough to rely on a
different import to ensure a module has its submodules as attributes.
Plainly, unless there is an explicit <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">bar</span></code> in
<code class="docutils literal notranslate"><span class="pre">foo/__init__.py</span></code>, always use <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo.bar;</span> <span class="pre">foo.bar.Baz</span></code>, not
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span> <span class="pre">foo.bar.Baz</span></code>. The latter only works (unreliably) because the
attribute <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> is added as a side effect of <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> being
imported somewhere else.</li>
<li>Users who are moving imports into functions to improve startup time, should
instead consider keeping them where they are but adding the <code class="docutils literal notranslate"><span class="pre">lazy</span></code>
keyword. This allows them to keep dependencies clear and avoid the overhead
of repeatedly re-resolving the import but will still speed up the program.<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Before: Inline import (repeated overhead)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>  <span class="c1"># Re-resolved on every call</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># After: Lazy import at module level</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Loaded once on first call</span>
</pre></div>
</div>
</li>
<li>Avoid using wild card (star) imports, as those are always eager.</li>
</ul>
</section>
<section id="faq">
<h2><a class="toc-backref" href="#faq" role="doc-backlink">FAQ</a></h2>
<section id="how-does-this-differ-from-the-rejected-pep-690">
<h3><a class="toc-backref" href="#how-does-this-differ-from-the-rejected-pep-690" role="doc-backlink">How does this differ from the rejected PEP 690?</a></h3>
<p>PEP 810 takes an explicit, opt-in approach instead of <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>’s implicit
global approach. The key differences are:</p>
<ul class="simple">
<li><strong>Explicit syntax</strong>: <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">foo</span></code> clearly marks which imports are
lazy.</li>
<li><strong>Local scope</strong>: Laziness only affects the specific import statement, not
cascading to dependencies.</li>
<li><strong>Simpler implementation</strong>: Uses proxy objects instead of modifying core
dictionary behavior.</li>
</ul>
</section>
<section id="what-changes-at-reification-time-what-stays-the-same">
<h3><a class="toc-backref" href="#what-changes-at-reification-time-what-stays-the-same" role="doc-backlink">What changes at reification time? What stays the same?</a></h3>
<p><strong>What changes (the timing):</strong></p>
<ul class="simple">
<li><strong>When</strong> the module is imported - deferred to first use instead of at the
import statement</li>
<li><strong>When</strong> import errors occur - at first use rather than at import time</li>
<li><strong>When</strong> module-level side effects execute - at first use rather than at
import time</li>
</ul>
<p><strong>What stays the same (everything else):</strong></p>
<ul class="simple">
<li>The import machinery used - same <code class="docutils literal notranslate"><span class="pre">__import__</span></code>, same hooks, same loaders</li>
<li>The module object created - identical to an eagerly imported module</li>
<li>Import state consulted - <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code>, etc. at
<strong>reification time</strong> (not at import statement time)</li>
<li>Module attributes and behavior - completely indistinguishable after
reification</li>
<li>Thread safety - same import lock discipline as normal imports</li>
</ul>
<p>In other words: lazy imports only change <strong>when</strong> something happens, not
<strong>what</strong> happens. After reification, a lazy-imported module is
indistinguishable from an eagerly imported one.</p>
</section>
<section id="what-happens-when-lazy-imports-encounter-errors">
<h3><a class="toc-backref" href="#what-happens-when-lazy-imports-encounter-errors" role="doc-backlink">What happens when lazy imports encounter errors?</a></h3>
<p>Import errors (<code class="docutils literal notranslate"><span class="pre">ImportError</span></code>, <code class="docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code>, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.</p>
<p>The implementation provides enhanced error reporting through exception
chaining. When a lazy import fails during reification, the original exception
is preserved and chained, showing both where the import was defined and where
it was first used:</p>
<div class="highlight-pytb notranslate"><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;test.py&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>
<span class="gr">ImportError</span>: <span class="n">lazy import of &#39;broken_module&#39; raised an exception during resolution</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;test.py&quot;</span>, line <span class="m">3</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">broken_module</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="w">    </span><span class="pm">^^^^^^^^^^^^^</span>
  File <span class="nb">&quot;broken_module.py&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
</pre></div>
</div>
<p>Exceptions during reification prevent the replacement of the lazy object,
and subsequent uses of the lazy object will retry the whole reification.</p>
</section>
<section id="how-do-lazy-imports-affect-modules-with-import-time-side-effects">
<h3><a class="toc-backref" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects" role="doc-backlink">How do lazy imports affect modules with import-time side effects?</a></h3>
<p>Side effects are deferred until first use. This is generally desirable for
performance, but may require code changes for modules that rely on import-time
registration patterns. We recommend:</p>
<ul class="simple">
<li>Use explicit initialization functions instead of import-time side effects</li>
<li>Call initialization functions explicitly when needed</li>
<li>Avoid relying on import order for side effects</li>
</ul>
</section>
<section id="can-i-use-lazy-imports-with-from-import-statements">
<h3><a class="toc-backref" href="#can-i-use-lazy-imports-with-from-import-statements" role="doc-backlink">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></h3>
<p>Yes, as long as you don’t use <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></code>. Both <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span>
<span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">bar</span></code> are supported. The <code class="docutils literal notranslate"><span class="pre">bar</span></code> name will be
bound to a lazy object that resolves to <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> on first use.</p>
</section>
<section id="does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">
<h3><a class="toc-backref" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class" role="doc-backlink">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></h3>
<p>It loads the <strong>entire module</strong>, not just the class. This is because
Python’s import system always executes the complete module file – there’s no
mechanism to execute only part of a <code class="docutils literal notranslate"><span class="pre">.py</span></code> file. When you first access
<code class="docutils literal notranslate"><span class="pre">Class</span></code>, Python:</p>
<ol class="arabic simple">
<li>Loads and executes the entire <code class="docutils literal notranslate"><span class="pre">module.py</span></code> file</li>
<li>Extracts the <code class="docutils literal notranslate"><span class="pre">Class</span></code> attribute from the resulting module object</li>
<li>Binds <code class="docutils literal notranslate"><span class="pre">Class</span></code> to the name in your namespace</li>
</ol>
<p>This is identical to eager <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> behavior. The only
difference with lazy imports is that steps 1-3 happen on first use instead of
at the import statement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># heavy_module.py</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading heavy_module&quot;</span><span class="p">)</span>  <span class="c1"># This ALWAYS runs when module loads</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">UnusedClass</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Also gets defined, even though we don&#39;t import it</span>

<span class="c1"># app.py</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">heavy_module</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyClass</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Import statement done&quot;</span><span class="p">)</span>  <span class="c1"># heavy_module not loaded yet</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>                  <span class="c1"># NOW &quot;Loading heavy_module&quot; prints</span>
                                 <span class="c1"># (and UnusedClass gets defined too)</span>
</pre></div>
</div>
<p><strong>Key point</strong>: Lazy imports defer <em>when</em> a module loads, not <em>what</em> gets
loaded. You cannot selectively load only parts of a module – Python’s import
system doesn’t support partial module execution.</p>
</section>
<section id="what-about-type-annotations-and-type-checking-imports">
<h3><a class="toc-backref" href="#what-about-type-annotations-and-type-checking-imports" role="doc-backlink">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></h3>
<p>Lazy imports eliminate the common need for <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> guards. You
can write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Mapping</span>  <span class="c1"># No runtime cost</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Instead of:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="what-s-the-performance-overhead-of-lazy-imports">
<h3><a class="toc-backref" href="#what-s-the-performance-overhead-of-lazy-imports" role="doc-backlink">What’s the performance overhead of lazy imports?</a></h3>
<p>The overhead is minimal:</p>
<ul class="simple">
<li>Zero overhead after first use (provided the import doesn’t fail) thanks to
the adaptive interpreter optimizing the slow path away.</li>
<li>Small one-time cost to create the proxy object.</li>
<li>Reification (first use) has the same cost as a regular import.</li>
<li>No ongoing performance penalty.</li>
</ul>
<p>Benchmarking with the <a class="reference external" href="https://github.com/facebookexperimental/free-threading-benchmarking/blob/main/results/bm-20250922-3.15.0a0-27836e5/bm-20250922-vultr-x86_64-DinoV-lazy_imports-3.15.0a0-27836e5-vs-base.svg">pyperformance suite</a> shows the implementation is
performance neutral when lazy imports are not used.</p>
</section>
<section id="can-i-mix-lazy-and-eager-imports-of-the-same-module">
<h3><a class="toc-backref" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module" role="doc-backlink">Can I mix lazy and eager imports of the same module?</a></h3>
<p>Yes. If module <code class="docutils literal notranslate"><span class="pre">foo</span></code> is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the
same module object.</p>
</section>
<section id="how-do-i-migrate-existing-code-to-use-lazy-imports">
<h3><a class="toc-backref" href="#how-do-i-migrate-existing-code-to-use-lazy-imports" role="doc-backlink">How do I migrate existing code to use lazy imports?</a></h3>
<p>Migration is incremental:</p>
<ol class="arabic simple">
<li>Identify slow-loading modules using profiling tools.</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword to imports that aren’t needed immediately.</li>
<li>Test that side-effect timing changes don’t break functionality.</li>
<li>Use <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> for compatibility with older Python versions.</li>
</ol>
</section>
<section id="what-about-star-imports-from-module-import">
<h3><a class="toc-backref" href="#what-about-star-imports-from-module-import" role="doc-backlink">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></h3>
<p>Wild card (star) imports cannot be lazy - they remain eager. This is
because the set of names being imported cannot be determined without loading
the module. Using the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword with star imports will be a syntax
error. If lazy imports are globally enabled, star imports will still be eager.</p>
</section>
<section id="how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">
<h3><a class="toc-backref" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders" role="doc-backlink">How do lazy imports interact with import hooks and custom loaders?</a></h3>
<p>Import hooks and loaders work normally. When a lazy object is used,
the standard import protocol runs, including any custom hooks or loaders that
were in place at reification time.</p>
</section>
<section id="what-happens-in-multi-threaded-environments">
<h3><a class="toc-backref" href="#what-happens-in-multi-threaded-environments" role="doc-backlink">What happens in multi-threaded environments?</a></h3>
<p>Lazy import reification is thread-safe. Only one thread will perform the
actual import, and the binding is atomically updated. Other threads will see
either the lazy proxy or the final resolved object.</p>
</section>
<section id="can-i-force-reification-of-a-lazy-import-without-using-it">
<h3><a class="toc-backref" href="#can-i-force-reification-of-a-lazy-import-without-using-it" role="doc-backlink">Can I force reification of a lazy import without using it?</a></h3>
<p>Yes, individual lazy objects can be resolved by calling their <code class="docutils literal notranslate"><span class="pre">resolve()</span></code>
method.</p>
</section>
<section id="why-not-use-importlib-util-lazyloader-instead">
<h3><a class="toc-backref" href="#why-not-use-importlib-util-lazyloader-instead" role="doc-backlink">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> has significant limitations:</p>
<ul class="simple">
<li>Requires verbose setup code for each lazy import.</li>
<li>Doesn’t work well with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> statements.</li>
<li>Less clear and standard than dedicated syntax.</li>
</ul>
</section>
<section id="will-this-break-tools-like-isort-or-black">
<h3><a class="toc-backref" href="#will-this-break-tools-like-isort-or-black" role="doc-backlink">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></h3>
<p>Linters, formatters, and other tools will need updates to recognize
the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword, but the changes should be minimal since the import
structure remains the same. The keyword appears at the beginning,
making it easy to parse.</p>
</section>
<section id="how-do-i-know-if-a-library-is-compatible-with-lazy-imports">
<h3><a class="toc-backref" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports" role="doc-backlink">How do I know if a library is compatible with lazy imports?</a></h3>
<p>Most libraries should work fine with lazy imports. Libraries that might
have issues:</p>
<ul class="simple">
<li>Those with essential import-time side effects (registration,
monkey-patching).</li>
<li>Those that expect specific import ordering.</li>
<li>Those that modify global state during import.</li>
</ul>
<p>When in doubt, test lazy imports with your specific use cases.</p>
</section>
<section id="what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">
<h3><a class="toc-backref" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly" role="doc-backlink">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></h3>
<p><em>Note: This is an advanced feature.</em> You can use the lazy imports filter to
exclude specific modules that are known to have problematic side effects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">my_filter</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">):</span>
    <span class="c1"># Don&#39;t lazily import modules known to have side effects</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;problematic_module&#39;</span><span class="p">,</span> <span class="s1">&#39;another_module&#39;</span><span class="p">}:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Import eagerly</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Allow lazy import</span>

<span class="n">sys</span><span class="o">.</span><span class="n">set_lazy_imports_filter</span><span class="p">(</span><span class="n">my_filter</span><span class="p">)</span>
</pre></div>
</div>
<p>The filter function receives the importer module name, the module being
imported, and the fromlist (if using <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code>). Returning <code class="docutils literal notranslate"><span class="pre">False</span></code>
forces an eager import.</p>
<p>Alternatively, set the global mode to <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code> via <code class="docutils literal notranslate"><span class="pre">-X</span>
<span class="pre">lazy_imports=none</span></code> to turn off all lazy imports for debugging.</p>
</section>
<section id="can-i-use-lazy-imports-inside-functions">
<h3><a class="toc-backref" href="#can-i-use-lazy-imports-inside-functions" role="doc-backlink">Can I use lazy imports inside functions?</a></h3>
<p>No, the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword is only allowed at module level. For
function-level lazy loading, use traditional inline imports or move the import
to module level with <code class="docutils literal notranslate"><span class="pre">lazy</span></code>.</p>
</section>
<section id="what-about-forwards-compatibility-with-older-python-versions">
<h3><a class="toc-backref" href="#what-about-forwards-compatibility-with-older-python-versions" role="doc-backlink">What about forwards compatibility with older Python versions?</a></h3>
<p>Use the <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> global for compatibility:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Works on Python 3.15+ as lazy, eager on older versions</span>
<span class="n">__lazy_modules__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;expensive_module&#39;</span><span class="p">,</span> <span class="s1">&#39;expensive_module_2&#39;</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">expensive_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">expensive_module_2</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyClass</span>
</pre></div>
</div>
<p>The <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute is a list of module name strings. When
an import statement is executed, Python checks if the module name being
imported appears in <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>. If it does, the import is
treated as if it had the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword (becoming <em>potentially lazy</em>). On
Python versions before 3.15 that don’t support lazy imports, the
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute is simply ignored and imports proceed
eagerly as normal.</p>
<p>This provides a migration path until you can rely on the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword. For
maximum predictability, it’s recommended to define <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>
once, before any imports. But as it is checked on each import, it can be
modified between <code class="docutils literal notranslate"><span class="pre">import</span></code> statements.</p>
</section>
<section id="how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">
<h3><a class="toc-backref" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749" role="doc-backlink">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></h3>
<p>Python 3.14 implemented deferred evaluation of annotations,
as specified by <a class="pep reference internal" href="../pep-0649/" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors">PEP 649</a> and <a class="pep reference internal" href="../pep-0749/" title="PEP 749 – Implementing PEP 649">PEP 749</a>.
If an annotation is not stringified, it is an expression that is evaluated
at a later time. It will only be resolved if the annotation is accessed. In
the example below, the <code class="docutils literal notranslate"><span class="pre">fake_typing</span></code> module is only loaded when the user
inspects the <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> dictionary. The <code class="docutils literal notranslate"><span class="pre">fake_typing</span></code> module would
also be loaded if the user uses <code class="docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code> or
<code class="docutils literal notranslate"><span class="pre">getattr</span></code> to access the annotations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">fake_typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyFakeType</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">MyFakeType</span><span class="p">):</span>
  <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">)</span>  <span class="c1"># Triggers loading the fake_typing module</span>
</pre></div>
</div>
</section>
<section id="how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">
<h3><a class="toc-backref" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection" role="doc-backlink">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></h3>
<p>Accessing lazy imports through normal attribute access or <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>
will trigger reification of the accessed attribute. Calling <code class="docutils literal notranslate"><span class="pre">dir()</span></code> on a
module will be special cased in <code class="docutils literal notranslate"><span class="pre">mod.__dir__</span></code> to avoid reification.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># Before any access</span>
<span class="c1"># json not in sys.modules</span>

<span class="c1"># Any of these trigger reification:</span>
<span class="n">dumps_func</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span>
<span class="n">dumps_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s1">&#39;dumps&#39;</span><span class="p">)</span>
<span class="c1"># Now json is in sys.modules</span>
</pre></div>
</div>
</section>
<section id="do-lazy-imports-work-with-circular-imports">
<h3><a class="toc-backref" href="#do-lazy-imports-work-with-circular-imports" role="doc-backlink">Do lazy imports work with circular imports?</a></h3>
<p>Lazy imports don’t automatically solve circular import problems. If two
modules have a circular dependency, making the imports lazy might help <strong>only
if</strong> the circular reference isn’t accessed during module initialization.
However, if either module accesses the other during import time, you’ll still
get an error.</p>
<p><strong>Example that works</strong> (deferred access in functions):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># user_model.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">post_model</span>

<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_posts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># OK - post_model accessed inside function, not during import</span>
        <span class="k">return</span> <span class="n">post_model</span><span class="o">.</span><span class="n">Post</span><span class="o">.</span><span class="n">get_by_user</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># post_model.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">user_model</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Post</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_by_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Posts by </span><span class="si">{</span><span class="n">username</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>This works because neither module accesses the other at module level – the
access happens later when <code class="docutils literal notranslate"><span class="pre">get_posts()</span></code> is called.</p>
<p><strong>Example that fails</strong> (access during import):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># module_a.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">module_b</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">module_b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>  <span class="c1"># Error! Accessing during import</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;A&quot;</span>

<span class="c1"># module_b.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">module_a</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">module_a</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>  <span class="c1"># Circular dependency error here</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;B&quot;</span>
</pre></div>
</div>
<p>This fails because <code class="docutils literal notranslate"><span class="pre">module_a</span></code> tries to access <code class="docutils literal notranslate"><span class="pre">module_b</span></code> at import time,
which then tries to access <code class="docutils literal notranslate"><span class="pre">module_a</span></code> before it’s fully initialized.</p>
<p>The best practice is still to avoid circular imports in your code design.</p>
</section>
<section id="will-lazy-imports-affect-the-performance-of-my-hot-paths">
<h3><a class="toc-backref" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths" role="doc-backlink">Will lazy imports affect the performance of my hot paths?</a></h3>
<p>After first use (provided the import succeed), lazy imports have <strong>zero
overhead</strong> thanks to the adaptive interpreter. The interpreter specializes
the bytecode (e.g., <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> becomes <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>) which
eliminates the lazy check on subsequent accesses. This means once a lazy
import is reified, accessing it is just as fast as a normal import.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">use_json</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>

<span class="c1"># First call triggers reification</span>
<span class="n">use_json</span><span class="p">()</span>

<span class="c1"># After 2-3 calls, bytecode is specialized</span>
<span class="n">use_json</span><span class="p">()</span>
<span class="n">use_json</span><span class="p">()</span>
</pre></div>
</div>
<p>You can observe the specialization using <code class="docutils literal notranslate"><span class="pre">dis.dis(use_json,</span> <span class="pre">adaptive=True)</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>=== Before specialization ===
LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)

=== After 3 calls (specialized) ===
LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
<p>The specialized <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code> and <code class="docutils literal notranslate"><span class="pre">LOAD_ATTR_MODULE</span></code> instructions
are optimized fast paths with no overhead for checking lazy imports.</p>
</section>
<section id="what-about-sys-modules-when-does-a-lazy-import-appear-there">
<h3><a class="toc-backref" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there" role="doc-backlink">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></h3>
<p>A lazily imported module does <strong>not</strong> appear in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> until it’s
reified (first used). Once reified, it appears in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> just like
any eager import.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>  <span class="c1"># First use</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True</span>
</pre></div>
</div>
</section>
<section id="does-lazy-from-future-import-feature-work">
<h3><a class="toc-backref" href="#does-lazy-from-future-import-feature-work" role="doc-backlink">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></h3>
<p>No, future imports can’t be lazy because they’re parser/compiler directives.
It’s technically possible for the runtime behavior to be lazy but there’s no
real value in it.</p>
</section>
<section id="why-did-you-choose-lazy-as-the-keyword-name">
<h3><a class="toc-backref" href="#why-did-you-choose-lazy-as-the-keyword-name" role="doc-backlink">Why did you choose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></h3>
<p>Not “why”… memorize! :)</p>
</section>
</section>
<section id="deferred-ideas">
<h2><a class="toc-backref" href="#deferred-ideas" role="doc-backlink">Deferred Ideas</a></h2>
<p>The following ideas have been considered but are deliberately deferred to focus
on delivering a stable, usable core feature first. These may be considered for
future enhancements once we have real-world experience with lazy imports.</p>
<section id="alternative-syntax-and-ergonomic-improvements">
<h3><a class="toc-backref" href="#alternative-syntax-and-ergonomic-improvements" role="doc-backlink">Alternative syntax and ergonomic improvements</a></h3>
<p>Several alternative syntax forms have been suggested to improve ergonomics:</p>
<ul>
<li><strong>Type-only imports</strong>: A specialized syntax for imports used exclusively in
type annotations (similar to the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword in other contexts) could be
added, such as <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">from</span> <span class="pre">collections.abc</span> <span class="pre">import</span> <span class="pre">Sequence</span></code>. This would make
the intent clearer than using <code class="docutils literal notranslate"><span class="pre">lazy</span></code> for type-only imports and would signal
to readers that the import is never used at runtime. However, since <code class="docutils literal notranslate"><span class="pre">lazy</span></code>
imports already solve the runtime cost problem for type annotations, we prefer
to start with the simpler, more general mechanism and evaluate whether
specialized syntax adds sufficient value after gathering usage data.</li>
<li><strong>Block-based syntax</strong>: Grouping multiple lazy imports in a block, such as:<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">as</span> <span class="n">lazy</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">foo</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">bar</span><span class="w"> </span><span class="kn">import</span> <span class="n">baz</span>
</pre></div>
</div>
<p>This could reduce repetition when marking many imports as lazy. However, it
would require introducing an entirely new statement form (<code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">lazy:</span></code> blocks)
that doesn’t fit into Python’s existing grammar patterns. It’s unclear how
this would interact with other language features or what the precedent would
be for similar block-level modifiers. This approach also makes it less clear
when scanning code whether a particular import is lazy, since you must look at
the surrounding context rather than the import line itself.</p>
</li>
</ul>
<p>While these alternatives could provide different ergonomics in certain contexts,
they share similar drawbacks: they would require introducing new statement
forms or overloading existing syntax in non-obvious ways, and they open the
door to many other potential uses of similar syntax patterns that would
significantly expand the language. We prefer to start with the explicit
<code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax and gather real-world feedback before considering
additional syntax variations. Any future ergonomic improvements should be
evaluated based on actual usage patterns rather than speculative benefits.</p>
</section>
<section id="automatic-lazy-imports-for-if-type-checking-blocks">
<h3><a class="toc-backref" href="#automatic-lazy-imports-for-if-type-checking-blocks" role="doc-backlink">Automatic lazy imports for <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code> blocks</a></h3>
<p>A future enhancement could automatically treat all imports inside
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING:</span></code> blocks as lazy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="kn">import</span> <span class="n">Bar</span>  <span class="c1"># Could be automatically lazy</span>
</pre></div>
</div>
<p>However, this would require significant changes to make this work at compile
time, since <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> is currently just a runtime variable. The
compiler would need special knowledge of this pattern, similar to how
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> statements are handled. Additionally, making
<code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> a built-in would be required for this to work reliably.
Since <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports already solve the runtime cost problem for type-only
imports, we prefer to start with the explicit syntax and evaluate whether
this optimization adds sufficient value.</p>
</section>
<section id="module-level-lazy-import-mode">
<h3><a class="toc-backref" href="#module-level-lazy-import-mode" role="doc-backlink">Module-level lazy import mode</a></h3>
<p>A module-level declaration to make all imports in that module lazy by default:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">lazy_imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">foo</span>  <span class="c1"># Automatically lazy</span>
</pre></div>
</div>
<p>This was discussed but deferred because it raises several questions. Using
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> implies this would become the default behavior in a
future Python version, which is unclear and not currently planned. It also
raises questions about how such a mode would interact with the global flag and
what the transition path would look like. The current explicit syntax and
<code class="docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> provide sufficient control for initial adoption.</p>
</section>
<section id="package-metadata-for-lazy-safe-declarations">
<h3><a class="toc-backref" href="#package-metadata-for-lazy-safe-declarations" role="doc-backlink">Package metadata for lazy-safe declarations</a></h3>
<p>Future enhancements could allow packages to declare in their metadata whether
they are safe for lazy importing (e.g., no import-time side effects). This
could be used by the filter mechanism or by static analysis tools. The current
filter API is designed to accommodate such future additions without requiring
changes to the core language specification.</p>
</section>
<section id="c-api-for-lazy-imports">
<h3><a class="toc-backref" href="#c-api-for-lazy-imports" role="doc-backlink">C API for lazy imports</a></h3>
<p>No dedicated C API is planned for creating or resolving lazy imports. This
feature is designed as a purely Python-facing mechanism, as C extensions
typically need immediate access to modules and cannot benefit from deferred
loading. Existing C API functions like <code class="docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code> remain
unchanged and continue to perform eager imports. If compelling use cases emerge,
this could be revisited in future versions.</p>
</section>
</section>
<section id="alternate-implementation-ideas">
<h2><a class="toc-backref" href="#alternate-implementation-ideas" role="doc-backlink">Alternate Implementation Ideas</a></h2>
<p>Here are some alternative design decisions that were considered during the
development of this PEP. While the current proposal represents what we believe
to be the best balance of simplicity, performance, and maintainability, these
alternatives offer different trade-offs that may be valuable for implementers
to consider or for future refinements.</p>
<section id="leveraging-a-subclass-of-dict">
<h3><a class="toc-backref" href="#leveraging-a-subclass-of-dict" role="doc-backlink">Leveraging a subclass of dict</a></h3>
<p>Instead of updating the internal dict object to directly add the fields needed
to support lazy imports, we could create a subclass of the dict object to be
used specifically for Lazy Import enablement. This would still be a leaky
abstraction though - methods can be called directly such as
<code class="docutils literal notranslate"><span class="pre">dict.__getitem__</span></code> and it would impact the performance of globals lookup in
the interpreter.</p>
</section>
<section id="alternate-keyword-names">
<h3><a class="toc-backref" href="#alternate-keyword-names" role="doc-backlink">Alternate keyword names</a></h3>
<p>For this PEP, we decided to propose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> for the explicit keyword as it
felt the most familiar to those already focused on optimizing import overhead.
We also considered a variety of other options to support explicit lazy
imports. The most compelling alternates were <code class="docutils literal notranslate"><span class="pre">defer</span></code> and <code class="docutils literal notranslate"><span class="pre">delay</span></code>.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="making-the-new-behavior-the-default">
<h3><a class="toc-backref" href="#making-the-new-behavior-the-default" role="doc-backlink">Making the new behavior the default</a></h3>
<p>Changing <code class="docutils literal notranslate"><span class="pre">import</span></code> to be lazy by default is outside of the scope of this PEP.
From the discussion on <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a> it is clear that this is a fairly
contentious idea, although perhaps once we have wide-spread use of lazy
imports this can be reconsidered.</p>
</section>
<section id="disallowing-lazy-imports-inside-with-blocks">
<h3><a class="toc-backref" href="#disallowing-lazy-imports-inside-with-blocks" role="doc-backlink">Disallowing lazy imports inside <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks</a></h3>
<p>An earlier version of this PEP proposed disallowing <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> statements
inside <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks, similar to the restriction on <code class="docutils literal notranslate"><span class="pre">try</span></code> blocks. The
concern was that certain context managers (like <code class="docutils literal notranslate"><span class="pre">contextlib.suppress(ImportError)</span></code>)
could suppress import errors in confusing ways when combined with lazy imports.</p>
<p>However, this restriction was rejected because <code class="docutils literal notranslate"><span class="pre">with</span></code> statements have much
broader semantics than <code class="docutils literal notranslate"><span class="pre">try/except</span></code> blocks. While <code class="docutils literal notranslate"><span class="pre">try/except</span></code> is explicitly
about catching exceptions, <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks are commonly used for resource
management, temporary state changes, or scoping – contexts where lazy imports
work perfectly fine. The <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax is explicit enough that
developers who write it inside a <code class="docutils literal notranslate"><span class="pre">with</span></code> block are making an intentional choice,
aligning with Python’s “consenting adults” philosophy. For genuinely problematic
cases like <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">suppress(ImportError):</span> <span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">foo</span></code>, static analysis
tools and linters are better suited to catch these patterns than hard language
restrictions.</p>
</section>
<section id="forcing-eager-imports-in-with-blocks-under-the-global-flag">
<h3><a class="toc-backref" href="#forcing-eager-imports-in-with-blocks-under-the-global-flag" role="doc-backlink">Forcing eager imports in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks under the global flag</a></h3>
<p>Another rejected idea was to make imports inside <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks remain eager
even when the global lazy imports flag is set to <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>. The rationale was
to be conservative: since <code class="docutils literal notranslate"><span class="pre">with</span></code> statements can affect how imports behave
(e.g., by modifying <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> or suppressing exceptions), forcing imports to
remain eager could prevent subtle bugs. However, this would create inconsistent
behavior where <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> is allowed explicitly in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks, but
normal imports remain eager when the global flag is enabled. This inconsistency
between explicit and implicit laziness is confusing and hard to explain.</p>
<p>The simpler, more consistent rule is that the global flag affects imports
everywhere that explicit <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax is allowed. This avoids having
three different sets of rules (explicit syntax, global flag behavior, and filter
mechanism) and instead provides two: explicit syntax rules match what the global
flag affects, and the filter mechanism provides escape hatches for edge cases.
For users who need fine-grained control, the filter mechanism
(<code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter()</span></code>) already provides a way to exclude specific
imports or patterns. Additionally, there’s no inverse operation: if the global
flag forces imports eager in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks but a user wants them lazy, there’s
no way to override it, creating an asymmetry.</p>
<p>In summary: imports in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks behave consistently whether marked
explicitly with <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> or implicitly via the global flag, creating a
simple rule that’s easy to explain and reason about.</p>
</section>
<section id="modification-of-the-dict-object">
<h3><a class="toc-backref" href="#modification-of-the-dict-object" role="doc-backlink">Modification of the dict object</a></h3>
<p>The initial PEP for lazy imports (PEP 690) relied heavily on the modification
of the internal dict object to support lazy imports. We recognize that this
data structure is highly tuned, heavily used across the codebase, and very
performance sensitive. Because of the importance of this data structure and
the desire to keep the implementation of lazy imports encapsulated from users
who may have no interest in the feature, we’ve decided to invest in an
alternate approach.</p>
<p>The dictionary is the foundational data structure in Python. Every object’s
attributes are stored in a dict, and dicts are used throughout the runtime for
namespaces, keyword arguments, and more. Adding any kind of hook or special
behavior to dicts to support lazy imports would:</p>
<ol class="arabic simple">
<li>Prevent critical interpreter optimizations including future JIT
compilation.</li>
<li>Add complexity to a data structure that must remain simple and fast.</li>
<li>Affect every part of Python, not just import behavior.</li>
<li>Violate separation of concerns – the hash table shouldn’t know about the
import system.</li>
</ol>
<p>Past decisions that violated this principle of keeping core abstractions clean
have caused significant pain in the CPython ecosystem, making optimization
difficult and introducing subtle bugs.</p>
</section>
<section id="making-lazy-imports-find-the-module-without-loading-it">
<h3><a class="toc-backref" href="#making-lazy-imports-find-the-module-without-loading-it" role="doc-backlink">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></h3>
<p>The Python <code class="docutils literal notranslate"><span class="pre">import</span></code> machinery separates out finding a module and loading
it, and the lazy import implementation could technically defer only the
loading part. However, this approach was rejected for several critical reasons.</p>
<p>A significant part of the performance win comes from skipping the finding phase.
The issue is particularly acute on NFS-backed filesystems and distributed
storage, where each <code class="docutils literal notranslate"><span class="pre">stat()</span></code> call incurs network latency. In these kinds of
environments, <code class="docutils literal notranslate"><span class="pre">stat()</span></code> calls can take tens to hundreds of milliseconds
depending on network conditions. With dozens of imports each doing multiple
filesystem checks traversing <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, the time spent finding modules
before executing any Python code can become substantial. In some measurements,
spec finding accounts for the majority of total import time. Skipping only the
loading phase would leave most of the performance problem unsolved.</p>
<p>More critically, separating finding from loading creates the worst of both
worlds for error handling. Some exceptions from the import machinery (e.g.,
<code class="docutils literal notranslate"><span class="pre">ImportError</span></code> from a missing module, path resolution failures,
<code class="docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code>) would be raised at the <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> statement, while
others (e.g., <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>, <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> from circular imports, attribute
errors from <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span></code>) would be raised later at first use.
This split is both confusing and unpredictable: developers would need to
understand the internal import machinery to know which errors happen when. The
current design is simpler: with full lazy imports, all import-related errors
occur at first use, making the behavior consistent and predictable.</p>
<p>Additionally, there are technical limitations: finding the module does not
guarantee the import will succeed, nor even that it will not raise ImportError.
Finding modules in packages requires that those packages are loaded, so it
would only help with lazy loading one level of a package hierarchy. Since
“finding” attributes in modules <em>requires</em> loading them, this would create a
hard to explain difference between <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">module</span></code> and
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">function</span></code>.</p>
</section>
<section id="placing-the-lazy-keyword-in-the-middle-of-from-imports">
<h3><a class="toc-backref" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports" role="doc-backlink">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></h3>
<p>While we found <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">bar</span></code> to be a really intuitive placement
for the new explicit syntax, we quickly learned that placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code>
keyword here is already syntactically allowed in Python. This is because
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">bar</span></code> is legal syntax (because whitespace does not
matter.)</p>
</section>
<section id="placing-the-lazy-keyword-at-the-end-of-import-statements">
<h3><a class="toc-backref" href="#placing-the-lazy-keyword-at-the-end-of-import-statements" role="doc-backlink">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></h3>
<p>We discussed appending lazy to the end of import statements like such <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">foo</span> <span class="pre">lazy</span></code> or <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">bar,</span> <span class="pre">baz</span> <span class="pre">lazy</span></code> but ultimately decided that
this approach provided less clarity. For example, if multiple modules are
imported in a single statement, it is unclear if the lazy binding applies to
all of the imported objects or just a subset of the items.</p>
</section>
<section id="adding-an-explicit-eager-keyword">
<h3><a class="toc-backref" href="#adding-an-explicit-eager-keyword" role="doc-backlink">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></h3>
<p>Since we’re not changing the default behavior, and we don’t want to
encourage use of the global flags, it’s too early to consider adding
superfluous syntax for the common, default case. It would create too much
confusion about what the default is, or when the <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword would be
necessary, or whether it affects lazy imports <em>in</em> the explicitly eagerly
imported module.</p>
</section>
<section id="allowing-the-filter-to-force-lazy-imports-even-when-globally-disabled">
<h3><a class="toc-backref" href="#allowing-the-filter-to-force-lazy-imports-even-when-globally-disabled" role="doc-backlink">Allowing the filter to force lazy imports even when globally disabled</a></h3>
<p>As lazy imports allow some forms of circular imports that would otherwise
fail, as an intentional and desirable thing (especially for typing-related
imports), there was a suggestion to add a way to override the global disable
and force particular imports to be lazy, for instance by calling the lazy
imports filter even if lazy imports are globally disabled.</p>
<p>This approach could introduce a complex hierarchy of the different “override”
systems, making it much harder to analyze and reason about the code.
Additionally, this may require additional complexity to introduce finer-grained
systems to enable or disable particular imports as the use of lazy imports
evolves. The global disable is not expected to see commonplace use, but be more
of a debugging and selective testing tool for those who want to tightly control
their dependency on lazy imports. We think it’s reasonable for package
maintainers, as they update packages to adopt lazy imports, to decide to
<em>not</em> support running with lazy imports globally disabled.</p>
<p>It may be that this means that in time, as more and more packages embrace
both typing and lazy imports, the global disable becomes mostly unused and
unusable. Similar things have happened in the past with other global flags,
and given the low cost of the flag this seems acceptable. It’s also easier
to add more specific re-enabling mechanisms later, when we have a clearer
picture of real-world use and patterns, than it is to remove a hastily added
mechanism that isn’t quite right.</p>
</section>
<section id="using-underscore-prefixed-names-for-advanced-features">
<h3><a class="toc-backref" href="#using-underscore-prefixed-names-for-advanced-features" role="doc-backlink">Using underscore-prefixed names for advanced features</a></h3>
<p>The global activation and filter functions (<code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports</span></code>,
<code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.get_lazy_imports_filter</span></code>) could be
marked as “private” or “advanced” by using underscore prefixes (e.g.,
<code class="docutils literal notranslate"><span class="pre">sys._set_lazy_imports_filter</span></code>). This was rejected because branding as
advanced features through documentation is sufficient. These functions have
legitimate use cases for advanced users, particularly operators of large
deployments. Providing an official mechanism prevents divergence from upstream
CPython. The global mode is intentionally documented as an advanced feature for
operators running huge fleets, not for day-to-day users or libraries. Python
has precedent for advanced features that remain public APIs without underscore
prefixes - for example, <code class="docutils literal notranslate"><span class="pre">gc.disable()</span></code>, <code class="docutils literal notranslate"><span class="pre">gc.get_objects()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">gc.set_threshold()</span></code> are advanced features that can cause issues if misused,
yet they are not underscore-prefixed.</p>
</section>
<section id="using-a-decorator-syntax-for-lazy-imports">
<h3><a class="toc-backref" href="#using-a-decorator-syntax-for-lazy-imports" role="doc-backlink">Using a decorator syntax for lazy imports</a></h3>
<p>A decorator-based syntax could mark imports as lazy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@lazy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nd">@lazy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="kn">import</span> <span class="n">bar</span>
</pre></div>
</div>
<p>This approach was rejected because it introduces too many open questions and
complications. Decorators in Python are designed to wrap and transform callable
objects (functions, classes, methods), not statements. Allowing decorators on
import statements would open the door to many other potential statement
decorators (<code class="docutils literal notranslate"><span class="pre">&#64;cached</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;traced</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;deprecated</span></code>, etc.), significantly
expanding the language’s syntax in ways we don’t want to explore. Furthermore,
this raises the question of where such decorators would come from: they would
need to be either imported or built-in, creating a bootstrapping problem for
import-related decorators. This is far more speculative and generic than the
focused <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax.</p>
</section>
<section id="using-a-context-manager-instead-of-a-new-soft-keyword">
<h3><a class="toc-backref" href="#using-a-context-manager-instead-of-a-new-soft-keyword" role="doc-backlink">Using a context manager instead of a new soft keyword</a></h3>
<p>A backward compatible syntax, for example in the form of a context manager,
has been proposed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">lazy_imports</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
</pre></div>
</div>
<p>This would replace the need for <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>, and allow
libraries to use one of the existing lazy imports implementations in older
Python versions. However, adding magic <code class="docutils literal notranslate"><span class="pre">with</span></code> statements with that kind of
effect would be a significant change to Python and <code class="docutils literal notranslate"><span class="pre">with</span></code> statements in
general, and it would not be easy to combine with the implementation for
lazy imports in this proposal. Adding standard library support for existing
lazy importers <em>without</em> changes to the implementation amounts to the status
quo, and does not solve the performance and usability issues with those
existing solutions.</p>
</section>
<section id="returning-a-proxy-dict-from-globals">
<h3><a class="toc-backref" href="#returning-a-proxy-dict-from-globals" role="doc-backlink">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></h3>
<p>An alternative to reifying on <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or exposing lazy objects would be
to return a proxy dictionary that automatically reifies lazy objects when
they’re accessed through the proxy. This would seemingly give the best of both
worlds: <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns immediately without reification cost, but
accessing items through the result would automatically resolve lazy imports.</p>
<p>However, this approach is fundamentally incompatible with how <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is
used in practice. Many standard library functions and built-ins expect
<code class="docutils literal notranslate"><span class="pre">globals()</span></code> to return a real <code class="docutils literal notranslate"><span class="pre">dict</span></code> object, not a proxy:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">globals())</span></code> requires a real dict.</li>
<li><code class="docutils literal notranslate"><span class="pre">eval(expr,</span> <span class="pre">globals())</span></code> requires a real dict.</li>
<li>Functions that check <code class="docutils literal notranslate"><span class="pre">type(globals())</span> <span class="pre">is</span> <span class="pre">dict</span></code> would break.</li>
<li>Dictionary methods like <code class="docutils literal notranslate"><span class="pre">.update()</span></code> would need special handling.</li>
<li>Performance would suffer from the indirection on every access.</li>
</ul>
<p>The proxy would need to be so transparent that it would be indistinguishable
from a real dict in almost all cases, which is extremely difficult to achieve
correctly. Any deviation from true dict behavior would be a source of subtle
bugs.</p>
</section>
<section id="automatically-reifying-on-dict-or-globals-access">
<h3><a class="toc-backref" href="#automatically-reifying-on-dict-or-globals-access" role="doc-backlink">Automatically reifying on <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> or <code class="docutils literal notranslate"><span class="pre">globals()</span></code> access</a></h3>
<p>Three options were considered for how <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> should
behave with lazy imports:</p>
<ol class="arabic simple">
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> traverses and resolves all lazy
objects before returning.</li>
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> returns the dictionary with lazy
objects present (chosen).</li>
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns the dictionary with lazy objects, but
<code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> reifies everything.</li>
</ol>
<p>We chose option 2: both <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> return the raw
namespace dictionary without triggering reification. This provides a clean,
predictable model where low-level introspection APIs don’t trigger side
effects.</p>
<p>Having <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> behave identically creates symmetry and
a simple mental model: both expose the raw namespace view. Low-level
introspection APIs should not automatically trigger imports, which would be
surprising and potentially expensive. Real-world experience implementing lazy
imports in the standard library (such as the traceback module) showed that
automatic reification on <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> access was cumbersome and forced
introspection code to load modules it was only examining.</p>
<p>Option 1 (always reifying) was rejected because it would make <code class="docutils literal notranslate"><span class="pre">globals()</span></code>
and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> access surprisingly expensive and prevent introspecting the
lazy state of a module. Option 3 was initially considered to “protect” external
code from seeing lazy objects, but real-world usage showed this created more
problems than it solved, particularly for stdlib code that needs to introspect
modules without triggering side effects.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>We would like to thank Paul Ganssle, Yury Selivanov, Łukasz Langa, Lysandros
Nikolaou, Pradyun Gedam, Mark Shannon, Hana Joo and the Python Google team,
the Python team(s) &#64; Meta, the Python &#64; HRT team, the Bloomberg Python team,
the Scientific Python community, everyone who participated in the initial
discussion of <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>, and many others who provided valuable feedback and
insights that helped shape this PEP.</p>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<dt class="label" id="f1">[<a href="#id1">1</a>]</dt>
<dd>Furthermore, there’s also external tooling, in the form of
<a class="reference external" href="https://pypi.org/project/flake8-type-checking/">flake8-type-checking</a>,
because it is common for developers to mislocate imports and accidentally
introduce a runtime dependency on an import only imported in such a block.
Ironically, the static type checker is of no help in these circumstances.</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0810.rst">https://github.com/python/peps/blob/main/peps/pep-0810.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0810.rst">2025-10-22 14:36:10 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#other-design-decisions">Other design decisions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar">Grammar</a><ul>
<li><a class="reference internal" href="#syntax-restrictions">Syntax restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#lazy-objects">Lazy objects</a></li>
<li><a class="reference internal" href="#lazy-import-mechanism">Lazy import mechanism</a></li>
<li><a class="reference internal" href="#reification">Reification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#bytecode-and-adaptive-specialization">Bytecode and adaptive specialization</a></li>
<li><a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a></li>
<li><a class="reference internal" href="#global-lazy-imports-control">Global lazy imports control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#unchanged-semantics">Unchanged semantics</a></li>
<li><a class="reference internal" href="#observable-behavioral-shifts-opt-in-only">Observable behavioral shifts (opt-in only)</a></li>
<li><a class="reference internal" href="#thread-safety-and-reification">Thread-safety and reification</a></li>
<li><a class="reference internal" href="#performance">Performance</a><ul>
<li><a class="reference internal" href="#runtime-performance">Runtime performance</a></li>
<li><a class="reference internal" href="#filter-function-performance">Filter function performance</a></li>
<li><a class="reference internal" href="#startup-time-improvements">Startup time improvements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#typing-and-tools">Typing and tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#how-does-this-differ-from-the-rejected-pep-690">How does this differ from the rejected PEP 690?</a></li>
<li><a class="reference internal" href="#what-changes-at-reification-time-what-stays-the-same">What changes at reification time? What stays the same?</a></li>
<li><a class="reference internal" href="#what-happens-when-lazy-imports-encounter-errors">What happens when lazy imports encounter errors?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects">How do lazy imports affect modules with import-time side effects?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-with-from-import-statements">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></li>
<li><a class="reference internal" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></li>
<li><a class="reference internal" href="#what-about-type-annotations-and-type-checking-imports">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></li>
<li><a class="reference internal" href="#what-s-the-performance-overhead-of-lazy-imports">What’s the performance overhead of lazy imports?</a></li>
<li><a class="reference internal" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module">Can I mix lazy and eager imports of the same module?</a></li>
<li><a class="reference internal" href="#how-do-i-migrate-existing-code-to-use-lazy-imports">How do I migrate existing code to use lazy imports?</a></li>
<li><a class="reference internal" href="#what-about-star-imports-from-module-import">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">How do lazy imports interact with import hooks and custom loaders?</a></li>
<li><a class="reference internal" href="#what-happens-in-multi-threaded-environments">What happens in multi-threaded environments?</a></li>
<li><a class="reference internal" href="#can-i-force-reification-of-a-lazy-import-without-using-it">Can I force reification of a lazy import without using it?</a></li>
<li><a class="reference internal" href="#why-not-use-importlib-util-lazyloader-instead">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></li>
<li><a class="reference internal" href="#will-this-break-tools-like-isort-or-black">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></li>
<li><a class="reference internal" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports">How do I know if a library is compatible with lazy imports?</a></li>
<li><a class="reference internal" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-inside-functions">Can I use lazy imports inside functions?</a></li>
<li><a class="reference internal" href="#what-about-forwards-compatibility-with-older-python-versions">What about forwards compatibility with older Python versions?</a></li>
<li><a class="reference internal" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></li>
<li><a class="reference internal" href="#do-lazy-imports-work-with-circular-imports">Do lazy imports work with circular imports?</a></li>
<li><a class="reference internal" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths">Will lazy imports affect the performance of my hot paths?</a></li>
<li><a class="reference internal" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></li>
<li><a class="reference internal" href="#does-lazy-from-future-import-feature-work">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></li>
<li><a class="reference internal" href="#why-did-you-choose-lazy-as-the-keyword-name">Why did you choose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-ideas">Deferred Ideas</a><ul>
<li><a class="reference internal" href="#alternative-syntax-and-ergonomic-improvements">Alternative syntax and ergonomic improvements</a></li>
<li><a class="reference internal" href="#automatic-lazy-imports-for-if-type-checking-blocks">Automatic lazy imports for <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code> blocks</a></li>
<li><a class="reference internal" href="#module-level-lazy-import-mode">Module-level lazy import mode</a></li>
<li><a class="reference internal" href="#package-metadata-for-lazy-safe-declarations">Package metadata for lazy-safe declarations</a></li>
<li><a class="reference internal" href="#c-api-for-lazy-imports">C API for lazy imports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-implementation-ideas">Alternate Implementation Ideas</a><ul>
<li><a class="reference internal" href="#leveraging-a-subclass-of-dict">Leveraging a subclass of dict</a></li>
<li><a class="reference internal" href="#alternate-keyword-names">Alternate keyword names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#making-the-new-behavior-the-default">Making the new behavior the default</a></li>
<li><a class="reference internal" href="#disallowing-lazy-imports-inside-with-blocks">Disallowing lazy imports inside <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks</a></li>
<li><a class="reference internal" href="#forcing-eager-imports-in-with-blocks-under-the-global-flag">Forcing eager imports in <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks under the global flag</a></li>
<li><a class="reference internal" href="#modification-of-the-dict-object">Modification of the dict object</a></li>
<li><a class="reference internal" href="#making-lazy-imports-find-the-module-without-loading-it">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-at-the-end-of-import-statements">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></li>
<li><a class="reference internal" href="#adding-an-explicit-eager-keyword">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></li>
<li><a class="reference internal" href="#allowing-the-filter-to-force-lazy-imports-even-when-globally-disabled">Allowing the filter to force lazy imports even when globally disabled</a></li>
<li><a class="reference internal" href="#using-underscore-prefixed-names-for-advanced-features">Using underscore-prefixed names for advanced features</a></li>
<li><a class="reference internal" href="#using-a-decorator-syntax-for-lazy-imports">Using a decorator syntax for lazy imports</a></li>
<li><a class="reference internal" href="#using-a-context-manager-instead-of-a-new-soft-keyword">Using a context manager instead of a new soft keyword</a></li>
<li><a class="reference internal" href="#returning-a-proxy-dict-from-globals">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></li>
<li><a class="reference internal" href="#automatically-reifying-on-dict-or-globals-access">Automatically reifying on <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> or <code class="docutils literal notranslate"><span class="pre">globals()</span></code> access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0810.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>