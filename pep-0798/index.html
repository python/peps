
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 798 – Unpacking in Comprehensions | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0798/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 798 – Unpacking in Comprehensions | peps.python.org'>
    <meta property="og:description" content="This PEP proposes extending list, set, and dictionary comprehensions, as well as generator expressions, to allow unpacking notation (* and **) at the start of the expression, providing a concise way of combining an arbitrary number of iterables into one...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0798/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes extending list, set, and dictionary comprehensions, as well as generator expressions, to allow unpacking notation (* and **) at the start of the expression, providing a concise way of combining an arbitrary number of iterables into one...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 798</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 798 – Unpacking in Comprehensions" data-pagefind-weight="10" class="visually-hidden">PEP 798 – Unpacking in Comprehensions</span>
            <section id="pep-content">
<h1 class="page-title">PEP 798 – Unpacking in Comprehensions</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Adam Hartz &lt;hz&#32;&#97;t&#32;mit.edu&gt;, Erik Demaine &lt;edemaine&#32;&#97;t&#32;mit.edu&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Jelle Zijlstra &lt;jelle.zijlstra at gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/99435">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative proposal accepted for implementation">Accepted</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">19-Jul-2025</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/archives/list/python-ideas&#64;python.org/thread/7G732VMDWCRMWM4PKRG6ZMUKH7SUC7SH/" title="Python-Ideas thread">16-Oct-2021</a>, <a class="reference external" href="https://discuss.python.org/t/pre-pep-unpacking-in-comprehensions/96362" title="Discourse thread">22-Jun-2025</a>, <a class="reference external" href="https://discuss.python.org/t/pep-798-unpacking-in-comprehensions/99435" title="Discourse thread">19-Jul-2025</a></dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-798-unpacking-in-comprehensions/99435/60">03-Nov-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#syntax">Syntax</a></li>
<li><a class="reference internal" href="#semantics-list-set-dict-comprehensions">Semantics: List/Set/Dict Comprehensions</a></li>
<li><a class="reference internal" href="#semantics-generator-expressions">Semantics: Generator Expressions</a><ul>
<li><a class="reference internal" href="#interaction-with-assignment-expressions">Interaction with Assignment Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#code-examples">Code Examples</a><ul>
<li><a class="reference internal" href="#replacing-explicit-loops">Replacing Explicit Loops</a></li>
<li><a class="reference internal" href="#replacing-from-iterable-and-friends">Replacing from_iterable and Friends</a></li>
<li><a class="reference internal" href="#replacing-double-loops-in-comprehensions">Replacing Double Loops in Comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternative-proposals">Rejected Alternative Proposals</a><ul>
<li><a class="reference internal" href="#starred-generators-as-function-arguments">Starred Generators as Function Arguments</a></li>
<li><a class="reference internal" href="#further-generalizing-unpacking-operators">Further Generalizing Unpacking Operators</a></li>
<li><a class="reference internal" href="#alternative-generator-expression-semantics">Alternative Generator Expression Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concerns-and-disadvantages">Concerns and Disadvantages</a></li>
<li><a class="reference internal" href="#appendix-other-languages">Appendix: Other Languages</a></li>
<li><a class="reference internal" href="#appendix-semantics-of-generator-delegation">Appendix: Semantics of Generator Delegation</a><ul>
<li><a class="reference internal" href="#basic-behavior">Basic Behavior</a></li>
<li><a class="reference internal" href="#advanced-generator-protocol-differences">Advanced Generator Protocol Differences</a><ul>
<li><a class="reference internal" href="#delegation-with-send">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></li>
<li><a class="reference internal" href="#exception-handling-with-throw">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></li>
<li><a class="reference internal" href="#generator-cleanup-with-close">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes extending list, set, and dictionary comprehensions, as well
as generator expressions, to allow unpacking notation (<code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>) at the
start of the expression, providing a concise way of combining an arbitrary
number of iterables into one list or set or generator, or an arbitrary number
of dictionaries into one dictionary, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>  <span class="c1"># list with the concatenation of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>  <span class="c1"># set with the union of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">**</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span> <span class="c1"># dict with the combination of dicts in &#39;dicts&#39;</span>
<span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">)</span>  <span class="c1"># generator of the concatenation of iterables in &#39;its&#39;</span>
</pre></div>
</div>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Extended unpacking notation (<code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>) from <a class="pep reference internal" href="../pep-0448/" title="PEP 448 – Additional Unpacking Generalizations">PEP 448</a> makes it
easy to combine a few iterables or dictionaries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="o">*</span><span class="n">it2</span><span class="p">,</span> <span class="o">*</span><span class="n">it3</span><span class="p">]</span>  <span class="c1"># list with the concatenation of three iterables</span>
<span class="p">{</span><span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="o">*</span><span class="n">it2</span><span class="p">,</span> <span class="o">*</span><span class="n">it3</span><span class="p">}</span>  <span class="c1"># set with the union of three iterables</span>
<span class="p">{</span><span class="o">**</span><span class="n">dict1</span><span class="p">,</span> <span class="o">**</span><span class="n">dict2</span><span class="p">,</span> <span class="o">**</span><span class="n">dict3</span><span class="p">}</span>  <span class="c1"># dict with the combination of three dicts</span>
</pre></div>
</div>
<p>But if we want to similarly combine an arbitrary number of iterables, we cannot
use unpacking in this same way.</p>
<p>That said, we do have a few options for combining multiple iterables.  We
could, for example, use explicit looping structures and built-in means of
combination:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

<span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
    <span class="n">new_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">new_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">it</span>
</pre></div>
</div>
<p>Or, we could be more concise by using a comprehension with two loops:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">]</span>
<span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">}</span>
<span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, we could use <code class="docutils literal notranslate"><span class="pre">itertools.chain</span></code> or <code class="docutils literal notranslate"><span class="pre">itertools.chain.from_iterable</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">))</span>
<span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">))</span>
<span class="nb">dict</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">)))</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">)</span>

<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">))</span>
<span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">))</span>
<span class="nb">dict</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">))</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, for all but the generator, we could use <code class="docutils literal notranslate"><span class="pre">functools.reduce</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">iconcat</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_list</span> <span class="o">:=</span> <span class="p">[]))</span>
<span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ior</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_set</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">()))</span>
<span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ior</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_dict</span> <span class="o">:=</span> <span class="p">{}))</span>
</pre></div>
</div>
<p>This PEP proposes allowing unpacking operations to be used in comprehensions as
an additional alternative:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>  <span class="c1"># list with the concatenation of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>  <span class="c1"># set with the union of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">**</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span> <span class="c1"># dict with the combination of dicts in &#39;dicts&#39;</span>
<span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">)</span>  <span class="c1"># generator of the concatenation of iterables in &#39;its&#39;</span>
</pre></div>
</div>
<p>This proposal also extends to asynchronous comprehensions and generator
expressions, such that, for example, <code class="docutils literal notranslate"><span class="pre">(*ait</span> <span class="pre">async</span> <span class="pre">for</span> <span class="pre">ait</span> <span class="pre">in</span> <span class="pre">aits())</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">async</span> <span class="pre">for</span> <span class="pre">ait</span> <span class="pre">in</span> <span class="pre">aits()</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">ait)</span></code>.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Combining multiple iterable objects together into a single object is a common
task.  For example, one <a class="reference external" href="https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists">StackOverflow post</a>
asking about flattening a list of lists has been viewed 4.6 million times, and
there are several examples of code from the standard library that perform this
operation (see <a class="reference internal" href="#pep798-examples"><span class="std std-ref">Code Examples</span></a>).  While Python provides a means of
combining a small, known number of iterables using extended unpacking from
<a class="pep reference internal" href="../pep-0448/" title="PEP 448 – Additional Unpacking Generalizations">PEP 448</a>, no comparable syntax currently exists for combining an arbitrary
number of iterables.</p>
<p>This proposal represents a natural extension of the language, paralleling
existing syntactic structures: where <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> creates a list from a fixed
number of values, <code class="docutils literal notranslate"><span class="pre">[item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">items]</span></code> creates a list from an arbitrary
number of values; this proposal extends that notion to the construction of
lists that involve unpacking, making <code class="docutils literal notranslate"><span class="pre">[*item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">items]</span></code> analogous to
<code class="docutils literal notranslate"><span class="pre">[*x,</span> <span class="pre">*y,</span> <span class="pre">*z]</span></code>.</p>
<p>We expect this syntax to be intuitive and familiar to programmers already
comfortable with both comprehensions and unpacking notation.  This proposal was
motivated in part by a written exam in a Python programming class, where
several students used the proposed notation (specifically the <code class="docutils literal notranslate"><span class="pre">set</span></code> version)
in their solutions, assuming that it already existed in Python. This suggests
that the notation represents a logical, consistent extension to Python’s
existing syntax.  By contrast, the existing double-loop version <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">it</span> <span class="pre">in</span>
<span class="pre">its</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> is one that students often get wrong, the natural impulse
for many students being to reverse the order of the <code class="docutils literal notranslate"><span class="pre">for</span></code> clauses.  The
intuitiveness of the proposed syntax is further supported by the comment
section of a <a class="reference external" href="https://old.reddit.com/r/Python/comments/1m607oi/pep_798_unpacking_in_comprehensions/">Reddit post</a>
made following the initial publication of this PEP, which demonstrates support
from a broader community.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="syntax">
<h3><a class="toc-backref" href="#syntax" role="doc-backlink">Syntax</a></h3>
<p>The grammar should be changed to allow the expression in list/set
comprehensions and generator expressions to be preceded by a <code class="docutils literal notranslate"><span class="pre">*</span></code>, and
allowing an alternative form of dictionary comprehension in which a
double-starred expression can be used in place of a <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> pair.</p>
<p>This can be accomplished by updating the <code class="docutils literal notranslate"><span class="pre">listcomp</span></code> and <code class="docutils literal notranslate"><span class="pre">setcomp</span></code> rules to
use <code class="docutils literal notranslate"><span class="pre">star_named_expression</span></code> instead of <code class="docutils literal notranslate"><span class="pre">named_expression</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>listcomp[expr_ty]:
    | &#39;[&#39; a=star_named_expression b=for_if_clauses &#39;]&#39;

setcomp[expr_ty]:
    | &#39;{&#39; a=star_named_expression b=for_if_clauses &#39;}&#39;
</pre></div>
</div>
<p>The rule for <code class="docutils literal notranslate"><span class="pre">genexp</span></code> would similarly need to be modified to allow a
<code class="docutils literal notranslate"><span class="pre">starred_expression</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>genexp[expr_ty]:
    | &#39;(&#39; a=(assignment_expression | expression !&#39;:=&#39; | starred_expression) b=for_if_clauses &#39;)&#39;
</pre></div>
</div>
<p>The rule for dictionary comprehensions would need to be adjusted as well, to
allow for this new form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dictcomp[expr_ty]:
    | &#39;{&#39; a=double_starred_kvpair b=for_if_clauses &#39;}&#39;
</pre></div>
</div>
<p>No change should be made to the way that argument unpacking is handled in
function calls, i.e., the general rule that generator expressions provided as
the sole argument to functions do not require additional redundant parentheses
should be retained.  Note that this implies that, for example, <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it))</span></code> (see <a class="reference internal" href="#pep798-functionargs"><span class="std std-ref">Starred Generators as Function Arguments</span></a>
for more discussion).</p>
<p><code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> should only be allowed at the top-most level of the expression
in the comprehension (see <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a> for more discussion).</p>
</section>
<section id="semantics-list-set-dict-comprehensions">
<h3><a class="toc-backref" href="#semantics-list-set-dict-comprehensions" role="doc-backlink">Semantics: List/Set/Dict Comprehensions</a></h3>
<p>The meaning of a starred expression in a list comprehension <code class="docutils literal notranslate"><span class="pre">[*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it]</span></code> is to treat each expression as an iterable, and concatenate them, in the
same way as if they were explicitly listed via <code class="docutils literal notranslate"><span class="pre">[*expr1,</span> <span class="pre">*expr2,</span> <span class="pre">...]</span></code>.
Similarly, <code class="docutils literal notranslate"><span class="pre">{*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it}</span></code> forms a set union, as if the expressions
were explicitly listed via <code class="docutils literal notranslate"><span class="pre">{*expr1,</span> <span class="pre">*expr2,</span> <span class="pre">...}</span></code>; and <code class="docutils literal notranslate"><span class="pre">{**expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it}</span></code> combines dictionaries, as if the expressions were explicitly listed via
<code class="docutils literal notranslate"><span class="pre">{**expr1,</span> <span class="pre">**expr2,</span> <span class="pre">...}</span></code>.  These operations should retain all of the
equivalent semantics for combining collections in this way (including, for
example, later values replacing earlier ones in the case of a duplicated key
when combining dictionaries).</p>
<p>Said another way, the objects created by the following comprehensions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">expr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>
<span class="n">new_set</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">expr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>
<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">expr</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span>
</pre></div>
</div>
<p>should be equivalent to the objects created by the following pieces of code,
respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
    <span class="n">new_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="semantics-generator-expressions">
<span id="pep798-genexpsemantics"></span><h3><a class="toc-backref" href="#semantics-generator-expressions" role="doc-backlink">Semantics: Generator Expressions</a></h3>
<p>Generator expressions using the unpacking syntax should form new generators
producing values from the concatenation of the iterables given by the
expressions.  Specifically, the behavior is defined to be equivalent to the
following (though without defining or referencing the looping variable <code class="docutils literal notranslate"><span class="pre">i</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (*expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (*expr async for x in ait())</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ait</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#pep798-alternativegenexpsemantics"><span class="std std-ref">Alternative Generator Expression Semantics</span></a> for more discussion of these semantics.</p>
<section id="interaction-with-assignment-expressions">
<h4><a class="toc-backref" href="#interaction-with-assignment-expressions" role="doc-backlink">Interaction with Assignment Expressions</a></h4>
<p>Note that this proposal does not suggest changing the order of evaluation of
the various pieces of the comprehension, nor any rules about scoping.  This is
particularly relevant for generator expressions that make use of the “walrus
operator” <code class="docutils literal notranslate"><span class="pre">:=</span></code> from <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, which, when used in a comprehension or a
generator expression, performs its variable binding in the containing scope
rather than locally to the comprehension.</p>
<p>As an example, consider the generator that results from evaluating the
expression <code class="docutils literal notranslate"><span class="pre">(*(y</span> <span class="pre">:=</span> <span class="pre">[i,</span> <span class="pre">i+1])</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">(0,</span> <span class="pre">2,</span> <span class="pre">4))</span></code>.  This is approximately
equivalent to the following generator, except that in its generator expression
form, <code class="docutils literal notranslate"><span class="pre">y</span></code> will be bound in the containing scope instead of locally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="n">y</span> <span class="o">:=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="n">j</span>
</pre></div>
</div>
<p>In this example, the subexpression <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:=</span> <span class="pre">[i,</span> <span class="pre">i+1])</span></code> is evaluated exactly
three times before the generator is exhausted: just after assigning <code class="docutils literal notranslate"><span class="pre">i</span></code> in
the comprehension to <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">4</span></code>, respectively.  Thus, <code class="docutils literal notranslate"><span class="pre">y</span></code> (in
the containing scope) will be modified at those points in time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">:=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;python-input-1&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">y</span>
<span class="gr">NameError</span>: <span class="n">name &#39;y&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
</section>
</section>
<section id="error-reporting">
<h3><a class="toc-backref" href="#error-reporting" role="doc-backlink">Error Reporting</a></h3>
<p>Currently, the proposed syntax generates a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>.  Allowing these
forms to be recognized as syntactically valid requires adjusting the grammar
rules for <code class="docutils literal notranslate"><span class="pre">invalid_comprehension</span></code> and <code class="docutils literal notranslate"><span class="pre">invalid_dict_comprehension</span></code> to allow
the use of <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>, respectively.</p>
<p>Additional specific error messages should be provided in at least the following
cases:</p>
<ul>
<li>Attempting to use <code class="docutils literal notranslate"><span class="pre">**</span></code> in a list comprehension or generator expression
should report that dictionary unpacking cannot be used in those structures,
for example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in list comprehension</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">(</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in generator expression</span>
</pre></div>
</div>
</li>
<li>The existing error message for attempting to use <code class="docutils literal notranslate"><span class="pre">*</span></code> in a dictionary
key/value should be retained, but similar messages should be reported
when attempting to use <code class="docutils literal notranslate"><span class="pre">**</span></code> unpacking on a dictionary key or value, for
example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use a starred expression in a dictionary key</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">*</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">*</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">        </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use a starred expression in a dictionary value</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in a dictionary key</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">        </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in a dictionary value</span>
</pre></div>
</div>
</li>
<li>The phrasing of some other existing error messages should similarly be
adjusted to account for the presence of the new syntax, and/or to clarify
ambiguous or confusing cases relating to unpacking more generally
(particularly the cases mentioned in <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a>), for
example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">]</span>
<span class="w">     </span><span class="pm">^^^^^^^^^^^^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid starred expression. Did you forget to wrap the conditional expression in parentheses?</span>

<span class="x"> &gt;&gt;&gt; {**x if x else y}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">**</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^^^^^^^^^^^^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid double starred expression. Did you forget to wrap the conditional expression in parentheses?</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">*</span><span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">*</span><span class="n">y</span><span class="p">]</span>
<span class="w">                 </span><span class="pm">^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot unpack only part of a conditional expression</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">**</span><span class="n">y</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">**</span><span class="n">y</span><span class="p">}</span>
<span class="w">                 </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking on only part of a conditional expression</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="reference-implementation">
<span id="pep798-reference"></span><h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The <a class="reference external" href="https://github.com/adqm/cpython/tree/comprehension_unpacking">reference implementation</a>
implements this functionality, including draft documentation and additional
test cases.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>The behavior of all comprehensions that are currently syntactically valid would
be unaffected by this change, so we do not anticipate much in the way of
backwards-incompatibility concerns.  In principle, this change would only
affect code that relied on the fact that attempting to use unpacking operations
in comprehensions would raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>, or that relied on the
particular phrasing of any of the old error messages being replaced, which we
expect to be rare.</p>
<p>One related concern is that a hypothetical future decision to change the
semantics of generator expressions to make use of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> during
unpacking (delegating to generators that are being unpacked) would not be
backwards-compatible because it would affect the behavior of the resulting
generators when used with <code class="docutils literal notranslate"><span class="pre">.send()</span></code>/<code class="docutils literal notranslate"><span class="pre">.asend()</span></code>, <code class="docutils literal notranslate"><span class="pre">.throw()</span></code>/<code class="docutils literal notranslate"><span class="pre">.athrow()</span></code>,
and <code class="docutils literal notranslate"><span class="pre">.close()</span></code>/<code class="docutils literal notranslate"><span class="pre">.aclose()</span></code>.  That said, despite being
backwards-incompatible, such a change would be unlikely to have a large impact
because it would only affect the behavior of structures that, under this
proposal, are not particularly useful.  See
<a class="reference internal" href="#pep798-alternativegenexpsemantics"><span class="std std-ref">Alternative Generator Expression Semantics</span></a> for more discussion.</p>
</section>
<section id="code-examples">
<span id="pep798-examples"></span><h2><a class="toc-backref" href="#code-examples" role="doc-backlink">Code Examples</a></h2>
<p>This section shows some illustrative examples of how small pieces of code from
the standard library could be rewritten to make use of this new syntax.  The
<a class="reference internal" href="#pep798-reference"><span class="std std-ref">Reference Implementation</span></a> continues to pass all tests with these replacements
made.</p>
<section id="replacing-explicit-loops">
<h3><a class="toc-backref" href="#replacing-explicit-loops" role="doc-backlink">Replacing Explicit Loops</a></h3>
<p>Replacing explicit loops compresses multiple lines into one, and avoids the
need for defining and referencing an auxiliary variable.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">email/_header_value_parser.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
    <span class="n">comments</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">comments</span><span class="p">)</span>
<span class="k">return</span> <span class="n">comments</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">token</span><span class="o">.</span><span class="n">comments</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">shutil.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">ignored_names</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="n">ignored_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
<span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignored_names</span><span class="p">)</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="p">{</span><span class="o">*</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span> <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">}</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">http/cookiejar.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">cookies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cookies</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">cookies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cookies_for_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">request</span><span class="p">))</span>
<span class="k">return</span> <span class="n">cookies</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="p">[</span>
    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_cookies_for_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cookies</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="replacing-from-iterable-and-friends">
<h3><a class="toc-backref" href="#replacing-from-iterable-and-friends" role="doc-backlink">Replacing from_iterable and Friends</a></h3>
<p>While not always the right choice, replacing <code class="docutils literal notranslate"><span class="pre">itertools.chain.from_iterable</span></code>
and <code class="docutils literal notranslate"><span class="pre">map</span></code> can avoid an extra level of redirection, resulting in code that
follows conventional wisdom that comprehensions are generally more readable
than map/filter.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">dataclasses.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">inherited_slots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_get_slots</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="p">)</span>

<span class="c1"># proposed:</span>
<span class="n">inherited_slots</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">_get_slots</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">importlib/metadata/__init__.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
    <span class="n">path</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">FastPath</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">FastPath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">collections/__init__.py</span></code> (<code class="docutils literal notranslate"><span class="pre">Counter</span></code> class):<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="n">_chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_starmap</span><span class="p">(</span><span class="n">_repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_repeat</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">zipfile/_path/__init__.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">parents</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_parents</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>

<span class="c1"># proposed:</span>
<span class="n">parents</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">_parents</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">_pyrepl/_module_completer.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">search_locations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
    <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;submodule_search_locations&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span> <span class="k">if</span> <span class="n">spec</span>
<span class="p">))</span>

<span class="c1"># proposed:</span>
<span class="n">search_locations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">*</span><span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;submodule_search_locations&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span> <span class="k">if</span> <span class="n">spec</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="replacing-double-loops-in-comprehensions">
<h3><a class="toc-backref" href="#replacing-double-loops-in-comprehensions" role="doc-backlink">Replacing Double Loops in Comprehensions</a></h3>
<p>Replacing double loops in comprehensions avoids the need for defining and
referencing an auxiliary variable.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">importlib/resources/readers.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>

<span class="c1"># proposed:</span>
<span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">asyncio/base_events.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">exc</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">exceptions</span> <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">]</span>

<span class="c1"># proposed:</span>
<span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">sub</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">_weakrefset.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

<span class="c1"># proposed:</span>
<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Currently, a common way to introduce the notion of comprehensions (which is
employed by the Python Tutorial) is to demonstrate equivalent code.  For
example, this method would say that, for example, <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code>
is equivalent to the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Taking this approach, we can introduce <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> as instead
being equivalent to the following (which uses <code class="docutils literal notranslate"><span class="pre">extend</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">append</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Set and dict comprehensions that make use of unpacking can also be introduced
by a similar analogy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to out = {expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="c1"># equivalent to out = {*expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="c1"># equivalent to out = {k_expr: v_expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="p">[</span><span class="n">k_expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_expr</span>

<span class="c1"># equivalent to out = {**expr for x in it}, provided that expr evaluates to</span>
<span class="c1"># a mapping that can be unpacked with **</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>And we can take a similar approach to illustrate the behavior of generator
expressions that involve unpacking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">expr</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>

<span class="c1"># equivalent to g = (*expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">expr</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<p>We can then generalize from these specific examples to the idea that, wherever
a non-starred comprehension/genexp would use an operator that adds a single
element to a collection, the starred would instead use an operator that adds
multiple elements to that collection.</p>
<p>Alternatively, we don’t need to think of the two ideas as separate; instead,
with the new syntax, we can think of <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[...x...</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> as
equivalent to the following <a class="footnote-reference brackets" href="#pep798-guido" id="id2">[1]</a> (where <code class="docutils literal notranslate"><span class="pre">...x...</span></code> is a stand-in
for arbitrary code), regardless of whether or not <code class="docutils literal notranslate"><span class="pre">...x...</span></code> uses <code class="docutils literal notranslate"><span class="pre">*</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Similarly, we can think of <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">{...x...</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it}</span></code> as equivalent to the
following code, regardless of whether or not <code class="docutils literal notranslate"><span class="pre">...x...</span></code> uses <code class="docutils literal notranslate"><span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">**</span></code>
or <code class="docutils literal notranslate"><span class="pre">:</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># or out = {}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="p">})</span>
</pre></div>
</div>
<p>These examples are equivalent in the sense that the output they produce would
be the same in both the version with the comprehension and the version without
it, but note that the non-comprehension version is slightly less efficient due
to making new lists/sets/dictionaries before each <code class="docutils literal notranslate"><span class="pre">extend</span></code> or <code class="docutils literal notranslate"><span class="pre">update</span></code>,
which is unnecessary in the version that uses comprehensions.</p>
</section>
<section id="rejected-alternative-proposals">
<h2><a class="toc-backref" href="#rejected-alternative-proposals" role="doc-backlink">Rejected Alternative Proposals</a></h2>
<p>The primary goal when thinking through the specification above was consistency
with existing norms around unpacking and comprehensions / generator
expressions.  One way to interpret this is that the goal was to write the
specification so as to require the smallest possible change(s) to the existing
grammar and code generation, letting the existing code inform the surrounding
semantics.</p>
<p>Below we discuss some of the common concerns/alternative proposals that came up
in discussions but that are not included in this proposal.</p>
<section id="starred-generators-as-function-arguments">
<span id="pep798-functionargs"></span><h3><a class="toc-backref" href="#starred-generators-as-function-arguments" role="doc-backlink">Starred Generators as Function Arguments</a></h3>
<p>One common concern that has arisen multiple times (not only in the discussion
threads linked above but also in previous discussions around this same idea) is
a possible syntactical ambiguity when passing a starred generator as the sole
argument to <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code>.  In the original <a class="pep reference internal" href="../pep-0448/" title="PEP 448 – Additional Unpacking Generalizations">PEP 448</a>, this ambiguity
was cited as a reason for not including a similar generalization as part of the
proposal.</p>
<p>This proposal suggests that <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> should be interpreted as
<code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code> and should not attempt further unpacking of the
resulting generator, but several alternatives were suggested in our discussion
(and/or have been suggested in the past), including:</p>
<ul class="simple">
<li>interpreting <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> as <code class="docutils literal notranslate"><span class="pre">f(*(x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code>,</li>
<li>interpreting <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> as <code class="docutils literal notranslate"><span class="pre">f(*(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code>, or</li>
<li>continuing to raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> for <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> even if the
other aspects of this proposal are accepted.</li>
</ul>
<p>The reason to prefer this proposal over these alternatives is the preservation
of existing conventions for punctuation around generator expressions.
Currently, the general rule is that generator expressions must be wrapped in
parentheses except when provided as the sole argument to a function, and this
proposal suggests maintaining that rule even as we allow more kinds of
generator expressions.  This option maintains a full symmetry between
comprehensions and generator expressions that use unpacking and those that
don’t.</p>
<p>Currently, we have the following conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in a single list</span>
<span class="n">f</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in a single set</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># pass in a single generator (no additional parentheses required around genexp)</span>

<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in elements from the list separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in elements from the set separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># pass in elements from the generator separately (parentheses required)</span>
</pre></div>
</div>
<p>This proposal opts to maintain those conventions even when the comprehensions
make use of unpacking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">([</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in a single list</span>
<span class="n">f</span><span class="p">({</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in a single set</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># pass in a single generator (no additional parentheses required around genexp)</span>

<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in elements from the list separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">{</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in elements from the set separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># pass in elements from the generator separately (parentheses required)</span>
</pre></div>
</div>
</section>
<section id="further-generalizing-unpacking-operators">
<span id="pep798-moregeneral"></span><h3><a class="toc-backref" href="#further-generalizing-unpacking-operators" role="doc-backlink">Further Generalizing Unpacking Operators</a></h3>
<p>Another suggestion that came out of the discussion involved further
generalizing the <code class="docutils literal notranslate"><span class="pre">*</span></code> beyond simply allowing it to be used to unpack the
expression in a comprehension.  Two main flavors of this extension were
considered:</p>
<ul>
<li>making <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> true unary operators that create a new kind of
<code class="docutils literal notranslate"><span class="pre">Unpackable</span></code> object (or similar), which comprehensions could treat by
unpacking it but which could also be used in other contexts; or</li>
<li>continuing to allow <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> only in the places they are allowed
elsewhere in this proposal (expression lists, comprehensions, generator
expressions, and argument lists), but also allow them to be used in
subexpressions within a comprehension, allowing, for example, the following
as a way to flatten a list that contains some iterables but some non-iterable
objects:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
</li>
</ul>
<p>These variants were considered substantially more complex (both to understand
and to implement) and of only marginal utility, so neither is included in this
PEP.  As such, these forms should continue to raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>, but with
a new error message as described above, though it should not be ruled out as a
consideration for future proposals.</p>
</section>
<section id="alternative-generator-expression-semantics">
<span id="pep798-alternativegenexpsemantics"></span><h3><a class="toc-backref" href="#alternative-generator-expression-semantics" role="doc-backlink">Alternative Generator Expression Semantics</a></h3>
<p>Another point of discussion centered around the semantics of unpacking in
generator expressions, particularly the relationship between the semantics of
synchronous and asynchronous generator expressions given that async generators
do not support <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (see the section of <a class="pep reference internal" href="../pep-0525/" title="PEP 525 – Asynchronous Generators">PEP 525</a> on Asynchronous
<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>).</p>
<p>The core question centered around whether sync and async generator expressions
should use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (or an equivalent) when unpacking, as opposed to an
explicit loop.  The main difference between these options is whether the
resulting generator delegates to the objects being unpacked, which would affect
the behavior of these generator expressions when used with
<code class="docutils literal notranslate"><span class="pre">.send()/.asend()</span></code>, <code class="docutils literal notranslate"><span class="pre">.throw()/.athrow()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.close()/.aclose()</span></code> in the
case where the objects being unpacked are themselves generators.  The
differences between these options are summarized in
<a class="reference internal" href="#pep798-appendix-yieldfrom"><span class="std std-ref">Appendix: Semantics of Generator Delegation</span></a>.</p>
<p>Several reasonable options were considered, none of which was a clear winner in
a <a class="reference external" href="https://discuss.python.org/t/pep-798-unpacking-in-comprehensions/99435/33">poll in the Discourse thread</a>.
Beyond the proposal outlined above, the following were also considered:</p>
<ol class="arabic">
<li>Using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in synchronous generator expressions but
using an explicit loop in asynchronous generator expressions (as proposed in
the original draft of this PEP).<p>This strategy would have allowed unpacking in generator expressions to
closely mimic a popular way of writing generators that perform this
operation (using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>), but it would also have created an
asymmetry between synchronous and asynchronous versions, and also between
this new syntax and <code class="docutils literal notranslate"><span class="pre">itertools.chain</span></code> and the double-loop version.</p>
</li>
<li>Using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in synchronous generator expressions and
mimicking the behavior of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in async generator
expressions.<p>This strategy would also make unpacking in synchronous and asynchronous
generators behave symmetrically, but it would also be more complex, enough
so that the cost may not be worth the benefit, particularly in the absence
of a compelling use case for delegation.</p>
</li>
<li>Using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in synchronous generator expressions, and
disallowing unpacking in asynchronous generator expressions until they
support <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>.<p>This strategy could possibly reduce friction if asynchronous generator
expressions do gain support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> in the future by making sure
that any decision made at that point would be fully backwards-compatible,
but in the meantime, it would result in an even bigger discrepancy between
synchronous and asynchronous generator expressions than option 1.</p>
</li>
<li>Disallowing unpacking in all generator expressions.<p>This would retain symmetry between the two cases, but with the downside of
losing an expressive form and reducing symmetry between list/set
comprehensions and generator expressions.</p>
</li>
</ol>
<p>Each of these options (including the one presented in this PEP) has its
benefits and drawbacks, with no option being clearly superior on all fronts.
The semantics proposed in <a class="reference internal" href="#pep798-genexpsemantics"><span class="std std-ref">Semantics: Generator Expressions</span></a> above represent a
reasonable compromise by allowing exactly the same kind of unpacking in
synchronous and asynchronous generator expressions and retaining an existing
property of generator expressions (that they do not delegate to subgenerators).</p>
<p>This decision should be revisited in the event that asynchronous generators
receive support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> in the future, in which case adjusting the
semantics of unpacking in generator expressions to use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> should be
considered.</p>
</section>
</section>
<section id="concerns-and-disadvantages">
<h2><a class="toc-backref" href="#concerns-and-disadvantages" role="doc-backlink">Concerns and Disadvantages</a></h2>
<p>Although the general consensus from the discussion thread seemed to be that
this syntax was clear and intuitive, several concerns and potential downsides
were raised as well. This section aims to summarize those concerns.</p>
<ul class="simple">
<li><strong>Overlap with existing alternatives:</strong>
While the proposed syntax represents a consistent extension to the language
and is likely to result in more-concise code, there are already several ways
to accomplish this same thing in Python.</li>
<li><strong>Function call ambiguity:</strong>
Expressions like <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> may initially appear ambiguous, as it’s
not obvious whether the intent is to unpack the generator or to pass it as a
single argument. Although this proposal retains existing conventions by
treating that form as equivalent to <code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code>, that equivalence
may not be immediately obvious.</li>
<li><strong>Potential for overuse or abuse:</strong>
Complex uses of unpacking in comprehensions could obscure logic that may be
clearer in an explicit loop.  While this is already a concern with
comprehensions more generally, the addition of <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> may make
particularly complex uses even more difficult to read and understand at a
glance.  For example, while these situations are likely rare, comprehensions
that use unpacking in multiple ways can make it difficult to know what’s
being unpacked and when, e.g., <code class="docutils literal notranslate"><span class="pre">f(*(*x</span> <span class="pre">for</span> <span class="pre">*x,</span> <span class="pre">_</span> <span class="pre">in</span> <span class="pre">list_of_lists))</span></code>.</li>
<li><strong>Unclear limitation of scope:</strong>
This proposal restricts unpacking to the top level of the comprehension
expression, but some users may expect that the unpacking operator is being
further generalized as discussed in <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a>.</li>
<li><strong>Effect on External Tools:</strong>
As with any change to Python’s syntax, making this change would create work
for maintainers of code formatters, linters, type checkers, etc., to make
sure that the new syntax is supported.</li>
</ul>
</section>
<section id="appendix-other-languages">
<h2><a class="toc-backref" href="#appendix-other-languages" role="doc-backlink">Appendix: Other Languages</a></h2>
<p>Quite a few other languages support this kind of flattening with syntax similar
to what is already available in Python, but support for using unpacking syntax
within comprehensions is rare.  This section provides a brief summary of
support for similar syntax in a few other languages.</p>
<p>Many languages that support comprehensions support double loops:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># python</span>
<span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- haskell</span>
<span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># julia</span>
<span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="n">xs</span><span class="p">;</span><span class="w"> </span><span class="n">xs</span><span class="p">]]</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="c1">; clojure</span>
<span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">xs</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">concat </span><span class="nv">xs</span><span class="w"> </span><span class="nv">xs</span><span class="p">)]</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Several other languages (even those without comprehensions) support these
operations via a built-in function or method to support flattening of nested
structures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># python</span>
<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">xs</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])))</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// javascript</span>
<span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">5</span><span class="p">]].</span><span class="nx">flatMap</span><span class="p">(</span><span class="nx">xs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[...</span><span class="nx">xs</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">xs</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- haskell</span>
<span class="nf">concat</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
</pre></div>
</div>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="c1"># ruby</span>
<span class="o">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]].</span><span class="n">flat_map</span><span class="w"> </span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span>
</pre></div>
</div>
<p>However, languages that support both comprehension and unpacking do not tend to
allow unpacking within a comprehension.  For example, the following expression
in Julia currently leads to a syntax error:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xs</span><span class="o">...</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]]</span>
</pre></div>
</div>
<p>As one counterexample, support for a similar syntax was recently added to <a class="reference external" href="https://civet.dev/">Civet</a>.  For example, the following is a valid comprehension in
Civet, making use of JavaScript’s <code class="docutils literal notranslate"><span class="pre">...</span></code> syntax for unpacking:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">xs</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">5</span><span class="p">]]</span><span class="w"> </span><span class="nx">then</span><span class="w"> </span><span class="p">...(</span><span class="nx">xs</span><span class="o">++</span><span class="nx">xs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="appendix-semantics-of-generator-delegation">
<span id="pep798-appendix-yieldfrom"></span><h2><a class="toc-backref" href="#appendix-semantics-of-generator-delegation" role="doc-backlink">Appendix: Semantics of Generator Delegation</a></h2>
<p>One of the common questions about the semantics outlined above had to do with
the difference between using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> when unpacking inside of a
generator expression, versus using an explicit loop.  Because this is a
fairly-advanced feature of generators, this appendix attempts to summarize some
of the key differences between generators that use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> and those
that use explicit loops.</p>
<section id="basic-behavior">
<h3><a class="toc-backref" href="#basic-behavior" role="doc-backlink">Basic Behavior</a></h3>
<p>For simple iteration over values, which we expect to be by far the most-common
use of unpacking in generator expressions,  both approaches produce identical
results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">iterable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># Both produce the same sequence of values</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">yield_from</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">explicit_loop</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># prints True</span>
</pre></div>
</div>
</section>
<section id="advanced-generator-protocol-differences">
<h3><a class="toc-backref" href="#advanced-generator-protocol-differences" role="doc-backlink">Advanced Generator Protocol Differences</a></h3>
<p>The differences become apparent when using the advanced generator protocol
methods <code class="docutils literal notranslate"><span class="pre">.send()</span></code>, <code class="docutils literal notranslate"><span class="pre">.throw()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.close()</span></code>, and when the sub-iterables
are themselves generators rather than simple sequences.  In these cases, the
<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> version results in the associated signal reaching the
subgenerator, but the version with the explicit loop does not.</p>
<section id="delegation-with-send">
<h4><a class="toc-backref" href="#delegation-with-send" role="doc-backlink">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sub_generator</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;received: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">yield</span> <span class="s2">&quot;last&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">sub_generator</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sub_generator</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># With yield from, values are passed through to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>  <span class="c1"># prints &quot;received: hello&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;last&quot;</span>

<span class="c1"># With explicit loop, .send() affects the outer generator; values don&#39;t reach the sub-generator</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen2</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>  <span class="c1"># prints &quot;received: None&quot; (sub-generator receives None instead of &quot;hello&quot;)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;last&quot;</span>
</pre></div>
</div>
</section>
<section id="exception-handling-with-throw">
<h4><a class="toc-backref" href="#exception-handling-with-throw" role="doc-backlink">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sub_generator_with_exception_handling</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
        <span class="k">yield</span> <span class="s2">&quot;second&quot;</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;caught: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">sub_generator_with_exception_handling</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sub_generator_with_exception_handling</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># With yield from, exceptions are passed to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen1</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)))</span>  <span class="c1"># prints &quot;caught: test&quot;</span>

<span class="c1"># With explicit loop, exceptions affect the outer generator only</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen2</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)))</span>  <span class="c1"># ValueError is raised; sub-generator doesn&#39;t see it</span>
</pre></div>
</div>
</section>
<section id="generator-cleanup-with-close">
<h4><a class="toc-backref" href="#generator-cleanup-with-close" role="doc-backlink">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># hold references to sub-generators so GC doesn&#39;t close the explicit loop version</span>
<span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sub_generator_with_cleanup</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
        <span class="k">yield</span> <span class="s2">&quot;second&quot;</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sub-generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sub_generator_with_cleanup</span><span class="p">()</span>
        <span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">g</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;outer generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sub_generator_with_cleanup</span><span class="p">()</span>
        <span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;outer generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="c1"># With yield from, GeneratorExit is passed through to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="n">gen1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># closes sub-generator and then outer generator</span>

<span class="c1"># With explicit loop, GeneratorExit goes to outer generator only</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="n">gen2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># only closes outer generator</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;program finished; GC will close the explicit loop subgenerator&#39;</span><span class="p">)</span>
<span class="c1"># second inner generator closes when GC closes it at the end</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="pep798-guido" role="doc-footnote">
<dt class="label" id="pep798-guido">[<a href="#id2">1</a>]</dt>
<dd><a class="reference external" href="https://mail.python.org/archives/list/python-ideas&#64;python.org/message/CQPULNM6PM623PLXF5Z63BIUZGOSQEKW/">Message from Guido van Rossum</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0798.rst">https://github.com/python/peps/blob/main/peps/pep-0798.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0798.rst">2025-12-27 18:15:18 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#syntax">Syntax</a></li>
<li><a class="reference internal" href="#semantics-list-set-dict-comprehensions">Semantics: List/Set/Dict Comprehensions</a></li>
<li><a class="reference internal" href="#semantics-generator-expressions">Semantics: Generator Expressions</a><ul>
<li><a class="reference internal" href="#interaction-with-assignment-expressions">Interaction with Assignment Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#code-examples">Code Examples</a><ul>
<li><a class="reference internal" href="#replacing-explicit-loops">Replacing Explicit Loops</a></li>
<li><a class="reference internal" href="#replacing-from-iterable-and-friends">Replacing from_iterable and Friends</a></li>
<li><a class="reference internal" href="#replacing-double-loops-in-comprehensions">Replacing Double Loops in Comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternative-proposals">Rejected Alternative Proposals</a><ul>
<li><a class="reference internal" href="#starred-generators-as-function-arguments">Starred Generators as Function Arguments</a></li>
<li><a class="reference internal" href="#further-generalizing-unpacking-operators">Further Generalizing Unpacking Operators</a></li>
<li><a class="reference internal" href="#alternative-generator-expression-semantics">Alternative Generator Expression Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concerns-and-disadvantages">Concerns and Disadvantages</a></li>
<li><a class="reference internal" href="#appendix-other-languages">Appendix: Other Languages</a></li>
<li><a class="reference internal" href="#appendix-semantics-of-generator-delegation">Appendix: Semantics of Generator Delegation</a><ul>
<li><a class="reference internal" href="#basic-behavior">Basic Behavior</a></li>
<li><a class="reference internal" href="#advanced-generator-protocol-differences">Advanced Generator Protocol Differences</a><ul>
<li><a class="reference internal" href="#delegation-with-send">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></li>
<li><a class="reference internal" href="#exception-handling-with-throw">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></li>
<li><a class="reference internal" href="#generator-cleanup-with-close">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0798.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>