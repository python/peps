
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 798 – Unpacking in Comprehensions | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0798/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 798 – Unpacking in Comprehensions | peps.python.org'>
    <meta property="og:description" content="This PEP proposes extending list, set, and dictionary comprehensions, as well as generator expressions, to allow unpacking notation (* and **) at the start of the expression, providing a concise way of combining an arbitrary number of iterables into one...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0798/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes extending list, set, and dictionary comprehensions, as well as generator expressions, to allow unpacking notation (* and **) at the start of the expression, providing a concise way of combining an arbitrary number of iterables into one...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 798</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 798 – Unpacking in Comprehensions</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Adam Hartz &lt;hz&#32;&#97;t&#32;mit.edu&gt;, Erik Demaine &lt;edemaine&#32;&#97;t&#32;mit.edu&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Jelle Zijlstra &lt;jelle.zijlstra at gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/99435">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">19-Jul-2025</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/archives/list/python-ideas&#64;python.org/thread/7G732VMDWCRMWM4PKRG6ZMUKH7SUC7SH/" title="Python-Ideas thread">16-Oct-2021</a>, <a class="reference external" href="https://discuss.python.org/t/pre-pep-unpacking-in-comprehensions/96362" title="Discourse thread">22-Jun-2025</a>, <a class="reference external" href="https://discuss.python.org/t/pep-798-unpacking-in-comprehensions/99435" title="Discourse thread">19-Jul-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#syntax">Syntax</a></li>
<li><a class="reference internal" href="#semantics-list-set-dict-comprehensions">Semantics: List/Set/Dict Comprehensions</a></li>
<li><a class="reference internal" href="#semantics-generator-expressions">Semantics: Generator Expressions</a><ul>
<li><a class="reference internal" href="#interaction-with-assignment-expressions">Interaction with Assignment Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#code-examples">Code Examples</a><ul>
<li><a class="reference internal" href="#replacing-explicit-loops">Replacing Explicit Loops</a></li>
<li><a class="reference internal" href="#replacing-from-iterable-and-friends">Replacing from_iterable and Friends</a></li>
<li><a class="reference internal" href="#replacing-double-loops-in-comprehensions">Replacing Double Loops in Comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternative-proposals">Rejected Alternative Proposals</a><ul>
<li><a class="reference internal" href="#starred-generators-as-function-arguments">Starred Generators as Function Arguments</a></li>
<li><a class="reference internal" href="#further-generalizing-unpacking-operators">Further Generalizing Unpacking Operators</a></li>
<li><a class="reference internal" href="#alternative-generator-expression-semantics">Alternative Generator Expression Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concerns-and-disadvantages">Concerns and Disadvantages</a></li>
<li><a class="reference internal" href="#appendix-other-languages">Appendix: Other Languages</a></li>
<li><a class="reference internal" href="#appendix-semantics-of-generator-delegation">Appendix: Semantics of Generator Delegation</a><ul>
<li><a class="reference internal" href="#basic-behavior">Basic Behavior</a></li>
<li><a class="reference internal" href="#advanced-generator-protocol-differences">Advanced Generator Protocol Differences</a><ul>
<li><a class="reference internal" href="#delegation-with-send">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></li>
<li><a class="reference internal" href="#exception-handling-with-throw">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></li>
<li><a class="reference internal" href="#generator-cleanup-with-close">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes extending list, set, and dictionary comprehensions, as well
as generator expressions, to allow unpacking notation (<code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>) at the
start of the expression, providing a concise way of combining an arbitrary
number of iterables into one list or set or generator, or an arbitrary number
of dictionaries into one dictionary, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>  <span class="c1"># list with the concatenation of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>  <span class="c1"># set with the union of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">**</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span> <span class="c1"># dict with the combination of dicts in &#39;dicts&#39;</span>
<span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">)</span>  <span class="c1"># generator of the concatenation of iterables in &#39;its&#39;</span>
</pre></div>
</div>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Extended unpacking notation (<code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>) from <a class="pep reference internal" href="../pep-0448/" title="PEP 448 – Additional Unpacking Generalizations">PEP 448</a> makes it
easy to combine a few iterables or dictionaries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="o">*</span><span class="n">it2</span><span class="p">,</span> <span class="o">*</span><span class="n">it3</span><span class="p">]</span>  <span class="c1"># list with the concatenation of three iterables</span>
<span class="p">{</span><span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="o">*</span><span class="n">it2</span><span class="p">,</span> <span class="o">*</span><span class="n">it3</span><span class="p">}</span>  <span class="c1"># set with the union of three iterables</span>
<span class="p">{</span><span class="o">**</span><span class="n">dict1</span><span class="p">,</span> <span class="o">**</span><span class="n">dict2</span><span class="p">,</span> <span class="o">**</span><span class="n">dict3</span><span class="p">}</span>  <span class="c1"># dict with the combination of three dicts</span>
</pre></div>
</div>
<p>But if we want to similarly combine an arbitrary number of iterables, we cannot
use unpacking in this same way.</p>
<p>That said, we do have a few options for combining multiple iterables.  We
could, for example, use explicit looping structures and built-in means of
combination:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

<span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
    <span class="n">new_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">new_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">it</span>
</pre></div>
</div>
<p>Or, we could be more concise by using a comprehension with two loops:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">]</span>
<span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">}</span>
<span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, we could use <code class="docutils literal notranslate"><span class="pre">itertools.chain</span></code> or <code class="docutils literal notranslate"><span class="pre">itertools.chain.from_iterable</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">))</span>
<span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">))</span>
<span class="nb">dict</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">)))</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">its</span><span class="p">)</span>

<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">))</span>
<span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">))</span>
<span class="nb">dict</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">))</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">its</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, for all but the generator, we could use <code class="docutils literal notranslate"><span class="pre">functools.reduce</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">iconcat</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_list</span> <span class="o">:=</span> <span class="p">[]))</span>
<span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ior</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_set</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">()))</span>
<span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ior</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="p">(</span><span class="n">new_dict</span> <span class="o">:=</span> <span class="p">{}))</span>
</pre></div>
</div>
<p>This PEP proposes allowing unpacking operations to be used in comprehensions as
an additional alternative:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>  <span class="c1"># list with the concatenation of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>  <span class="c1"># set with the union of iterables in &#39;its&#39;</span>
<span class="p">{</span><span class="o">**</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span> <span class="c1"># dict with the combination of dicts in &#39;dicts&#39;</span>
<span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">its</span><span class="p">)</span>  <span class="c1"># generator of the concatenation of iterables in &#39;its&#39;</span>
</pre></div>
</div>
<p>This proposal also extends to asynchronous comprehensions and generator
expressions, such that, for example, <code class="docutils literal notranslate"><span class="pre">(*ait</span> <span class="pre">async</span> <span class="pre">for</span> <span class="pre">ait</span> <span class="pre">in</span> <span class="pre">aits())</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">async</span> <span class="pre">for</span> <span class="pre">ait</span> <span class="pre">in</span> <span class="pre">aits()</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">ait)</span></code>.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Combining iterable objects together into a single larger object is a common
task. One <a class="reference external" href="https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists">StackOverflow post</a>
asking about flattening a list of lists, for example, has been viewed 4.6
million times.  Despite this being a common operation, the options currently
available for performing it concisely require levels of indirection that can
make the resulting code difficult to read and understand.</p>
<p>The proposed notation is concise (avoiding the use and repetition of auxiliary
variables) and, we expect, intuitive and familiar to programmers familiar with
both comprehensions and unpacking notation (see <a class="reference internal" href="#pep798-examples"><span class="std std-ref">Code Examples</span></a> for
examples of code from the standard library that could be rewritten more clearly
and concisely using the proposed syntax).</p>
<p>This proposal was motivated in part by a written exam in a Python programming
class, where several students used the notation (specifically the <code class="docutils literal notranslate"><span class="pre">set</span></code>
version) in their solutions, assuming that it already existed in Python.  This
suggests that the notation is intuitive, even to beginners.  By contrast, the
existing syntax <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">its</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> is one that students often
get wrong, the natural impulse for many students being to reverse the order of
the <code class="docutils literal notranslate"><span class="pre">for</span></code> clauses.</p>
<p>Additionally, the comment section of a <a class="reference external" href="https://old.reddit.com/r/Python/comments/1m607oi/pep_798_unpacking_in_comprehensions/">Reddit post</a>
following the publication of this PEP shows substantial support for the
proposal and further suggests that the syntax proposed here is legible,
intuitive, and useful.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="syntax">
<h3><a class="toc-backref" href="#syntax" role="doc-backlink">Syntax</a></h3>
<p>The grammar should be changed to allow the expression in list/set
comprehensions and generator expressions to be preceded by a <code class="docutils literal notranslate"><span class="pre">*</span></code>, and
allowing an alternative form of dictionary comprehension in which a
double-starred expression can be used in place of a <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> pair.</p>
<p>This can be accomplished by updating the <code class="docutils literal notranslate"><span class="pre">listcomp</span></code> and <code class="docutils literal notranslate"><span class="pre">setcomp</span></code> rules to
use <code class="docutils literal notranslate"><span class="pre">star_named_expression</span></code> instead of <code class="docutils literal notranslate"><span class="pre">named_expression</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>listcomp[expr_ty]:
    | &#39;[&#39; a=star_named_expression b=for_if_clauses &#39;]&#39;

setcomp[expr_ty]:
    | &#39;{&#39; a=star_named_expression b=for_if_clauses &#39;}&#39;
</pre></div>
</div>
<p>The rule for <code class="docutils literal notranslate"><span class="pre">genexp</span></code> would similarly need to be modified to allow a
<code class="docutils literal notranslate"><span class="pre">starred_expression</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>genexp[expr_ty]:
    | &#39;(&#39; a=(assignment_expression | expression !&#39;:=&#39; | starred_expression) b=for_if_clauses &#39;)&#39;
</pre></div>
</div>
<p>The rule for dictionary comprehensions would need to be adjusted as well, to
allow for this new form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dictcomp[expr_ty]:
    | &#39;{&#39; a=double_starred_kvpair b=for_if_clauses &#39;}&#39;
</pre></div>
</div>
<p>No change should be made to the way that argument unpacking is handled in
function calls, i.e., the general rule that generator expressions provided as
the sole argument to functions do not require additional redundant parentheses
should be retained.  Note that this implies that, for example, <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it))</span></code> (see <a class="reference internal" href="#pep798-functionargs"><span class="std std-ref">Starred Generators as Function Arguments</span></a>
for more discussion).</p>
<p><code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> should only be allowed at the top-most level of the expression
in the comprehension (see <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a> for more discussion).</p>
</section>
<section id="semantics-list-set-dict-comprehensions">
<h3><a class="toc-backref" href="#semantics-list-set-dict-comprehensions" role="doc-backlink">Semantics: List/Set/Dict Comprehensions</a></h3>
<p>The meaning of a starred expression in a list comprehension <code class="docutils literal notranslate"><span class="pre">[*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it]</span></code> is to treat each expression as an iterable, and concatenate them, in the
same way as if they were explicitly listed via <code class="docutils literal notranslate"><span class="pre">[*expr1,</span> <span class="pre">*expr2,</span> <span class="pre">...]</span></code>.
Similarly, <code class="docutils literal notranslate"><span class="pre">{*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it}</span></code> forms a set union, as if the expressions
were explicitly listed via <code class="docutils literal notranslate"><span class="pre">{*expr1,</span> <span class="pre">*expr2,</span> <span class="pre">...}</span></code>; and <code class="docutils literal notranslate"><span class="pre">{**expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">it}</span></code> combines dictionaries, as if the expressions were explicitly listed via
<code class="docutils literal notranslate"><span class="pre">{**expr1,</span> <span class="pre">**expr2,</span> <span class="pre">...}</span></code>.  These operations should retain all of the
equivalent semantics for combining collections in this way (including, for
example, later values replacing earlier ones in the case of a duplicated key
when combining dictionaries).</p>
<p>Said another way, the objects created by the following comprehensions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">expr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">]</span>
<span class="n">new_set</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">expr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">}</span>
<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">expr</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">}</span>
</pre></div>
</div>
<p>should be equivalent to the objects created by the following pieces of code,
respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">its</span><span class="p">:</span>
    <span class="n">new_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
    <span class="n">new_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="semantics-generator-expressions">
<span id="pep798-genexpsemantics"></span><h3><a class="toc-backref" href="#semantics-generator-expressions" role="doc-backlink">Semantics: Generator Expressions</a></h3>
<p>Generator expressions using the unpacking syntax should form new generators
producing values from the concatenation of the iterables given by the
expressions.  Specifically, the behavior is defined to be equivalent to the
following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (*expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">expr</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> is not allowed inside of async generators (see the section
of <a class="pep reference internal" href="../pep-0525/" title="PEP 525 – Asynchronous Generators">PEP 525</a> on Asynchronous <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>), the equivalent for <code class="docutils literal notranslate"><span class="pre">(*expr</span>
<span class="pre">async</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">ait())</span></code> is more like the following (though of course this new
form should not define or reference the looping variable <code class="docutils literal notranslate"><span class="pre">i</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (*expr async for x in ait())</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ait</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<p>The specifics of these semantics should be revisited in the future,
particularly if async generators receive support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (in which
case the async variant may wish to be changed to make use of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
instead of an explicit loop).  See <a class="reference internal" href="#pep798-alternativegenexpsemantics"><span class="std std-ref">Alternative Generator Expression Semantics</span></a> for
more discussion.</p>
<section id="interaction-with-assignment-expressions">
<h4><a class="toc-backref" href="#interaction-with-assignment-expressions" role="doc-backlink">Interaction with Assignment Expressions</a></h4>
<p>Note that this proposal does not suggest changing the order of evaluation of
the various pieces of the comprehension, nor any rules about scoping.  This is
particularly relevant for generator expressions that make use of the “walrus
operator” <code class="docutils literal notranslate"><span class="pre">:=</span></code> from <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>, which, when used in a comprehension or a
generator expression, performs its variable binding in the containing scope
rather than locally to the comprehension.</p>
<p>As an example, consider the generator that results from evaluating the
expression <code class="docutils literal notranslate"><span class="pre">(*(y</span> <span class="pre">:=</span> <span class="pre">[i,</span> <span class="pre">i+1])</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">(0,</span> <span class="pre">2,</span> <span class="pre">4))</span></code>.  This is approximately
equivalent to the following generator, except that in its generator expression
form, <code class="docutils literal notranslate"><span class="pre">y</span></code> will be bound in the containing scope instead of locally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">y</span> <span class="o">:=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>In this example, the subexpression <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:=</span> <span class="pre">[i,</span> <span class="pre">i+1])</span></code> is evaluated exactly
three times before the generator is exhausted: just after assigning <code class="docutils literal notranslate"><span class="pre">i</span></code> in
the comprehension to <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">4</span></code>, respectively.  Thus, <code class="docutils literal notranslate"><span class="pre">y</span></code> (in
the containing scope) will be modified at those points in time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">:=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;python-input-1&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">y</span>
<span class="gr">NameError</span>: <span class="n">name &#39;y&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
</section>
</section>
<section id="error-reporting">
<h3><a class="toc-backref" href="#error-reporting" role="doc-backlink">Error Reporting</a></h3>
<p>Currently, the proposed syntax generates a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>.  Allowing these
forms to be recognized as syntactically valid requires adjusting the grammar
rules for <code class="docutils literal notranslate"><span class="pre">invalid_comprehension</span></code> and <code class="docutils literal notranslate"><span class="pre">invalid_dict_comprehension</span></code> to allow
the use of <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code>, respectively.</p>
<p>Additional specific error messages should be provided in at least the following
cases:</p>
<ul>
<li>Attempting to use <code class="docutils literal notranslate"><span class="pre">**</span></code> in a list comprehension or generator expression
should report that dictionary unpacking cannot be used in those structures,
for example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in list comprehension</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">(</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in generator expression</span>
</pre></div>
</div>
</li>
<li>The existing error message for attempting to use <code class="docutils literal notranslate"><span class="pre">*</span></code> in a dictionary
key/value should be retained, but similar messages should be reported
when attempting to use <code class="docutils literal notranslate"><span class="pre">**</span></code> unpacking on a dictionary key or value, for
example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use a starred expression in a dictionary key</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">*</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">*</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">        </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use a starred expression in a dictionary value</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in a dictionary key</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">}</span>
<span class="w">        </span><span class="pm">^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking in a dictionary value</span>
</pre></div>
</div>
</li>
<li>The phrasing of some other existing error messages should similarly be
adjusted to account for the presence of the new syntax, and/or to clarify
ambiguous or confusing cases relating to unpacking more generally
(particularly the cases mentioned in <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a>), for
example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">]</span>
<span class="w">     </span><span class="pm">^^^^^^^^^^^^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid starred expression. Did you forget to wrap the conditional expression in parentheses?</span>

<span class="x"> &gt;&gt;&gt; {**x if x else y}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="o">**</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">}</span>
<span class="w">     </span><span class="pm">^^^^^^^^^^^^^^^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid double starred expression. Did you forget to wrap the conditional expression in parentheses?</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">*</span><span class="n">y</span><span class="p">]</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">*</span><span class="n">y</span><span class="p">]</span>
<span class="w">                 </span><span class="pm">^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot unpack only part of a conditional expression</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">**</span><span class="n">y</span><span class="p">}</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="p">{</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="o">**</span><span class="n">y</span><span class="p">}</span>
<span class="w">                 </span><span class="pm">^^</span>
<span class="gr">SyntaxError</span>: <span class="n">cannot use dict unpacking on only part of a conditional expression</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="reference-implementation">
<span id="pep798-reference"></span><h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The <a class="reference external" href="https://github.com/adqm/cpython/tree/comprehension_unpacking">reference implementation</a>
implements this functionality, including draft documentation and additional
test cases.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>The behavior of all comprehensions that are currently syntactically valid would
be unaffected by this change, so we do not anticipate much in the way of
backwards-incompatibility concerns.  In principle, this change would only
affect code that relied on the fact that attempting to use unpacking operations
in comprehensions would raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>, or that relied on the
particular phrasing of any of the old error messages being replaced, which we
expect to be rare.</p>
<p>One related concern is that a hypothetical future decision to change the
semantics of async generator expressions to make use of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> during
unpacking (delegating to generators that are being unpacked) would not be
backwards-compatible because it would affect the behavior of the resulting
generators when used with <code class="docutils literal notranslate"><span class="pre">.asend()</span></code>, <code class="docutils literal notranslate"><span class="pre">.athrow()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.aclose()</span></code>.  That
said, despite being backwards-incompatible, such a change would be unlikely to
have a large impact because it would only affect the behavior of structures
that, under this proposal, are not particularly useful.  See
<a class="reference internal" href="#pep798-alternativegenexpsemantics"><span class="std std-ref">Alternative Generator Expression Semantics</span></a> for more discussion.</p>
</section>
<section id="code-examples">
<span id="pep798-examples"></span><h2><a class="toc-backref" href="#code-examples" role="doc-backlink">Code Examples</a></h2>
<p>This section shows some illustrative examples of how small pieces of code from
the standard library could be rewritten to make use of this new syntax to
improve concision and readability.  The <a class="reference internal" href="#pep798-reference"><span class="std std-ref">Reference Implementation</span></a> continues to
pass all tests with these replacements made.</p>
<section id="replacing-explicit-loops">
<h3><a class="toc-backref" href="#replacing-explicit-loops" role="doc-backlink">Replacing Explicit Loops</a></h3>
<p>Replacing explicit loops compresses multiple lines into one, and avoids the
need for defining and referencing an auxiliary variable.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">email/_header_value_parser.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
    <span class="n">comments</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">comments</span><span class="p">)</span>
<span class="k">return</span> <span class="n">comments</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">token</span><span class="o">.</span><span class="n">comments</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">shutil.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">ignored_names</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="n">ignored_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
<span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignored_names</span><span class="p">)</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="p">{</span><span class="o">*</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span> <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">}</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">http/cookiejar.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">cookies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cookies</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">cookies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cookies_for_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">request</span><span class="p">))</span>
<span class="k">return</span> <span class="n">cookies</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="p">[</span>
    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_cookies_for_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cookies</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="replacing-from-iterable-and-friends">
<h3><a class="toc-backref" href="#replacing-from-iterable-and-friends" role="doc-backlink">Replacing from_iterable and Friends</a></h3>
<p>While not always the right choice, replacing <code class="docutils literal notranslate"><span class="pre">itertools.chain.from_iterable</span></code>
and <code class="docutils literal notranslate"><span class="pre">map</span></code> can avoid an extra level of redirection, resulting in code that
follows conventional wisdom that comprehensions are more readable than
map/filter.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">dataclasses.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">inherited_slots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_get_slots</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="p">)</span>

<span class="c1"># improved:</span>
<span class="n">inherited_slots</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">_get_slots</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">importlib/metadata/__init__.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
    <span class="n">path</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">FastPath</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">FastPath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">collections/__init__.py</span></code> (<code class="docutils literal notranslate"><span class="pre">Counter</span></code> class):<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="n">_chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_starmap</span><span class="p">(</span><span class="n">_repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_repeat</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">zipfile/_path/__init__.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">parents</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_parents</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>

<span class="c1"># improved:</span>
<span class="n">parents</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">_parents</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">_pyrepl/_module_completer.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">search_locations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
    <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;submodule_search_locations&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span> <span class="k">if</span> <span class="n">spec</span>
<span class="p">))</span>

<span class="c1"># improved:</span>
<span class="n">search_locations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">*</span><span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;submodule_search_locations&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span> <span class="k">if</span> <span class="n">spec</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="replacing-double-loops-in-comprehensions">
<h3><a class="toc-backref" href="#replacing-double-loops-in-comprehensions" role="doc-backlink">Replacing Double Loops in Comprehensions</a></h3>
<p>Replacing double loops in comprehensions avoids the need for defining and
referencing an auxiliary variable, reducing clutter.</p>
<ul>
<li>From <code class="docutils literal notranslate"><span class="pre">importlib/resources/readers.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>

<span class="c1"># improved:</span>
<span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">asyncio/base_events.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">exc</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">exceptions</span> <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">]</span>

<span class="c1"># improved:</span>
<span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">sub</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>From <code class="docutils literal notranslate"><span class="pre">_weakrefset.py</span></code>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># current:</span>
<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

<span class="c1"># improved:</span>
<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Currently, a common way to introduce the notion of comprehensions (which is
employed by the Python Tutorial) is to demonstrate equivalent code.  For
example, this method would say that, for example, <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code>
is equivalent to the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Taking this approach, we can introduce <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[*expr</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> as instead
being equivalent to the following (which uses <code class="docutils literal notranslate"><span class="pre">extend</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">append</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Set and dict comprehensions that make use of unpacking can also be introduced
by a similar analogy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to out = {expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="c1"># equivalent to out = {*expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="c1"># equivalent to out = {k_expr: v_expr for x in it}</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="p">[</span><span class="n">k_expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_expr</span>

<span class="c1"># equivalent to out = {**expr for x in it}, provided that expr evaluates to</span>
<span class="c1"># a mapping that can be unpacked with **</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>And we can take a similar approach to illustrate the behavior of generator
expressions that involve unpacking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent to g = (expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">expr</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>

<span class="c1"># equivalent to g = (*expr for x in it)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">expr</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
</pre></div>
</div>
<p>We can then generalize from these specific examples to the idea that, wherever
a non-starred comprehension/genexp would use an operator that adds a single
element to a collection, the starred would instead use an operator that adds
multiple elements to that collection.</p>
<p>Alternatively, we don’t need to think of the two ideas as separate; instead,
with the new syntax, we can think of <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">[...x...</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it]</span></code> as
equivalent to the following <a class="footnote-reference brackets" href="#pep798-guido" id="id2">[1]</a> (where <code class="docutils literal notranslate"><span class="pre">...x...</span></code> is a stand-in
for arbitrary code), regardless of whether or not <code class="docutils literal notranslate"><span class="pre">...x...</span></code> uses <code class="docutils literal notranslate"><span class="pre">*</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Similarly, we can think of <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">{...x...</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">it}</span></code> as equivalent to the
following code, regardless of whether or not <code class="docutils literal notranslate"><span class="pre">...x...</span></code> uses <code class="docutils literal notranslate"><span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">**</span></code>
or <code class="docutils literal notranslate"><span class="pre">:</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># or out = {}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="p">})</span>
</pre></div>
</div>
<p>These examples are equivalent in the sense that the output they produce would
be the same in both the version with the comprehension and the version without
it, but note that the non-comprehension version is slightly less efficient due
to making new lists/sets/dictionaries before each <code class="docutils literal notranslate"><span class="pre">extend</span></code> or <code class="docutils literal notranslate"><span class="pre">update</span></code>,
which is unnecessary in the version that uses comprehensions.</p>
</section>
<section id="rejected-alternative-proposals">
<h2><a class="toc-backref" href="#rejected-alternative-proposals" role="doc-backlink">Rejected Alternative Proposals</a></h2>
<p>The primary goal when thinking through the specification above was consistency
with existing norms around unpacking and comprehensions / generator
expressions.  One way to interpret this is that the goal was to write the
specification so as to require the smallest possible change(s) to the existing
grammar and code generation, letting the existing code inform the surrounding
semantics.</p>
<p>Below we discuss some of the common concerns/alternative proposals that came up
in discussions but that are not included in this proposal.</p>
<section id="starred-generators-as-function-arguments">
<span id="pep798-functionargs"></span><h3><a class="toc-backref" href="#starred-generators-as-function-arguments" role="doc-backlink">Starred Generators as Function Arguments</a></h3>
<p>One common concern that has arisen multiple times (not only in the discussion
threads linked above but also in previous discussions around this same idea) is
a possible syntactical ambiguity when passing a starred generator as the sole
argument to <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code>.  In the original <a class="pep reference internal" href="../pep-0448/" title="PEP 448 – Additional Unpacking Generalizations">PEP 448</a>, this ambiguity
was cited as a reason for not including a similar generalization as part of the
proposal.</p>
<p>This proposal suggests that <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> should be interpreted as
<code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code> and should not attempt further unpacking of the
resulting generator, but several alternatives were suggested in our discussion
(and/or have been suggested in the past), including:</p>
<ul class="simple">
<li>interpreting <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> as <code class="docutils literal notranslate"><span class="pre">f(*(x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code>,</li>
<li>interpreting <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> as <code class="docutils literal notranslate"><span class="pre">f(*(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code>, or</li>
<li>continuing to raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> for <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> even if the
other aspects of this proposal are accepted.</li>
</ul>
<p>The reason to prefer this proposal over these alternatives is the preservation
of existing conventions for punctuation around generator expressions.
Currently, the general rule is that generator expressions must be wrapped in
parentheses except when provided as the sole argument to a function, and this
proposal suggests maintaining that rule even as we allow more kinds of
generator expressions.  This option maintains a full symmetry between
comprehensions and generator expressions that use unpacking and those that
don’t.</p>
<p>Currently, we have the following conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in a single list</span>
<span class="n">f</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in a single set</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># pass in a single generator (no additional parentheses required around genexp)</span>

<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in elements from the list separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in elements from the set separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># pass in elements from the generator separately (parentheses required)</span>
</pre></div>
</div>
<p>This proposal opts to maintain those conventions even when the comprehensions
make use of unpacking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">([</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in a single list</span>
<span class="n">f</span><span class="p">({</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in a single set</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># pass in a single generator (no additional parentheses required around genexp)</span>

<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>  <span class="c1"># pass in elements from the list separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">{</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">})</span>  <span class="c1"># pass in elements from the set separately</span>
<span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># pass in elements from the generator separately (parentheses required)</span>
</pre></div>
</div>
</section>
<section id="further-generalizing-unpacking-operators">
<span id="pep798-moregeneral"></span><h3><a class="toc-backref" href="#further-generalizing-unpacking-operators" role="doc-backlink">Further Generalizing Unpacking Operators</a></h3>
<p>Another suggestion that came out of the discussion involved further
generalizing the <code class="docutils literal notranslate"><span class="pre">*</span></code> beyond simply allowing it to be used to unpack the
expression in a comprehension.  Two main flavors of this extension were
considered:</p>
<ul>
<li>making <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> true unary operators that create a new kind of
<code class="docutils literal notranslate"><span class="pre">Unpackable</span></code> object (or similar), which comprehensions could treat by
unpacking it but which could also be used in other contexts; or</li>
<li>continuing to allow <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> only in the places they are allowed
elsewhere in this proposal (expression lists, comprehensions, generator
expressions, and argument lists), but also allow them to be used in
subexpressions within a comprehension, allowing, for example, the following
as a way to flatten a list that contains some iterables but some non-iterable
objects:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">*</span><span class="n">x</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
</li>
</ul>
<p>These variants were considered substantially more complex (both to understand
and to implement) and of only marginal utility, so neither is included in this
PEP.  As such, these forms should continue to raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>, but with
a new error message as described above, though it should not be ruled out as a
consideration for future proposals.</p>
</section>
<section id="alternative-generator-expression-semantics">
<span id="pep798-alternativegenexpsemantics"></span><h3><a class="toc-backref" href="#alternative-generator-expression-semantics" role="doc-backlink">Alternative Generator Expression Semantics</a></h3>
<p>Another point of discussion centered around the semantics of unpacking in
generator expressions, particularly the relationship between the semantics of
synchronous and asynchronous generator expressions given that async generators
do not support <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (see the section of <a class="pep reference internal" href="../pep-0525/" title="PEP 525 – Asynchronous Generators">PEP 525</a> on Asynchronous
<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>).</p>
<p>The core question centered around whether sync and async generator expressions
should use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (or an equivalent) when unpacking, as opposed to an
explicit loop.  The main difference between these options is whether the
resulting generator delegates to the objects being unpacked, which would affect
the behavior of these generator expressions when used with
<code class="docutils literal notranslate"><span class="pre">.send()/.asend()</span></code>, <code class="docutils literal notranslate"><span class="pre">.throw()/.athrow()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.close()/.aclose()</span></code> in the
case where the objects being unpacked are themselves generators.  The
differences between these options are summarized in
<a class="reference internal" href="#pep798-appendix-yieldfrom"><span class="std std-ref">Appendix: Semantics of Generator Delegation</span></a>.</p>
<p>Several reasonable options were considered, none of which was a clear winner in
a <a class="reference external" href="https://discuss.python.org/t/pep-798-unpacking-in-comprehensions/99435/33">poll in the Discourse thread</a>.
Beyond the proposal outlined above, the following were also considered:</p>
<ol class="arabic">
<li>Using explicit loops for both synchronous and asynchronous generator
expressions.<p>This strategy would have resulted in a symmetry between synchronous and
asynchronous generator expressions but would have prevented a
potentially-useful tool by disallowing delegation in the case of synchronous
generator expressions.  One specific concern with this approach is the
introduction of an asymmetry between synchronous and asynchronous
generators, but this concern is mitigated by the fact that these asymmetries
already exist between synchronous and asynchronous generators more
generally.</p>
</li>
<li>Using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in synchronous generator expressions and
mimicking the behavior of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in async generator
expressions.<p>This strategy would also make unpacking in synchronous and asynchronous
generators behave symmetrically, but it would also be more complex, enough
so that the cost may not be worth the benefit.  As such, this PEP proposes
that generator expressions using the unpacking operator should not use
semantics similar to <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> until <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> is supported in
asynchronous generators more generally.</p>
</li>
<li>Using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> for unpacking in synchronous generator expressions, and
disallowing unpacking in asynchronous generator expressions until they
support <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>.<p>This strategy could possibly reduce friction if asynchronous generator
expressions do gain support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> in the future by making sure
that any decision made at that point would be fully backwards-compatible.
But the utility of unpacking in that context seems to outweigh the potential
downside of a minimally-invasive backwards-incompatible change in the future
if async generator expressions do receive support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>.</p>
</li>
<li>Disallowing unpacking in all generator expressions.<p>This would retain symmetry between the two cases, but with the downside of
losing a very expressive form.</p>
</li>
</ol>
<p>Each of these options (including the one presented in this PEP) has its
benefits and drawbacks, with no option being clearly superior on all fronts.
The semantics proposed in <a class="reference internal" href="#pep798-genexpsemantics"><span class="std std-ref">Semantics: Generator Expressions</span></a> represent a reasonable
compromise where unpacking in both synchronous and asynchronous generator
expressions mirrors common ways of writing equivalent generators currently.
Moreover, these subtle differences are unlikely to be impactful for common use
cases (for example, there is no difference for the likely most-common use case
of combining simple collections).</p>
<p>As suggested above, this decision should be revisited in the event that
asynchronous generators receive support for <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> in the future, in
which case adjusting the semantics of unpacking in async generator expressions
to use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> should be considered.</p>
</section>
</section>
<section id="concerns-and-disadvantages">
<h2><a class="toc-backref" href="#concerns-and-disadvantages" role="doc-backlink">Concerns and Disadvantages</a></h2>
<p>Although the general consensus from the discussion thread seemed to be that
this syntax was clear and intuitive, several concerns and potential downsides
were raised as well. This section aims to summarize those concerns.</p>
<ul class="simple">
<li><strong>Overlap with existing alternatives:</strong>
While the proposed syntax is arguably clearer and more concise, there are
already several ways to accomplish this same thing in Python.</li>
<li><strong>Function call ambiguity:</strong>
Expressions like <code class="docutils literal notranslate"><span class="pre">f(*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y)</span></code> may initially appear ambiguous, as it’s
not obvious whether the intent is to unpack the generator or to pass it as a
single argument. Although this proposal retains existing conventions by
treating that form as equivalent to <code class="docutils literal notranslate"><span class="pre">f((*x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">y))</span></code>, that equivalence
may not be immediately obvious.</li>
<li><strong>Potential for overuse or abuse:</strong>
Complex uses of unpacking in comprehensions could obscure logic that would be
clearer in an explicit loop.  While this is already a concern with
comprehensions more generally, the addition of <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> may make
particularly complex uses even more difficult to read and understand at a
glance.  For example, while these situations are likely rare, comprehensions
that use unpacking in multiple ways can make it difficult to know what’s
being unpacked and when: <code class="docutils literal notranslate"><span class="pre">f(*(*x</span> <span class="pre">for</span> <span class="pre">*x,</span> <span class="pre">_</span> <span class="pre">in</span> <span class="pre">list_of_lists))</span></code>.</li>
<li><strong>Unclear limitation of scope:</strong>
This proposal restricts unpacking to the top level of the comprehension
expression, but some users may expect that the unpacking operator is being
further generalized as discussed in <a class="reference internal" href="#pep798-moregeneral"><span class="std std-ref">Further Generalizing Unpacking Operators</span></a>.</li>
<li><strong>Effect on External Tools:</strong>
As with any change to Python’s syntax, making this change would create work
for maintainers of code formatters, linters, type checkers, etc., to make
sure that the new syntax is supported.</li>
</ul>
</section>
<section id="appendix-other-languages">
<h2><a class="toc-backref" href="#appendix-other-languages" role="doc-backlink">Appendix: Other Languages</a></h2>
<p>Quite a few other languages support this kind of flattening with syntax similar
to what is already available in Python, but support for using unpacking syntax
within comprehensions is rare.  This section provides a brief summary of
support for similar syntax in a few other languages.</p>
<p>Many languages that support comprehensions support double loops:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># python</span>
<span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- haskell</span>
<span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># julia</span>
<span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="n">xs</span><span class="p">;</span><span class="w"> </span><span class="n">xs</span><span class="p">]]</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="c1">; clojure</span>
<span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">xs</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">concat </span><span class="nv">xs</span><span class="w"> </span><span class="nv">xs</span><span class="p">)]</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Several other languages (even those without comprehensions) support these
operations via a built-in function or method to support flattening of nested
structures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># python</span>
<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">xs</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])))</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// javascript</span>
<span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">5</span><span class="p">]].</span><span class="nx">flatMap</span><span class="p">(</span><span class="nx">xs</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[...</span><span class="nx">xs</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">xs</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- haskell</span>
<span class="nf">concat</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
</pre></div>
</div>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="c1"># ruby</span>
<span class="o">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]].</span><span class="n">flat_map</span><span class="w"> </span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span>
</pre></div>
</div>
<p>However, languages that support both comprehension and unpacking do not tend to
allow unpacking within a comprehension.  For example, the following expression
in Julia currently leads to a syntax error:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xs</span><span class="o">...</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]]</span>
</pre></div>
</div>
<p>As one counterexample, support for a similar syntax was recently added to <a class="reference external" href="https://civet.dev/">Civet</a>.  For example, the following is a valid comprehension in
Civet, making use of JavaScript’s <code class="docutils literal notranslate"><span class="pre">...</span></code> syntax for unpacking:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nx">xs</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">5</span><span class="p">]]</span><span class="w"> </span><span class="nx">then</span><span class="w"> </span><span class="p">...(</span><span class="nx">xs</span><span class="o">++</span><span class="nx">xs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="appendix-semantics-of-generator-delegation">
<span id="pep798-appendix-yieldfrom"></span><h2><a class="toc-backref" href="#appendix-semantics-of-generator-delegation" role="doc-backlink">Appendix: Semantics of Generator Delegation</a></h2>
<p>One of the common questions about the semantics outlined above had to do with
the difference between using <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> when unpacking inside of a
generator expression, versus using an explicit loop.  Because this is a
fairly-advanced feature of generators, this appendix attempts to summarize some
of the key differences between generators that use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> and those
that use explicit loops.</p>
<section id="basic-behavior">
<h3><a class="toc-backref" href="#basic-behavior" role="doc-backlink">Basic Behavior</a></h3>
<p>For simple iteration over values, which we expect to be by far the most-common
use of unpacking in generator expressions,  both approaches produce identical
results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">iterable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># Both produce the same sequence of values</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">yield_from</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">explicit_loop</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># prints True</span>
</pre></div>
</div>
</section>
<section id="advanced-generator-protocol-differences">
<h3><a class="toc-backref" href="#advanced-generator-protocol-differences" role="doc-backlink">Advanced Generator Protocol Differences</a></h3>
<p>The differences become apparent when using the advanced generator protocol
methods <code class="docutils literal notranslate"><span class="pre">.send()</span></code>, <code class="docutils literal notranslate"><span class="pre">.throw()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.close()</span></code>, and when the sub-iterables
are themselves generators rather than simple sequences.  In these cases, the
<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> version results in the associated signal reaching the
subgenerator, but the version with the explicit loop does not.</p>
<section id="delegation-with-send">
<h4><a class="toc-backref" href="#delegation-with-send" role="doc-backlink">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sub_generator</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;received: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">yield</span> <span class="s2">&quot;last&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">sub_generator</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sub_generator</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># With yield from, values are passed through to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>  <span class="c1"># prints &quot;received: hello&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;last&quot;</span>

<span class="c1"># With explicit loop, .send() affects the outer generator; values don&#39;t reach the sub-generator</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen2</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>  <span class="c1"># prints &quot;received: None&quot; (sub-generator receives None instead of &quot;hello&quot;)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;last&quot;</span>
</pre></div>
</div>
</section>
<section id="exception-handling-with-throw">
<h4><a class="toc-backref" href="#exception-handling-with-throw" role="doc-backlink">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sub_generator_with_exception_handling</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
        <span class="k">yield</span> <span class="s2">&quot;second&quot;</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;caught: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">sub_generator_with_exception_handling</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sub_generator_with_exception_handling</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">item</span>

<span class="c1"># With yield from, exceptions are passed to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen1</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)))</span>  <span class="c1"># prints &quot;caught: test&quot;</span>

<span class="c1"># With explicit loop, exceptions affect the outer generator only</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gen2</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)))</span>  <span class="c1"># ValueError is raised; sub-generator doesn&#39;t see it</span>
</pre></div>
</div>
</section>
<section id="generator-cleanup-with-close">
<h4><a class="toc-backref" href="#generator-cleanup-with-close" role="doc-backlink">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># hold references to sub-generators so GC doesn&#39;t close the explicit loop version</span>
<span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sub_generator_with_cleanup</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s2">&quot;first&quot;</span>
        <span class="k">yield</span> <span class="s2">&quot;second&quot;</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sub-generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">yield_from</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sub_generator_with_cleanup</span><span class="p">()</span>
        <span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">g</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;outer generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">explicit_loop</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sub_generator_with_cleanup</span><span class="p">()</span>
        <span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;outer generator received GeneratorExit&quot;</span><span class="p">)</span>

<span class="c1"># With yield from, GeneratorExit is passed through to sub-generator</span>
<span class="n">gen1</span> <span class="o">=</span> <span class="n">yield_from</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen1</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="n">gen1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># closes sub-generator and then outer generator</span>

<span class="c1"># With explicit loop, GeneratorExit goes to outer generator only</span>
<span class="n">gen2</span> <span class="o">=</span> <span class="n">explicit_loop</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen2</span><span class="p">))</span>  <span class="c1"># prints &quot;first&quot;</span>
<span class="n">gen2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># only closes outer generator</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;program finished; GC will close the explicit loop subgenerator&#39;</span><span class="p">)</span>
<span class="c1"># second inner generator closes when GC closes it at the end</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="pep798-guido" role="doc-footnote">
<dt class="label" id="pep798-guido">[<a href="#id2">1</a>]</dt>
<dd><a class="reference external" href="https://mail.python.org/archives/list/python-ideas&#64;python.org/message/CQPULNM6PM623PLXF5Z63BIUZGOSQEKW/">Message from Guido van Rossum</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0798.rst">https://github.com/python/peps/blob/main/peps/pep-0798.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0798.rst">2025-09-15 17:40:01 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#syntax">Syntax</a></li>
<li><a class="reference internal" href="#semantics-list-set-dict-comprehensions">Semantics: List/Set/Dict Comprehensions</a></li>
<li><a class="reference internal" href="#semantics-generator-expressions">Semantics: Generator Expressions</a><ul>
<li><a class="reference internal" href="#interaction-with-assignment-expressions">Interaction with Assignment Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#code-examples">Code Examples</a><ul>
<li><a class="reference internal" href="#replacing-explicit-loops">Replacing Explicit Loops</a></li>
<li><a class="reference internal" href="#replacing-from-iterable-and-friends">Replacing from_iterable and Friends</a></li>
<li><a class="reference internal" href="#replacing-double-loops-in-comprehensions">Replacing Double Loops in Comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternative-proposals">Rejected Alternative Proposals</a><ul>
<li><a class="reference internal" href="#starred-generators-as-function-arguments">Starred Generators as Function Arguments</a></li>
<li><a class="reference internal" href="#further-generalizing-unpacking-operators">Further Generalizing Unpacking Operators</a></li>
<li><a class="reference internal" href="#alternative-generator-expression-semantics">Alternative Generator Expression Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concerns-and-disadvantages">Concerns and Disadvantages</a></li>
<li><a class="reference internal" href="#appendix-other-languages">Appendix: Other Languages</a></li>
<li><a class="reference internal" href="#appendix-semantics-of-generator-delegation">Appendix: Semantics of Generator Delegation</a><ul>
<li><a class="reference internal" href="#basic-behavior">Basic Behavior</a></li>
<li><a class="reference internal" href="#advanced-generator-protocol-differences">Advanced Generator Protocol Differences</a><ul>
<li><a class="reference internal" href="#delegation-with-send">Delegation with <code class="docutils literal notranslate"><span class="pre">.send()</span></code></a></li>
<li><a class="reference internal" href="#exception-handling-with-throw">Exception Handling with <code class="docutils literal notranslate"><span class="pre">.throw()</span></code></a></li>
<li><a class="reference internal" href="#generator-cleanup-with-close">Generator Cleanup with <code class="docutils literal notranslate"><span class="pre">.close()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0798.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>