
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 691 – JSON-based Simple API for Python Package Indexes | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0691/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 691 – JSON-based Simple API for Python Package Indexes | peps.python.org'>
    <meta property="og:description" content="The “Simple Repository API” that was defined in PEP 503 (and was in use much longer than that) has served us reasonably well for a very long time. However, the reliance on using HTML as the data exchange mechanism has several shortcomings.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0691/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="The “Simple Repository API” that was defined in PEP 503 (and was in use much longer than that) has served us reasonably well for a very long time. However, the reliance on using HTML as the data exchange mechanism has several shortcomings.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 691</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 691 – JSON-based Simple API for Python Package Indexes" data-pagefind-weight="10" class="visually-hidden">PEP 691 – JSON-based Simple API for Python Package Indexes</span>
            <section id="pep-content">
<h1 class="page-title">PEP 691 – JSON-based Simple API for Python Package Indexes</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;,
Pradyun Gedam &lt;pradyunsg&#32;&#97;t&#32;gmail.com&gt;,
Cooper Lees &lt;me&#32;&#97;t&#32;cooperlees.com&gt;,
Dustin Ingram &lt;di&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-even">PEP-Delegate<span class="colon">:</span></dt>
<dd class="field-even">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-691-json-based-simple-api-for-python-package-indexes/15553">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative proposal accepted for implementation">Accepted</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Topic<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">04-May-2022</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/pep-691-json-based-simple-api-for-python-package-indexes/15553" title="Discourse thread">05-May-2022</a></dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-691-json-based-simple-api-for-python-package-indexes/15553/70">Discourse message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#goals">Goals</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#versioning">Versioning</a></li>
<li><a class="reference internal" href="#json-serialization">JSON Serialization</a><ul>
<li><a class="reference internal" href="#project-list">Project List</a></li>
<li><a class="reference internal" href="#project-detail">Project Detail</a></li>
</ul>
</li>
<li><a class="reference internal" href="#content-types">Content-Types</a></li>
<li><a class="reference internal" href="#version-format-selection">Version + Format Selection</a><ul>
<li><a class="reference internal" href="#alternative-negotiation-mechanisms">Alternative Negotiation Mechanisms</a><ul>
<li><a class="reference internal" href="#url-parameter">URL Parameter</a></li>
<li><a class="reference internal" href="#endpoint-configuration">Endpoint Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tuf-support-pep-458">TUF Support - PEP 458</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#does-this-mean-pypi-is-planning-to-drop-support-for-html-pep-503">Does this mean PyPI is planning to drop support for HTML/PEP 503?</a></li>
<li><a class="reference internal" href="#why-json-instead-of-x-format">Why JSON instead of X format?</a></li>
<li><a class="reference internal" href="#why-not-add-x-feature">Why not add X feature?</a></li>
<li><a class="reference internal" href="#why-include-the-filename-when-the-url-has-it-already">Why include the filename when the URL has it already?</a></li>
<li><a class="reference internal" href="#why-not-break-out-other-pieces-of-information-from-the-filename">Why not break out other pieces of information from the filename?</a></li>
<li><a class="reference internal" href="#why-content-negotiation-instead-of-multiple-urls">Why Content Negotiation instead of multiple URLs?</a></li>
<li><a class="reference internal" href="#does-this-mean-that-static-servers-are-no-longer-supported">Does this mean that static servers are no longer supported?</a></li>
<li><a class="reference internal" href="#why-not-add-an-application-json-alias-like-text-html">Why not add an <code class="docutils literal notranslate"><span class="pre">application/json</span></code> alias like <code class="docutils literal notranslate"><span class="pre">text/html</span></code>?</a></li>
<li><a class="reference internal" href="#why-add-a-application-vnd-pypi-simple-v1-html">Why add a <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code>?</a></li>
<li><a class="reference internal" href="#why-v1-0-and-not-v1-1-or-v2-0">Why v1.0 and not v1.1 or v2.0?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-1-survey-of-use-cases-to-cover">Appendix 1: Survey of use cases to cover</a></li>
<li><a class="reference internal" href="#appendix-2-rough-underlying-data-models">Appendix 2: Rough Underlying Data Models</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<div class="pep-banner canonical-pypa-spec sticky-banner admonition important">
<p class="admonition-title">Important</p>
<p>This PEP is a historical document. The up-to-date, canonical spec, <a class="reference external" href="https://packaging.python.org/en/latest/specifications/simple-repository-api/#simple-repository-api" title="(in Python Packaging User Guide)"><span>Simple repository API</span></a>, is maintained on the <a class="reference external" href="https://packaging.python.org/en/latest/specifications/">PyPA specs page</a>.</p>
<p class="close-button">×</p>
<p>See the <a class="reference external" href="https://www.pypa.io/en/latest/specifications/#handling-fixes-and-other-minor-updates">PyPA specification update process</a> for how to propose changes.</p>
</div>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>The “Simple Repository API” that was defined in <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> (and was in use much
longer than that) has served us reasonably well for a very long time. However,
the reliance on using HTML as the data exchange mechanism has several
shortcomings.</p>
<p>There are two major issues with an HTML-based API:</p>
<ul>
<li>While HTML5 is a standard, it’s an incredibly complex standard and ensuring
completely correct parsing of it involves complex logic that does not
currently exist within the Python standard library (nor the standard library
of many other languages).<p>This means that to actually accept everything that is technically valid, tools
have to pull in large dependencies or they have to rely on the standard library’s
<code class="docutils literal notranslate"><span class="pre">html.parser</span></code> library, which is lighter weight but potentially doesn’t
fully support HTML5.</p>
</li>
<li>HTML5 is primarily designed as a markup language to present documents for human
consumption. Our use of it is driven largely for historical and accidental
reasons, and it’s unlikely anyone would design an API that relied on it if
they were starting from scratch.<p>The primary issue with using a markup format designed for human consumption
is that there’s not a great way to actually encode data within HTML. We’ve
gotten around this by limiting the data we put in this API and being creative
with how we can cram data into the API (for instance, hashes are embedded as
URL fragments, adding the <code class="docutils literal notranslate"><span class="pre">data-yanked</span></code> attribute in <a class="pep reference internal" href="../pep-0592/" title="PEP 592 – Adding “Yank” Support to the Simple API">PEP 592</a>).</p>
</li>
</ul>
<p><a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> was largely an attempt to standardize what was already in use, so it
did not propose any large changes to the API.</p>
<p>In the intervening years, we’ve regularly talked about an “API V2” that would
re-envision the entire API of PyPI. However, due to limited time constraints,
that effort has not gained much, if any, traction beyond people thinking that
it would be nice to do.</p>
<p>This PEP attempts to take a different route. It doesn’t fundamentally change
the overall API structure, but instead specifies a new serialization of the
existing data contained in existing <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> responses in a format that is
easier for software to parse rather than using a human centric document format.</p>
</section>
<section id="goals">
<h2><a class="toc-backref" href="#goals" role="doc-backlink">Goals</a></h2>
<ul class="simple">
<li><strong>Enable zero configuration discovery.</strong> Clients of the simple API <strong>MUST</strong> be
able to gracefully determine whether a target repository supports this PEP
without relying on any form of out of band communication (configuration, prior
knowledge, etc). Individual clients <strong>MAY</strong> choose to require configuration
to enable the use of this API, however.</li>
<li><strong>Enable clients to drop support for “legacy” HTML parsing.</strong> While it is expected
that most clients will keep supporting HTML-only repositories for a while, if not
forever, it should be possible for a client to choose to support only the new
API formats and no longer invoke an HTML parser.</li>
<li><strong>Enable repositories to drop support for “legacy” HTML formats.</strong> Similar to
clients, it is expected that most repositories will continue to support HTML
responses for a long time, or forever. It should be possible for a repository to
choose to only support the new formats.</li>
<li><strong>Maintain full support for existing HTML-only clients.</strong> We <strong>MUST</strong> not break
existing clients that are accessing the API as a strictly <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> API. The only
exception to this, is if the repository itself has chosen to no longer support
the HTML format.</li>
<li><strong>Minimal additional HTTP requests.</strong> Using this API <strong>MUST</strong> not drastically
increase the amount of HTTP requests an installer must do in order to function.
Ideally it will require 0 additional requests, but if needed it may require one
or two additional requests (total, not per dependency).</li>
<li><strong>Minimal additional unique responses.</strong> Due to the nature of how large
repositories like PyPI cache responses, this PEP should not introduce a
significantly or combinatorially large number of additional unique responses
that the repository may produce.</li>
<li><strong>Supports TUF.</strong> This PEP <strong>MUST</strong> be able to function within the bounds of
what TUF can support (<a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a>), and must be able to be secured using it.</li>
<li><strong>Require only the standard library, or small external dependencies for clients.</strong>
Parsing an API response should ideally require nothing but the standard
library, however it would be acceptable to require a small, pure Python
dependency.</li>
</ul>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>To enable response parsing with only the standard library, this PEP specifies that
all responses (besides the files themselves, and the HTML responses from
<a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a>) should be serialized using <a class="reference external" href="https://www.json.org/">JSON</a>.</p>
<p>To enable zero configuration discovery and to minimize the amount of additional HTTP
requests, this PEP extends <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> such that all of the API endpoints (other than the
files themselves) will utilize HTTP content negotiation to allow client and server to
select the correct serialization format to serve, i.e. either HTML or JSON.</p>
<section id="versioning">
<h3><a class="toc-backref" href="#versioning" role="doc-backlink">Versioning</a></h3>
<p>Versioning will adhere to <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a> format (<code class="docutils literal notranslate"><span class="pre">Major.Minor</span></code>), which has defined the
existing HTML responses to be <code class="docutils literal notranslate"><span class="pre">1.0</span></code>. Since this PEP does not introduce new features
into the API, rather it describes a different serialization format for the existing
features, this PEP does not change the existing <code class="docutils literal notranslate"><span class="pre">1.0</span></code> version, and instead just
describes how to serialize that into JSON.</p>
<p>Similar to <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a>, the major version number <strong>MUST</strong> be incremented if any
changes to the new format would result in no longer being able to expect existing
clients to meaningfully understand the format.</p>
<p>Likewise, the minor version <strong>MUST</strong> be incremented if features are
added or removed from the format, but existing clients would be expected to continue
to meaningfully understand the format.</p>
<p>Changes that would not result in existing clients being unable to meaningfully
understand the format and which do not represent features being added or removed
may occur without changing the version number.</p>
<p>This is intentionally vague, as this PEP believes it is best left up to future PEPs
that make any changes to the API to investigate and decide whether or not that
change should increment the major or minor version.</p>
<p>Future versions of the API may add things that can only be represented in a subset
of the available serializations of that version. All serializations version numbers,
within a major version, <strong>SHOULD</strong> be kept in sync, but the specifics of how a
feature serializes into each format may differ, including whether or not that feature
is present at all.</p>
<p>It is the intent of this PEP that the API should be thought of as URL endpoints that
return data, whose interpretation is defined by the version of that data, and then
serialized into the target serialization format.</p>
</section>
<section id="json-serialization">
<span id="id1"></span><h3><a class="toc-backref" href="#json-serialization" role="doc-backlink">JSON Serialization</a></h3>
<p>The URL structure from <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> still applies, as this PEP only adds an additional
serialization format for the already existing API.</p>
<p>The following constraints apply to all JSON serialized responses described in this
PEP:</p>
<ul class="simple">
<li>All JSON responses will <em>always</em> be a JSON object rather than an array or other
type.</li>
<li>While JSON doesn’t natively support an URL type, any value that represents an
URL in this API may be either absolute or relative as long as they point to
the correct location. If relative, they are relative to the current URL as if
it were HTML.</li>
<li>Additional keys may be added to any dictionary objects in the API responses
and clients <strong>MUST</strong> ignore keys that they don’t understand.</li>
<li>All JSON responses will have a <code class="docutils literal notranslate"><span class="pre">meta</span></code> key, which contains information related to
the response itself, rather than the content of the response.</li>
<li>All JSON responses will have a <code class="docutils literal notranslate"><span class="pre">meta.api-version</span></code> key, which will be a string that
contains the <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a> <code class="docutils literal notranslate"><span class="pre">Major.Minor</span></code> version number, with the same fail/warn
semantics as defined in <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a>.</li>
<li>All requirements of <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> that are not HTML specific still apply.</li>
</ul>
<section id="project-list">
<h4><a class="toc-backref" href="#project-list" role="doc-backlink">Project List</a></h4>
<p>The root URL <code class="docutils literal notranslate"><span class="pre">/</span></code> for this PEP (which represents the base URL) will be a JSON encoded
dictionary which has a two keys:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">projects</span></code>: An array where each entry is a dictionary with a single key, <code class="docutils literal notranslate"><span class="pre">name</span></code>, which represents string of the project name.</li>
<li><code class="docutils literal notranslate"><span class="pre">meta</span></code>: The general response metadata as <a class="reference internal" href="#json-serialization">described earlier</a>.</li>
</ul>
<p>As an example:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;projects&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Frob&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;spamspamspam&quot;</span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is the same as the one from <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a>, which does not specify
whether it is the non-normalized display name or the normalized name. In practice
different implementations of these PEPs are choosing differently here, so relying
on it being either non-normalized or normalized is relying on an implementation
detail of the repository in question.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the <code class="docutils literal notranslate"><span class="pre">projects</span></code> key is an array, and thus is required to be in some kind
of an order, neither <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> nor this PEP requires any specific ordering nor
that the ordering is consistent from one request to the next. Mentally this is
best thought of as a set, but both JSON and HTML lack the functionality to have
sets.</p>
</div>
</section>
<section id="project-detail">
<h4><a class="toc-backref" href="#project-detail" role="doc-backlink">Project Detail</a></h4>
<p>The format of this URL is <code class="docutils literal notranslate"><span class="pre">/&lt;project&gt;/</span></code> where the <code class="docutils literal notranslate"><span class="pre">&lt;project&gt;</span></code> is replaced by the
<a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> normalized name for that project, so a project named “Silly_Walk” would
have a URL like <code class="docutils literal notranslate"><span class="pre">/silly-walk/</span></code>.</p>
<p>This URL must respond with a JSON encoded dictionary that has three keys:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: The normalized name of the project.</li>
<li><code class="docutils literal notranslate"><span class="pre">files</span></code>: A list of dictionaries, each one representing an individual file.</li>
<li><code class="docutils literal notranslate"><span class="pre">meta</span></code>: The general response metadata as <a class="reference internal" href="#json-serialization">described earlier</a>.</li>
</ul>
<p>Each individual file dictionary has the following keys:</p>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: The filename that is being represented.</li>
<li><code class="docutils literal notranslate"><span class="pre">url</span></code>: The URL that the file can be fetched from.</li>
<li><code class="docutils literal notranslate"><span class="pre">hashes</span></code>: A dictionary mapping a hash name to a hex encoded digest of the file.
Multiple hashes can be included, and it is up to the client to decide what to do
with multiple hashes (it may validate all of them or a subset of them, or nothing
at all). These hash names <strong>SHOULD</strong> always be normalized to be lowercase.<p>The <code class="docutils literal notranslate"><span class="pre">hashes</span></code> dictionary <strong>MUST</strong> be present, even if no hashes are available
for the file, however it is <strong>HIGHLY</strong> recommended that at least one secure,
guaranteed-to-be-available hash is always included.</p>
<p>By default, any hash algorithm available via <a class="reference external" href="https://docs.python.org/3/library/hashlib.html">hashlib</a> (specifically any that can
be passed to <code class="docutils literal notranslate"><span class="pre">hashlib.new()</span></code> and do not require additional parameters) can
be used as a key for the hashes dictionary. At least one secure algorithm from
<code class="docutils literal notranslate"><span class="pre">hashlib.algorithms_guaranteed</span></code> <strong>SHOULD</strong> always be included. At the time
of this PEP, <code class="docutils literal notranslate"><span class="pre">sha256</span></code> specifically is recommended.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">requires-python</span></code>: An <strong>optional</strong> key that exposes the <em>Requires-Python</em>
metadata field, specified in <a class="pep reference internal" href="../pep-0345/" title="PEP 345 – Metadata for Python Software Packages 1.2">PEP 345</a>. Where this is present, installer tools
<strong>SHOULD</strong> ignore the download when installing to a Python version that
doesn’t satisfy the requirement.<p>Unlike <code class="docutils literal notranslate"><span class="pre">data-requires-python</span></code> in <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a>, the <code class="docutils literal notranslate"><span class="pre">requires-python</span></code> key does not
require any special escaping other than anything JSON does naturally.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">dist-info-metadata</span></code>: An <strong>optional</strong> key that indicates
that metadata for this file is available, via the same location as specified in
<a class="pep reference internal" href="../pep-0658/" title="PEP 658 – Serve Distribution Metadata in the Simple Repository API">PEP 658</a> (<code class="docutils literal notranslate"><span class="pre">{file_url}.metadata</span></code>). Where this is present, it <strong>MUST</strong> be
either a boolean to indicate if the file has an associated metadata file, or a
dictionary mapping hash names to a hex encoded digest of the metadata’s hash.<p>When this is a dictionary of hashes instead of a boolean, then all the same
requirements and recommendations as the <code class="docutils literal notranslate"><span class="pre">hashes</span></code> key hold true for this key as
well.</p>
<p>If this key is missing then the metadata file may or may not exist. If the key
value is truthy, then the metadata file is present, and if it is falsey then it
is not.</p>
<p>It is recommended that servers make the hashes of the metadata file available if
possible.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">gpg-sig</span></code>: An <strong>optional</strong> key that acts a boolean to indicate if the file has
an associated GPG signature or not. The URL for the signature file follows what
is specified in <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> (<code class="docutils literal notranslate"><span class="pre">{file_url}.asc</span></code>). If this key does not exist, then
the signature may or may not exist.</li>
<li><code class="docutils literal notranslate"><span class="pre">yanked</span></code>: An <strong>optional</strong> key which may be either a boolean to indicate if the
file has been yanked, or a non empty, but otherwise arbitrary, string to indicate
that a file has been yanked with a specific reason. If the <code class="docutils literal notranslate"><span class="pre">yanked</span></code> key is present
and is a truthy value, then it <strong>SHOULD</strong> be interpreted as indicating that the
file pointed to by the <code class="docutils literal notranslate"><span class="pre">url</span></code> field has been “Yanked” as per <a class="pep reference internal" href="../pep-0592/" title="PEP 592 – Adding “Yank” Support to the Simple API">PEP 592</a>.</li>
</ul>
<p>As an example:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;holygrail&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;files&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;filename&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;holygrail-1.0.tar.gz&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;url&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://example.com/files/holygrail-1.0.tar.gz&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;hashes&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;sha256&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;blake2b&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;requires-python&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&gt;=3.7&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;yanked&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Had a vulnerability&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;filename&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;holygrail-1.0-py3-none-any.whl&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;url&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://example.com/files/holygrail-1.0-py3-none-any.whl&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;hashes&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;sha256&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;blake2b&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;requires-python&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&gt;=3.7&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;dist-info-metadata&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the <code class="docutils literal notranslate"><span class="pre">files</span></code> key is an array, and thus is required to be in some kind
of an order, neither <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> nor this PEP requires any specific ordering nor
that the ordering is consistent from one request to the next. Mentally this is
best thought of as a set, but both JSON and HTML lack the functionality to have
sets.</p>
</div>
</section>
</section>
<section id="content-types">
<h3><a class="toc-backref" href="#content-types" role="doc-backlink">Content-Types</a></h3>
<p>This PEP proposes that all responses from the Simple API will have a standard
content type that describes what the response is (a Simple API response), what
version of the API it represents, and what serialization format has been used.</p>
<p>The structure of this content type will be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>application/vnd.pypi.simple.$version+format
</pre></div>
</div>
<p>Since only major versions should be disruptive to clients attempting to
understand one of these API responses, only the major version will be included
in the content type, and will be prefixed with a <code class="docutils literal notranslate"><span class="pre">v</span></code> to clarify that it is a
version number.</p>
<p>Which means that for the existing 1.0 API, the content types would be:</p>
<ul class="simple">
<li><strong>JSON:</strong> <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+json</span></code></li>
<li><strong>HTML:</strong> <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code></li>
</ul>
<p>In addition to the above, a special “meta” version is supported named <code class="docutils literal notranslate"><span class="pre">latest</span></code>,
whose purpose is to allow clients to request the absolute latest version, without
having to know ahead of time what that version is. It is recommended however,
that clients be explicit about what versions they support.</p>
<p>To support existing clients which expect the existing <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> API responses to
use the <code class="docutils literal notranslate"><span class="pre">text/html</span></code> content type, this PEP further defines <code class="docutils literal notranslate"><span class="pre">text/html</span></code> as an alias
for the <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code> content type.</p>
</section>
<section id="version-format-selection">
<h3><a class="toc-backref" href="#version-format-selection" role="doc-backlink">Version + Format Selection</a></h3>
<p>Now that there is multiple possible serializations, we need a mechanism to allow
clients to indicate what serialization formats they’re able to understand. In
addition, it would be beneficial if any possible new major version to the API can
be added without disrupting existing clients expecting the previous API version.</p>
<p>To enable this, this PEP standardizes on the use of HTTP’s
<a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">Server-Driven Content Negotiation</a>.</p>
<p>While this PEP won’t fully describe the entirety of server-driven content
negotiation, the flow is roughly:</p>
<ol class="arabic simple">
<li>The client makes an HTTP request containing an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header listing all
of the version+format content types that they are able to understand.</li>
<li>The server inspects that header, selects one of the listed content types,
then returns a response using that content type (treating the absence of
an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header as <code class="docutils literal notranslate"><span class="pre">Accept:</span> <span class="pre">*/*</span></code>).</li>
<li>If the server does not support any of the content types in the <code class="docutils literal notranslate"><span class="pre">Accept</span></code>
header then they are able to choose between 3 different options for how to
respond:<ol class="loweralpha simple">
<li>Select a default content type other than what the client has requested
and return a response with that.</li>
<li>Return a HTTP <code class="docutils literal notranslate"><span class="pre">406</span> <span class="pre">Not</span> <span class="pre">Acceptable</span></code> response to indicate that none of
the requested content types were available, and the server was unable
or unwilling to select a default content type to respond with.</li>
<li>Return a HTTP <code class="docutils literal notranslate"><span class="pre">300</span> <span class="pre">Multiple</span> <span class="pre">Choices</span></code> response that contains a list of
all of the possible responses that could have been chosen.</li>
</ol>
</li>
<li>The client interprets the response, handling the different types of responses
that the server may have responded with.</li>
</ol>
<p>This PEP does not specify which choices the server makes in regards to handling
a content type that it isn’t able to return, and clients <strong>SHOULD</strong> be prepared
to handle all of the possible responses in whatever way makes the most sense for
that client.</p>
<p>However, as there is no standard format for how a <code class="docutils literal notranslate"><span class="pre">300</span> <span class="pre">Multiple</span> <span class="pre">Choices</span></code>
response can be interpreted, this PEP highly discourages servers from utilizing
that option, as clients will have no way to understand and select a different
content-type to request. In addition, it’s unlikely that the client <em>could</em>
understand a different content type anyways, so at best this response would
likely just be treated the same as a <code class="docutils literal notranslate"><span class="pre">406</span> <span class="pre">Not</span> <span class="pre">Acceptable</span></code> error.</p>
<p>This PEP <strong>does</strong> require that if the meta version <code class="docutils literal notranslate"><span class="pre">latest</span></code> is being used, the
server <strong>MUST</strong> respond with the content type for the actual version that is
contained in the response
(i.e. A <code class="docutils literal notranslate"><span class="pre">Accept:</span> <span class="pre">application/vnd.pypi.simple.latest+json</span></code> request that returns
a <code class="docutils literal notranslate"><span class="pre">v1.x</span></code> response should have a <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> of
<code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+json</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header is a comma separated list of content types that the client
understands and is able to process. It supports three different formats for each
content type that is being requested:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">$type/$subtype</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">$type/*</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">*/*</span></code></li>
</ul>
<p>For the use of selecting a version+format, the most useful of these is
<code class="docutils literal notranslate"><span class="pre">$type/$subtype</span></code>, as that is the only way to actually specify the version
and format you want.</p>
<p>The order of the content types listed in the <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header does not have any
specific meaning, and the server <strong>SHOULD</strong> consider all of them to be equally
valid to respond with. If a client wishes to specify that they prefer a specific
content type over another, they may use the <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header’s
<a class="reference external" href="https://developer.mozilla.org/en-US/docs/Glossary/Quality_values">quality value</a>
syntax.</p>
<p>This allows a client to specify a priority for a specific entry in their
<code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, by appending a <code class="docutils literal notranslate"><span class="pre">;q=</span></code> followed by a value between <code class="docutils literal notranslate"><span class="pre">0</span></code> and
<code class="docutils literal notranslate"><span class="pre">1</span></code> inclusive, with up to 3 decimal digits. When interpreting this value,
an entry with a higher quality has priority over an entry with a lower quality,
and any entry without a quality present will default to a quality of <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>However, clients should keep in mind that a server is free to select <strong>any</strong> of
the content types they’ve asked for, regardless of their requested priority, and
it may even return a content type that they did <strong>not</strong> ask for.</p>
<p>To aid clients in determining the content type of the response that they have
received from an API request, this PEP requires that servers always include a
<code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> header indicating the content type of the response. This is
technically a backwards incompatible change, however in practice
<a class="reference external" href="https://github.com/pypa/pip/blob/cf3696a81b341925f82f20cb527e656176987565/src/pip/_internal/index/collector.py#L123-L150">pip has been enforcing this requirement</a>
so the risks for actual breakages is low.</p>
<p>An example of how a client can operate would look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">email.message</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>

<span class="k">def</span><span class="w"> </span><span class="nf">parse_content_type</span><span class="p">(</span><span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">Message</span><span class="p">()</span>
    <span class="n">m</span><span class="p">[</span><span class="s2">&quot;content-type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">header</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">()</span>

<span class="c1"># Construct our list of acceptable content types, we want to prefer</span>
<span class="c1"># that we get a v1 response serialized using JSON, however we also</span>
<span class="c1"># can support a v1 response serialized using HTML. For compatibility</span>
<span class="c1"># we also request text/html, but we prefer it least of all since we</span>
<span class="c1"># don&#39;t know if it&#39;s actually a Simple API response, or just some</span>
<span class="c1"># random HTML page that we&#39;ve gotten due to a misconfiguration.</span>
<span class="n">CONTENT_TYPES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;application/vnd.pypi.simple.v1+json&quot;</span><span class="p">,</span>
    <span class="s2">&quot;application/vnd.pypi.simple.v1+html;q=0.2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;text/html;q=0.01&quot;</span><span class="p">,</span>  <span class="c1"># For legacy compatibility</span>
<span class="p">]</span>
<span class="n">ACCEPT</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CONTENT_TYPES</span><span class="p">)</span>


<span class="c1"># Actually make our request to the API, requesting all of the content</span>
<span class="c1"># types that we find acceptable, and letting the server select one of</span>
<span class="c1"># them out of the list.</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://pypi.org/simple/&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Accept&quot;</span><span class="p">:</span> <span class="n">ACCEPT</span><span class="p">})</span>

<span class="c1"># If the server does not support any of the content types you requested,</span>
<span class="c1"># AND it has chosen to return a HTTP 406 error instead of a default</span>
<span class="c1"># response then this will raise an exception for the 406 error.</span>
<span class="n">resp</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>


<span class="c1"># Determine what kind of response we&#39;ve gotten to ensure that it is one</span>
<span class="c1"># that we can support, and if it is, dispatch to a function that will</span>
<span class="c1"># understand how to interpret that particular version+serialization. If</span>
<span class="c1"># we don&#39;t understand the content type we&#39;ve gotten, then we&#39;ll raise</span>
<span class="c1"># an exception.</span>
<span class="n">content_type</span> <span class="o">=</span> <span class="n">parse_content_type</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;content-type&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
<span class="k">match</span> <span class="n">content_type</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;application/vnd.pypi.simple.v1+json&quot;</span><span class="p">:</span>
        <span class="n">handle_v1_json</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;application/vnd.pypi.simple.v1+html&quot;</span> <span class="o">|</span> <span class="s2">&quot;text/html&quot;</span><span class="p">:</span>
        <span class="n">handle_v1_html</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown content type: </span><span class="si">{</span><span class="n">content_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If a client wishes to only support HTML or only support JSON, then they would
just remove the content types that they do not want from the <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header,
and turn receiving them into an error.</p>
<section id="alternative-negotiation-mechanisms">
<h4><a class="toc-backref" href="#alternative-negotiation-mechanisms" role="doc-backlink">Alternative Negotiation Mechanisms</a></h4>
<p>While using HTTP’s Content negotiation is considered the standard way for a client
and server to coordinate to ensure that the client is getting an HTTP response that
it is able to understand, there are situations where that mechanism may not be
sufficient. For those cases this PEP has alternative negotiation mechanisms that
may <em>optionally</em> be used instead.</p>
<section id="url-parameter">
<h5><a class="toc-backref" href="#url-parameter" role="doc-backlink">URL Parameter</a></h5>
<p>Servers that implement the Simple API may choose to support an URL parameter named
<code class="docutils literal notranslate"><span class="pre">format</span></code> to allow the clients to request a specific version of the URL.</p>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">format</span></code> parameter should be <strong>one</strong> of the valid content types.
Passing multiple content types, wild cards, quality values, etc… is <strong>not</strong>
supported.</p>
<p>Supporting this parameter is optional, and clients <strong>SHOULD NOT</strong> rely on it for
interacting with the API. This negotiation mechanism is intended to allow for easier
human based exploration of the API within a browser, or to allow documentation or
notes to link to a specific version+format.</p>
<p>Servers that do not support this parameter may choose to return an error when it is
present, or they may simple ignore its presence.</p>
<p>When a server does implement this parameter, it <strong>SHOULD</strong> take precedence over any
values in the client’s <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, and if the server does not support the
requested format, it may choose to fall back to the <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, or choose any
of the error conditions that standard server-driven content negotiation typically
has (e.g. <code class="docutils literal notranslate"><span class="pre">406</span> <span class="pre">Not</span> <span class="pre">Available</span></code>, <code class="docutils literal notranslate"><span class="pre">303</span> <span class="pre">Multiple</span> <span class="pre">Choices</span></code>, or selecting a default
type to return).</p>
</section>
<section id="endpoint-configuration">
<h5><a class="toc-backref" href="#endpoint-configuration" role="doc-backlink">Endpoint Configuration</a></h5>
<p>This option technically is not a special option at all, it is just a natural
consequence of using content negotiation and allowing servers to select which of the
available content types is their default.</p>
<p>If a server is unwilling or unable to implement the server-driven content negotiation,
and would instead rather require users to explicitly configure their client to select
the version they want, then that is a supported configuration.</p>
<p>To enable this, a server should make multiple endpoints (for instance,
<code class="docutils literal notranslate"><span class="pre">/simple/v1+html/</span></code> and/or <code class="docutils literal notranslate"><span class="pre">/simple/v1+json/</span></code>) for each version+format that they
wish to support. Under that endpoint, they can host a copy of their repository that
only supports one (or a subset) of the content-types. When a client makes a request
using the <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, the server can ignore it and return the content type
that corresponds to that endpoint.</p>
<p>For clients that wish to require specific configuration, they can keep track of
which version+format a specific repository URL was configured for, and when making
a request to that server, emit an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header that <em>only</em> includes the correct
content type.</p>
</section>
</section>
</section>
<section id="tuf-support-pep-458">
<h3><a class="toc-backref" href="#tuf-support-pep-458" role="doc-backlink">TUF Support - PEP 458</a></h3>
<p><a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a> requires that all API responses are hashable and that they can be uniquely
identified by a path relative to the repository root. For a Simple API repository, the
target path is the Root of our API (e.g. <code class="docutils literal notranslate"><span class="pre">/simple/</span></code> on PyPI). This creates
challenges when accessing the API using a TUF client instead of directly using a
standard HTTP client, as the TUF client cannot handle the fact that a target could
have multiple different representations that all hash differently.</p>
<p><a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a> does not specify what the target path should be for the Simple API, but
TUF requires that the target paths be “file-like”, in other words, a path like
<code class="docutils literal notranslate"><span class="pre">simple/PROJECT/</span></code> is not acceptable, because it technically points to a
directory.</p>
<p>The saving grace is that the target path does not <em>have</em> to actually match the URL
being fetched from the Simple API, and it can just be a sigil that the fetching code
knows how to transform into the actual URL that needs to be fetched. This same thing
can hold true for other aspects of the actual HTTP request, such as the <code class="docutils literal notranslate"><span class="pre">Accept</span></code>
header.</p>
<p>Ultimately figuring out how to map a directory to a filename is out of scope for this
PEP (but it would be in scope for <a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a>), and this PEP defers making a decision
about how exactly to represent this inside of <a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a> metadata.</p>
<p>However, it appears that the current WIP branch against pip that attempts to implement
<a class="pep reference internal" href="../pep-0458/" title="PEP 458 – Secure PyPI downloads with signed repository metadata">PEP 458</a> is using a target path like <code class="docutils literal notranslate"><span class="pre">simple/PROJECT/index.html</span></code>. This could be
modified to include the API version and serialization format using something like
<code class="docutils literal notranslate"><span class="pre">simple/PROJECT/vnd.pypi.simple.vN.FORMAT</span></code>. So the v1 HTML format would be
<code class="docutils literal notranslate"><span class="pre">simple/PROJECT/vnd.pypi.simple.v1.html</span></code> and the v1 JSON format would be
<code class="docutils literal notranslate"><span class="pre">simple/PROJECT/vnd.pypi.simple.v1.json</span></code>.</p>
<p>In this case, since <code class="docutils literal notranslate"><span class="pre">text/html</span></code> is an alias to <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code>
when interacting through TUF, it likely will make the most sense to normalize to the
more explicit name.</p>
<p>Likewise the <code class="docutils literal notranslate"><span class="pre">latest</span></code> metaversion should not be included in the targets, only
explicitly declared versions should be supported.</p>
</section>
</section>
<section id="recommendations">
<h2><a class="toc-backref" href="#recommendations" role="doc-backlink">Recommendations</a></h2>
<p>This section is non-normative, and represents what the PEP authors believe to be
the best default implementation decisions for something implementing this PEP, but
it does <strong>not</strong> represent any sort of requirement to match these decisions.</p>
<p>These decisions have been chosen to maximize the number of requests that can be
moved onto the newest version of an API, while maintaining the greatest amount
of compatibility. In addition, they’ve also tried to make using the API provide
guardrails that attempt to push clients into making the best choices it can.</p>
<p>It is recommended that servers:</p>
<ul class="simple">
<li>Support all 3 content types described in this PEP, using server-driven
content negotiation, for as long as they reasonably can, or at least as
long as they’re receiving non trivial traffic that uses the HTML responses.</li>
<li>When encountering an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header that does not contain any content types
that it knows how to work with, the server should not ever return a
<code class="docutils literal notranslate"><span class="pre">300</span> <span class="pre">Multiple</span> <span class="pre">Choice</span></code> response, and instead return a <code class="docutils literal notranslate"><span class="pre">406</span> <span class="pre">Not</span> <span class="pre">Acceptable</span></code>
response.<ul>
<li>However, if choosing to use the endpoint configuration, you should prefer to
return a <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> response in the expected content type for that endpoint.</li>
</ul>
</li>
<li>When selecting an acceptable version, the server should choose the highest version
that the client supports, with the most expressive/featureful serialization format,
taking into account the specificity of the client requests as well as any
quality priority values they have expressed, and it should only use the
<code class="docutils literal notranslate"><span class="pre">text/html</span></code> content type as a last resort.</li>
</ul>
<p>It is recommended that clients:</p>
<ul>
<li>Support all 3 content types described in this PEP, using server-driven
content negotiation, for as long as they reasonably can.</li>
<li>When constructing an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, include all of the content types
that you support.<p>You should generally <em>not</em> include a quality priority value for your content
types, unless you have implementation specific reasons that you want the
server to take into account (for example, if you’re using the standard library
HTML parser and you’re worried that there may be some kinds of HTML responses
that you’re unable to parse in some edge cases).</p>
<p>The one exception to this recommendation is that it is recommended that you
<em>should</em> include a <code class="docutils literal notranslate"><span class="pre">;q=0.01</span></code> value on the legacy <code class="docutils literal notranslate"><span class="pre">text/html</span></code> content type,
unless it is the only content type that you are requesting.</p>
</li>
<li>Explicitly select what versions they are looking for, rather than using the
<code class="docutils literal notranslate"><span class="pre">latest</span></code> meta version during normal operation.</li>
<li>Check the <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> of the response and ensure it matches something
that you were expecting.</li>
</ul>
</section>
<section id="faq">
<h2><a class="toc-backref" href="#faq" role="doc-backlink">FAQ</a></h2>
<section id="does-this-mean-pypi-is-planning-to-drop-support-for-html-pep-503">
<h3><a class="toc-backref" href="#does-this-mean-pypi-is-planning-to-drop-support-for-html-pep-503" role="doc-backlink">Does this mean PyPI is planning to drop support for HTML/PEP 503?</a></h3>
<p>No, PyPI has no plans at this time to drop support for <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> or HTML
responses.</p>
<p>While this PEP does give repositories the flexibility to do that, that largely
exists to ensure that things like using the Endpoint Configuration mechanism is
able to work, and to ensure that clients do not make any assumptions that would
prevent, at some point in the future, gracefully dropping support for HTML.</p>
<p>The existing HTML responses incur almost no maintenance burden on PyPI and
there is no pressing need to remove them. The only real benefit to dropping them
would be to reduce the number of items cached in our CDN.</p>
<p>If in the future PyPI <em>does</em> wish to drop support for them, doing so would
almost certainly be the topic of a PEP, or at a minimum a public, open, discussion
and would be informed by metrics showing any impact to end users.</p>
</section>
<section id="why-json-instead-of-x-format">
<h3><a class="toc-backref" href="#why-json-instead-of-x-format" role="doc-backlink">Why JSON instead of X format?</a></h3>
<p>JSON parsers are widely available in most, if not every, language. A JSON
parser is also available in the Python standard library. It’s not the perfect
format, but it’s good enough.</p>
</section>
<section id="why-not-add-x-feature">
<h3><a class="toc-backref" href="#why-not-add-x-feature" role="doc-backlink">Why not add X feature?</a></h3>
<p>The general goal of this PEP is to change or add very little. We will instead focus
largely on translating the existing information contained within our HTML responses
into a sensible JSON representation. This will include <a class="pep reference internal" href="../pep-0658/" title="PEP 658 – Serve Distribution Metadata in the Simple Repository API">PEP 658</a> metadata required
for packaging tooling.</p>
<p>The only real new capability that is added in this PEP is the ability to have
multiple hashes for a single file. That was done because the current mechanism being
limited to a single hash has made it painful in the past to migrate hashes
(md5 to sha256) and the cost of making the hashes a dictionary and allowing multiple
is pretty low.</p>
<p>The API was generally designed to allow further extension through adding new keys,
so if there’s some new piece of data that an installer might need, future PEPs can
easily make that available.</p>
</section>
<section id="why-include-the-filename-when-the-url-has-it-already">
<h3><a class="toc-backref" href="#why-include-the-filename-when-the-url-has-it-already" role="doc-backlink">Why include the filename when the URL has it already?</a></h3>
<p>We could reduce the size of our responses by removing the <code class="docutils literal notranslate"><span class="pre">filename</span></code> key and expecting
clients to pull that information out of the URL.</p>
<p>Currently this PEP chooses not to do that, largely because <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a> explicitly required
that the filename be available via the anchor tag of the links, though that was largely
because <em>something</em> had to be there. It’s not clear if repositories in the wild always
have a filename as the last part of the URL or if they’re relying on the filename in the
anchor tag.</p>
<p>It also makes the responses slightly nicer to read for a human, as you get a nice short
unique identifier.</p>
<p>If we got reasonable confidence that mandating the filename is in the URL, then we could
drop this data and reduce the size of the JSON response.</p>
</section>
<section id="why-not-break-out-other-pieces-of-information-from-the-filename">
<h3><a class="toc-backref" href="#why-not-break-out-other-pieces-of-information-from-the-filename" role="doc-backlink">Why not break out other pieces of information from the filename?</a></h3>
<p>Currently clients are expected to parse a number of pieces of information from the
filename such as project name, version, ABI tags, etc. We could break these out
and add them as keys to the file object.</p>
<p>This PEP has chosen not to do that because doing so would increase the size of the
API responses, and most clients are going to require the ability to parse that
information out of file names anyways regardless of what the API does. Thus it makes
sense to keep that functionality inside of the clients.</p>
</section>
<section id="why-content-negotiation-instead-of-multiple-urls">
<h3><a class="toc-backref" href="#why-content-negotiation-instead-of-multiple-urls" role="doc-backlink">Why Content Negotiation instead of multiple URLs?</a></h3>
<p>Another reasonable way to implement this would be to duplicate the API routes and
include some marker in the URL itself for JSON. Such as making the URLs be something
like <code class="docutils literal notranslate"><span class="pre">/simple/foo.json</span></code>, <code class="docutils literal notranslate"><span class="pre">/simple/_index.json</span></code>, etc.</p>
<p>This makes some things simpler like TUF integration and fully static serving of a
repository (since <code class="docutils literal notranslate"><span class="pre">.json</span></code> files can just be written out).</p>
<p>However, this is two pretty major issues:</p>
<ul>
<li>Our current URL structure relies on the fact that there is an URL that represents
the “root”, <code class="docutils literal notranslate"><span class="pre">/</span></code> to serve the list of projects. If we want to have separate URLs
for JSON and HTML, we would need to come up with some way to have two root URLs.<p>Something like <code class="docutils literal notranslate"><span class="pre">/</span></code> being HTML and <code class="docutils literal notranslate"><span class="pre">/_index.json</span></code> being JSON, since <code class="docutils literal notranslate"><span class="pre">_index</span></code>
isn’t a valid project name could work. But <code class="docutils literal notranslate"><span class="pre">/</span></code> being HTML doesn’t work great if
a repository wants to remove support for HTML.</p>
<p>Another option could be moving all of the existing HTML URLs under a namespace while
making a new namespace for JSON. Since <code class="docutils literal notranslate"><span class="pre">/&lt;project&gt;/</span></code> was defined, we would have to
make these namespaces not valid project names, so something like <code class="docutils literal notranslate"><span class="pre">/_html/</span></code> and
<code class="docutils literal notranslate"><span class="pre">/_json/</span></code> could work, then just redirect the non namespaced URLs to whatever the
“default” for that repository is (likely HTML, unless they’ve disabled HTML then JSON).</p>
</li>
<li>With separate URLs, there’s no good way to support zero configuration discovery
that a repository supports the JSON URLs without making additional HTTP requests to
determine if the JSON URL exists or not.<p>The most naive implementation of this would be to request the JSON URL and fall back
to the HTML URL for <em>every</em> single request, but that would be horribly performant
and violate the goal of minimal additional HTTP requests.</p>
<p>The most likely implementation of this would be to make some sort of repository level
configuration file that somehow indicates what is supported. We would have the same
namespace problem as above, with the same solution, something like <code class="docutils literal notranslate"><span class="pre">/_config.json</span></code>
or so could hold that data, and a client could first make an HTTP request to that,
and if it exists pull it down and parse it to learn about the capabilities of this
particular repository.</p>
</li>
<li>The use of <code class="docutils literal notranslate"><span class="pre">Accept</span></code> also allows us to add versioning into this field</li>
</ul>
<p>All being said, it is the opinion of this PEP that those three issues combined make
using separate API routes a less desirable solution than relying on content
negotiation to select the most ideal representation of the data.</p>
</section>
<section id="does-this-mean-that-static-servers-are-no-longer-supported">
<h3><a class="toc-backref" href="#does-this-mean-that-static-servers-are-no-longer-supported" role="doc-backlink">Does this mean that static servers are no longer supported?</a></h3>
<p>In short, no, static servers are still (almost) fully supported by this PEP.</p>
<p>The specifics of how they are supported will depend on the static server in
question. For example:</p>
<ul class="simple">
<li><strong>S3:</strong> S3 fully supports custom content types, however it does not support
any form of content negotiation. In order to have a server hosted on S3, you
would have to use the “Endpoint configuration” style of negotiation, and
users would have to configure their clients explicitly.</li>
<li><strong>GitHub Pages:</strong> GitHub pages does not support custom content types, so the
S3 solution is not currently workable, which means that only <code class="docutils literal notranslate"><span class="pre">text/html</span></code>
repositories would function.</li>
<li><strong>Apache:</strong> Apache fully supports server-driven content negotiation, and would
just need to be configured to map the custom content types to specific extension.</li>
</ul>
</section>
<section id="why-not-add-an-application-json-alias-like-text-html">
<h3><a class="toc-backref" href="#why-not-add-an-application-json-alias-like-text-html" role="doc-backlink">Why not add an <code class="docutils literal notranslate"><span class="pre">application/json</span></code> alias like <code class="docutils literal notranslate"><span class="pre">text/html</span></code>?</a></h3>
<p>This PEP believes that it is best for both clients and servers to be explicit
about the types of the API responses that are being used, and a content type
like <code class="docutils literal notranslate"><span class="pre">application/json</span></code> is the exact opposite of explicit.</p>
<p>The existence of the <code class="docutils literal notranslate"><span class="pre">text/html</span></code> alias exists as a compromise primarily to
ensure that existing consumers of the API continue to function as they already
do. There is no such expectation of existing clients using the Simple API with
a <code class="docutils literal notranslate"><span class="pre">application/json</span></code> content type.</p>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">application/json</span></code> has no versioning in it, which means that
if there is ever a <code class="docutils literal notranslate"><span class="pre">2.x</span></code> version of the Simple API, we will be forced to make
a decision. Should <code class="docutils literal notranslate"><span class="pre">application/json</span></code> preserve backwards compatibility and
continue to be an alias for <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+json</span></code>, or should
it be updated to be an alias for <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v2+json</span></code>?</p>
<p>This problem doesn’t exist for <code class="docutils literal notranslate"><span class="pre">text/html</span></code>, because the assumption is that
HTML will remain a legacy format, and will likely not gain <em>any</em> new features,
much less features that require breaking compatibility. So having it be an
alias for <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code> is effectively the same as
having it be an alias for <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.latest+html</span></code>, since
<code class="docutils literal notranslate"><span class="pre">1.x</span></code> will likely be the only HTML version to exist.</p>
<p>The largest benefit to adding the <code class="docutils literal notranslate"><span class="pre">application/json</span></code> content type is that
there do things that do not allow you to have custom content types, and require
you to select one of their preset content types. The main example of this being
GitHub Pages, which the lack of <code class="docutils literal notranslate"><span class="pre">application/json</span></code> support in this PEP means
that static repositories will no longer be able to be hosted on GitHub Pages
unless GitHub adds the <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+json</span></code> content type.</p>
<p>This PEP believes that the benefits are not large enough to add that content
type alias at this time, and that its inclusion would likely be a footgun
waiting for unsuspecting people to accidentally pick it up. Especially given
that we can always add it in the future, but removing things is a lot harder
to do.</p>
</section>
<section id="why-add-a-application-vnd-pypi-simple-v1-html">
<h3><a class="toc-backref" href="#why-add-a-application-vnd-pypi-simple-v1-html" role="doc-backlink">Why add a <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code>?</a></h3>
<p>The PEP expects the HTML version of the API to become legacy, so one option it
could take is not add the <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code> content type,
and just use <code class="docutils literal notranslate"><span class="pre">text/html</span></code> for that.</p>
<p>This PEP has decided that adding the new content type is better overall, since it
makes even the legacy format more self describing and makes them both more consistent
with each other. Overall I think it’s more confusing if the <code class="docutils literal notranslate"><span class="pre">+html</span></code> version doesn’t
exist.</p>
</section>
<section id="why-v1-0-and-not-v1-1-or-v2-0">
<h3><a class="toc-backref" href="#why-v1-0-and-not-v1-1-or-v2-0" role="doc-backlink">Why v1.0 and not v1.1 or v2.0?</a></h3>
<p>This PEP is still wholly backwards compatible with clients that could read the
existing v1.0 API, can still continue to read the API after these changes have
been made. In <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a>, the qualification for a major version bump is:</p>
<blockquote>
<div>Incrementing the major version is used to signal a backwards incompatible
change such that existing clients would no longer be expected to be able to
meaningfully use the API.</div></blockquote>
<p>The changes in this PEP do not meet that bar, nothing has changed in a way that
existing clients would no longer be expected to be able to meaningfully use the
API.</p>
<p>That means we should still be within the v1.x version line.</p>
<p>The question of whether we should be v1.1 or v1.0 is a more interesting one, and
there are a few ways of looking at it:</p>
<ul class="simple">
<li>We’ve exposed new features to the API (the project name on the project
page, multiple hashes), which is a sign that we should increment the minor
version.</li>
<li>The new features exist wholly within the JSON serialization, which means that
no client that currently is requesting the HTML 1.0 page, would ever see any
of the new features anyways, so for them it is effectively still v1.0.</li>
<li>No major client has implemented support for PEP 629 yet, which means that the
minor version numbering is largely academic at this point anyways, since it
exists to let clients provide feedback to end users.</li>
</ul>
<p>The second and third points above end up making the first point kind of
meaningless, and with that, it makes more sense to just call everything v1.0
and be stricter about updating versions into the future.</p>
</section>
</section>
<section id="appendix-1-survey-of-use-cases-to-cover">
<h2><a class="toc-backref" href="#appendix-1-survey-of-use-cases-to-cover" role="doc-backlink">Appendix 1: Survey of use cases to cover</a></h2>
<p>This was done through a discussion between <code class="docutils literal notranslate"><span class="pre">pip</span></code>, <code class="docutils literal notranslate"><span class="pre">PyPI</span></code>, and <code class="docutils literal notranslate"><span class="pre">bandersnarch</span></code>
maintainers, who are the two first potential users for the new API. This is
how they use the Simple + JSON APIs today or how they currently plan to use it:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">pip</span></code>:<ul>
<li>List of all files for a particular release</li>
<li>Metadata of each individual artifact:<ul>
<li>was it yanked? (<code class="docutils literal notranslate"><span class="pre">data-yanked</span></code>)</li>
<li>what’s the python-requires? (<code class="docutils literal notranslate"><span class="pre">data-python-requires</span></code>)</li>
<li>what’s the hash of this file? (currently, hash in URL)</li>
<li>Full metadata (<code class="docutils literal notranslate"><span class="pre">data-dist-info-metadata</span></code>)</li>
<li>[Bonus] what are the declared dependencies, if available (list-of-strings, null if unavailable)?</li>
</ul>
</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">bandersnatch</span></code> - Only uses legacy JSON API + XMLRPC today:<ul>
<li>Generates Simple HTML rather than copying from PyPI<ul>
<li>Maybe this changes with the new API and we verbatim pull these API assets from PyPI</li>
</ul>
</li>
<li>List of all files for a particular release.<ul>
<li>Workout URL for release files to download</li>
</ul>
</li>
<li>Metadata of each individual artifact.<ul>
<li>Write out the JSON to mirror storage today (disk/S3)<ul>
<li>Required metadata used
(via <a class="reference external" href="https://github.com/pypa/bandersnatch/blob/main/src/bandersnatch/package.py">Package class</a>):<ul>
<li><code class="docutils literal notranslate"><span class="pre">metadata[&quot;info&quot;]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">metadata[&quot;last_serial&quot;]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">metadata[&quot;releases&quot;]</span></code><ul>
<li>digests</li>
<li>URL</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>XML-RPC calls (we’d love to deprecate - but we don’t think should go in the Simple API)<ul>
<li>[Bonus] Get packages since serial X (or all)<ul>
<li>XML-RPC Call: <code class="docutils literal notranslate"><span class="pre">changelog_since_serial</span></code></li>
</ul>
</li>
<li>[Bonus] Get all packages with serial<ul>
<li>XML-RPC Call: <code class="docutils literal notranslate"><span class="pre">list_packages_with_serial</span></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="appendix-2-rough-underlying-data-models">
<h2><a class="toc-backref" href="#appendix-2-rough-underlying-data-models" role="doc-backlink">Appendix 2: Rough Underlying Data Models</a></h2>
<p>These are not intended to perfectly match the server, client, or wire
formats. Rather, these are conceptual models, put to code to make them
more explicit as to the abstract models underlining the repository API
as it evolved through <a class="pep reference internal" href="../pep-0503/" title="PEP 503 – Simple Repository API">PEP 503</a>, <a class="pep reference internal" href="../pep-0592/" title="PEP 592 – Adding “Yank” Support to the Simple API">PEP 592</a>, <a class="pep reference internal" href="../pep-0629/" title="PEP 629 – Versioning PyPI’s Simple API">PEP 629</a>, <a class="pep reference internal" href="../pep-0658/" title="PEP 658 – Serve Distribution Metadata in the Simple Repository API">PEP 658</a>,
and now this PEP, <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a>.</p>
<p>The existing HTML, and the new JSON serialization of these models then
represent how these underlying conceptual models get mapped onto the
actual wire formats.</p>
<p>How servers or clients choose to model this data is out of scope for
this PEP.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
    <span class="n">api_version</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;1.0&quot;</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Project</span><span class="p">:</span>
    <span class="c1"># Normalized or Non-Normalized Name</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># Computed in JSON, Included in HTML</span>
    <span class="n">url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">File</span><span class="p">:</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">url</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># Limited to a len() of 1 in HTML</span>
    <span class="n">hashes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="n">gpg_sig</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">requires_python</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP592File</span><span class="p">(</span><span class="n">File</span><span class="p">):</span>
    <span class="n">yanked</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP658File</span><span class="p">(</span><span class="n">PEP592File</span><span class="p">):</span>
    <span class="c1"># Limited to a len() of 1 in HTML</span>
    <span class="n">dist_info_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>


<span class="c1"># Simple Index page (/simple/)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP503_Index</span><span class="p">:</span>
    <span class="n">projects</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Project</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP629_Index</span><span class="p">(</span><span class="n">PEP503_Index</span><span class="p">):</span>
    <span class="n">meta</span><span class="p">:</span> <span class="n">Meta</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Index</span><span class="p">(</span><span class="n">PEP629_Index</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># Simple Detail page (/simple/$PROJECT/)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP503_Detail</span><span class="p">:</span>
    <span class="n">files</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">File</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP592_Detail</span><span class="p">(</span><span class="n">PEP503_Detail</span><span class="p">):</span>
    <span class="n">files</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">PEP592File</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP629_Detail</span><span class="p">(</span><span class="n">PEP592_Detail</span><span class="p">):</span>
    <span class="n">meta</span><span class="p">:</span> <span class="n">Meta</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP658_Detail</span><span class="p">(</span><span class="n">PEP629_Detail</span><span class="p">):</span>
  <span class="n">files</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">PEP658File</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PEP691_Detail</span><span class="p">(</span><span class="n">PEP658_Detail</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Normalized Name</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Detail</span><span class="p">(</span><span class="n">PEP691_Detail</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0691.rst">https://github.com/python/peps/blob/main/peps/pep-0691.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0691.rst">2025-08-20 21:30:45 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#goals">Goals</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#versioning">Versioning</a></li>
<li><a class="reference internal" href="#json-serialization">JSON Serialization</a><ul>
<li><a class="reference internal" href="#project-list">Project List</a></li>
<li><a class="reference internal" href="#project-detail">Project Detail</a></li>
</ul>
</li>
<li><a class="reference internal" href="#content-types">Content-Types</a></li>
<li><a class="reference internal" href="#version-format-selection">Version + Format Selection</a><ul>
<li><a class="reference internal" href="#alternative-negotiation-mechanisms">Alternative Negotiation Mechanisms</a><ul>
<li><a class="reference internal" href="#url-parameter">URL Parameter</a></li>
<li><a class="reference internal" href="#endpoint-configuration">Endpoint Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tuf-support-pep-458">TUF Support - PEP 458</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#does-this-mean-pypi-is-planning-to-drop-support-for-html-pep-503">Does this mean PyPI is planning to drop support for HTML/PEP 503?</a></li>
<li><a class="reference internal" href="#why-json-instead-of-x-format">Why JSON instead of X format?</a></li>
<li><a class="reference internal" href="#why-not-add-x-feature">Why not add X feature?</a></li>
<li><a class="reference internal" href="#why-include-the-filename-when-the-url-has-it-already">Why include the filename when the URL has it already?</a></li>
<li><a class="reference internal" href="#why-not-break-out-other-pieces-of-information-from-the-filename">Why not break out other pieces of information from the filename?</a></li>
<li><a class="reference internal" href="#why-content-negotiation-instead-of-multiple-urls">Why Content Negotiation instead of multiple URLs?</a></li>
<li><a class="reference internal" href="#does-this-mean-that-static-servers-are-no-longer-supported">Does this mean that static servers are no longer supported?</a></li>
<li><a class="reference internal" href="#why-not-add-an-application-json-alias-like-text-html">Why not add an <code class="docutils literal notranslate"><span class="pre">application/json</span></code> alias like <code class="docutils literal notranslate"><span class="pre">text/html</span></code>?</a></li>
<li><a class="reference internal" href="#why-add-a-application-vnd-pypi-simple-v1-html">Why add a <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.simple.v1+html</span></code>?</a></li>
<li><a class="reference internal" href="#why-v1-0-and-not-v1-1-or-v2-0">Why v1.0 and not v1.1 or v2.0?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-1-survey-of-use-cases-to-cover">Appendix 1: Survey of use cases to cover</a></li>
<li><a class="reference internal" href="#appendix-2-rough-underlying-data-models">Appendix 2: Rough Underlying Data Models</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0691.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>