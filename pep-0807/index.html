
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 807 – Index support for Trusted Publishing | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0807/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 807 – Index support for Trusted Publishing | peps.python.org'>
    <meta property="og:description" content="This PEP proposes a standard mechanism through which arbitrary Python package indices can support “Trusted Publishing,” a misuse-resistant credential exchange scheme already implemented by the Python Package Index (PyPI).">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0807/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes a standard mechanism through which arbitrary Python package indices can support “Trusted Publishing,” a misuse-resistant credential exchange scheme already implemented by the Python Package Index (PyPI).">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 807</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 807 – Index support for Trusted Publishing" data-pagefind-weight="10" class="visually-hidden">PEP 807 – Index support for Trusted Publishing</span>
            <section id="pep-content">
<h1 class="page-title">PEP 807 – Index support for Trusted Publishing</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">William Woodruff &lt;william&#32;&#97;t&#32;yossarian.net&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;</dd>
<dt class="field-odd">PEP-Delegate<span class="colon">:</span></dt>
<dd class="field-odd">Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/104027">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Topic<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">19-Sep-2025</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/103067" title="Discourse thread">08-Aug-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/104027" title="Discourse thread">29-Sep-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#constraints">Constraints</a></li>
<li><a class="reference internal" href="#trusted-publishing-discovery">Trusted Publishing Discovery</a></li>
<li><a class="reference internal" href="#trusted-publishing-token-exchange">Trusted Publishing Token Exchange</a><ul>
<li><a class="reference internal" href="#audience-retrieval">Audience Retrieval</a></li>
<li><a class="reference internal" href="#token-minting">Token Minting</a></li>
<li><a class="reference internal" href="#feature-negotiation">Feature Negotiation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How To Teach This</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#lateral-discovery">“Lateral” Discovery</a></li>
<li><a class="reference internal" href="#implicit-discovery">“Implicit” Discovery</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes a standard mechanism through which arbitrary
Python package indices can support “Trusted Publishing,” a misuse-resistant
credential exchange scheme already implemented by the Python Package Index
(PyPI).</p>
<p>The mechanism proposed in this PEP is designed to encapsulate PyPI’s
<a class="reference external" href="https://docs.pypi.org/trusted-publishers/">existing implementation</a>
of Trusted Publishing, while allowing other indices to implement the same
scheme in a manner that is discoverable by and interoperable with existing
Python package uploading clients.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>“Trusted Publishing” is PyPI’s term of art for using the
<a class="reference external" href="https://openid.net/connect/">OpenID Connect (OIDC) standard</a>
to exchange a short-lived <em>identity credential</em> from a trusted
third-party service (like a CI/CD or cloud provider) for a short-lived,
minimally-scoped <em>upload credential</em> that can be used to publish
to the index.</p>
<p>Trusted Publishing was originally designed and enabled on PyPI in 2023 as
a non-standard (PyPI-specific) feature, much like the existing
<a class="reference external" href="https://docs.pypi.org/api/upload/">upload API</a>. It has seen
widespread adoption in that capacity: over one million files have been published
to PyPI using a Trusted Publisher (as of September 2025), representing
approximately one in every eight files uploaded to PyPI since becoming
available. Additionally, PyPI’s design has inspired similar designs in the
<a class="reference external" href="https://crates.io/docs/trusted-publishing">Rust (crates.io)</a>,
<a class="reference external" href="https://guides.rubygems.org/trusted-publishing/">Ruby (RubyGems)</a>, and
<a class="reference external" href="https://docs.npmjs.com/trusted-publishers">JavaScript (npm)</a> ecosystems.</p>
<p>The absence of a standard for Trusted Publishing presents a long-term
impediment for adoption: third-party indices (i.e. those other than
PyPI and TestPyPI) cannot easily implement Trusted Publishing without
referencing PyPI’s unstandardized design. This in turn poses a long-term
maturity risk similar to that of the unstandardized upload API: package upload
clients (like <a class="reference external" href="https://twine.readthedocs.io/en/stable/">Twine</a> and
<a class="reference external" href="https://docs.astral.sh/uv/">uv</a>) must either accept behavioral differences
between indices (leading to an accretion of hacks) or continue to reject
non-PyPI implementations of Trusted Publishing.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The lack of an existing standard for Trusted Publishing is the primary
rationale for this PEP.</p>
<p>The design proposed in this PEP closely follows PyPI’s existing implementation,
with an added layer of <a class="reference internal" href="#trusted-publishing-discovery">discovery</a>
that enables uploading clients to determine whether an arbitrary index
supports Trusted Publishing without making PyPI-specific assumptions.</p>
<p>The rationale for this design is as follows:</p>
<ol class="arabic simple">
<li>The existing (unstandardized) implementation of Trusted Publishign on PyPI
has a proven track record, and is already widely adopted in uploading tools.
A significant deviation from the existing design would introduce
unnecessary compatibility risks.</li>
<li>The discovery mechanism proposed in this PEP is designed to be
consistent with existing standards for machine-to-machine protocols,
namely <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8615.html"><strong>RFC 8615</strong></a> (Well-Known URIs). Additionally, this discovery mechanism
is designed to allow multiple indices to be hosted under a single
domain, which is a common topology for third-party index hosts.</li>
</ol>
<p>In sum, the rationale for this PEP is to standardize PyPI’s existing
interfaces <em>and</em> make them discoverable while allowing index hosts
that don’t match PyPI’s topology to implement Trusted Publishing.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>This PEP’s specification contains two parts:</p>
<ul class="simple">
<li>A <em>discovery</em> mechanism that package upload clients can use to determine
whether an arbitrary Python package index host supports Trusted Publishing.</li>
<li>A <em>token exchange</em> mechanism that package upload clients can use to
exchange an identity credential for an upload credential.</li>
</ul>
<section id="constraints">
<h3><a class="toc-backref" href="#constraints" role="doc-backlink">Constraints</a></h3>
<p>Unless explicitly stated otherwise, the following constraints
apply to all parts of this PEP’s specification:</p>
<ul>
<li>All URLs <strong>MUST</strong> have <a class="reference external" href="https://www.w3.org/TR/secure-contexts/#potentially-trustworthy-origin">potentially trustworthy origins</a>.
In practice, this means that all URLs <strong>MUST</strong> use the <code class="docutils literal notranslate"><span class="pre">https</span></code>
scheme, be some variant of a local loopback (<code class="docutils literal notranslate"><span class="pre">localhost</span></code>,
<code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code>, etc.), or otherwise be considered <em>a priori</em> trustworthy
in the context of the interaction (e.g. an internal network).<p>Uploading clients <strong>MUST</strong> reject any URLs that do not meet this constraint.</p>
</li>
<li>All server-supplied URLs (i.e. those in discovery responses) <strong>MUST</strong>
have the same host subcomponent as the user-provided upload URL. Uploading
clients <strong>MUST</strong> reject any URLs that do not meet this constraint.<p>In practice, this means that a discovery request to
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/.well-known/pytp?discover={key}</span></code> can only
return URLs with the <code class="docutils literal notranslate"><span class="pre">upload.example.com</span></code> host.</p>
</li>
<li>All client requests <strong>SHOULD</strong> have an
<code class="docutils literal notranslate"><span class="pre">Accept:</span> <span class="pre">application/vnd.pypi.pytp.v1+json</span></code> header. In the absence of
an <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header, the receiving server <strong>MUST</strong> behave as if this header
were present.<p>Receiving servers <strong>SHOULD</strong> respond with a <code class="docutils literal notranslate"><span class="pre">406</span> <span class="pre">Not</span> <span class="pre">Acceptable</span></code>
status code if any other <code class="docutils literal notranslate"><span class="pre">Accept</span></code> header is present.</p>
</li>
<li>Unless otherwise specified, all error (4xx and 5xx) responses from the server
<strong>MUST</strong> use the <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9457.html"><strong>RFC 9457</strong></a> (Problem Details for HTTP APIs) format.
In particular, the server <strong>MUST</strong> use the “Problem Details JSON Object”
defined in <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9457.html#section-3"><strong>Section 3</strong></a> and <strong>SHOULD</strong> use
the <code class="docutils literal notranslate"><span class="pre">application/problem+json</span></code> media type in its responses.</li>
</ul>
</section>
<section id="trusted-publishing-discovery">
<h3><a class="toc-backref" href="#trusted-publishing-discovery" role="doc-backlink">Trusted Publishing Discovery</a></h3>
<p>All Python package uploading is currently “endpoint driven,” in the sense
uploading clients (like <em>twine</em> and <em>uv</em>) are given an upload URL (and
<strong>not</strong> merely a domain name).</p>
<p>For example, to upload to PyPI, uploading clients are expected to connect
to <code class="docutils literal notranslate"><span class="pre">https://upload.pypi.org/legacy/</span></code>.</p>
<p>The discovery mechanism proposed below takes advantage of this fact to
allow single domains to advertise support for multiple indices
(and their corresponding upload endpoints).</p>
<p>The discovery mechanism is as follows:</p>
<ol class="arabic">
<li>The uploading client is given an upload URL, e.g.
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/legacy/</span></code>.</li>
<li>The uploading client extracts the <em>path component</em> of the URL,
as defined in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>. If the path component is empty,
the empty string should be used.<p>For the above example, the path component is
<code class="docutils literal notranslate"><span class="pre">/legacy/</span></code>.</p>
</li>
<li>The uploading client performs a query-safe URL encoding of the path component
(i.e. percent-encoding as defined in <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>, including encoding
of forward slashes and spaces), producing the <em>discovery key</em>.<p>For the above example, the discovery key is
<code class="docutils literal notranslate"><span class="pre">%2Flegacy%2F</span></code>. <a class="footnote-reference brackets" href="#fn-discovery-key" id="id1">[1]</a></p>
</li>
<li>The uploading client constructs a <em>discovery URL</em> by taking the
scheme and authority components (as defined in <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>)
of the upload URL and appending <code class="docutils literal notranslate"><span class="pre">/.well-known/pytp</span></code> as the path.
Then, the uploading client appends the discovery key as the value
of the <code class="docutils literal notranslate"><span class="pre">discover</span></code> query parameter.<p>For the above example, the discovery URL is
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/.well-known/pytp?discover=%2Flegacy%2F</span></code>.</p>
</li>
<li>The uploading client performs an HTTP GET request to the discovery URL.</li>
<li>The server responds with a <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> status code and a body
containing a JSON object if the index supports Trusted Publishing
for the given upload URL.<p>The JSON object <strong>MUST</strong> contain the following
fields:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">audience-endpoint</span></code>: a string containing the URL of the OIDC
audience endpoint to be used during token exchange.</li>
<li><code class="docutils literal notranslate"><span class="pre">token-mint-endpoint</span></code>: a string containing the URL of the
token minting endpoint to be used during token exchange.</li>
</ul>
<p>Additionally, the JSON object <strong>MAY</strong> contain the following fields:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">features</span></code>: an array of strings indicating optional features
supported by the index’s Trusted Publishing implementation.
The set of possible features is defined under <a class="reference internal" href="#feature-negotiation">feature negotiation</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">default-features</span></code>: an array of strings indicating the default
features used by the index’s Trusted Publishing implementation
if a request does not explicitly specify any features.
If the <code class="docutils literal notranslate"><span class="pre">default-features</span></code> field is not present, the uploading client
<strong>MUST</strong> assume a default of <code class="docutils literal notranslate"><span class="pre">[&quot;multi-use-token&quot;]</span></code>.</li>
</ul>
<p>For the above example, a valid response body would be:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="nt">&quot;audience-endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://upload.example.com/_/oidc/audience&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;token-mint-endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://upload.example.com/_/oidc/mint-token&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;features&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;single-use-token&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;multi-use-token&quot;</span><span class="p">],</span>
<span class="w">   </span><span class="nt">&quot;default-features&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;multi-use-token&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<p>If the server does not support Trusted Publishing for the given
upload URL, it <strong>MUST</strong> respond with a <code class="docutils literal notranslate"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></code> status code.</p>
<p>Servers <strong>MAY</strong> additionally respond with any other standard HTTP
error code in the 400 or 500 range to indicate an appropriate error
condition.</p>
</section>
<section id="trusted-publishing-token-exchange">
<h3><a class="toc-backref" href="#trusted-publishing-token-exchange" role="doc-backlink">Trusted Publishing Token Exchange</a></h3>
<p>Once an uploading client has performed a successful
<a class="reference internal" href="#trusted-publishing-discovery">discovery</a> flow, it can proceed to perform
the actual Trusted Publishing token exchange.</p>
<p>Token exchange occurs in three steps:</p>
<ol class="arabic simple">
<li>The uploading client uses the <em>audience endpoint</em> obtained
during discovery to ask the index for its expected OIDC audience.</li>
<li>The uploading client uses the expected audience to obtain an
appropriately bound <em>identity credential</em> from the Trusted Publishing
provider being used (i.e. the CI/CD or cloud provider that the upload
is being performed from). The details of this step are provider-specific,
and are out of scope for this PEP. <a class="footnote-reference brackets" href="#fn-oidc" id="id2">[2]</a></li>
<li>The uploading client uses the <em>token minting endpoint</em> obtained
during discovery to exchange the obtained identity credential
for a short-lived <em>upload credential</em> that can be used to upload
to the index.</li>
</ol>
<section id="audience-retrieval">
<h4><a class="toc-backref" href="#audience-retrieval" role="doc-backlink">Audience Retrieval</a></h4>
<p>To retrieve the expected OIDC audience, the uploading client performs
an HTTP GET request to the <em>audience endpoint</em> obtained during
<a class="reference internal" href="#trusted-publishing-discovery">discovery</a>.</p>
<p>On success, the server responds with a <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> status code and a body
containing a JSON object with the following field:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">audience</span></code>: a string containing the expected OIDC audience.</li>
</ul>
<p>On failure, the server <strong>MUST</strong> respond with a standard HTTP
error code in the 400 or 500 range to indicate the appropriate error condition.</p>
</section>
<section id="token-minting">
<h4><a class="toc-backref" href="#token-minting" role="doc-backlink">Token Minting</a></h4>
<p>After the uploading client has performed
<a class="reference internal" href="#audience-retrieval">audience retrieval</a> and obtained an
identity credential from the Trusted Publishing provider, it can
proceed to mint an upload credential.</p>
<p>To mint an upload credential, the uploading client performs
an HTTP POST request to the <em>token minting endpoint</em> obtained during
<a class="reference internal" href="#trusted-publishing-discovery">discovery</a>. The payload of the
POST request <strong>MUST</strong> be a JSON object containing the following:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">token</span></code>: a string containing the identity credential
obtained from the Trusted Publishing provider.</li>
<li><code class="docutils literal notranslate"><span class="pre">features</span></code>: an <strong>optional</strong> array of strings
indicating the desired features for the minted upload credential.
If this field is not provided by the client, the server <strong>MUST</strong> use
its own default features as specified in the
<code class="docutils literal notranslate"><span class="pre">default-features</span></code> field during discovery.</li>
</ul>
<p>For example, a valid request body would be:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="nt">&quot;token&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ey...&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;features&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;single-use-token&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On success, the server responds with a <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> status code and a body
containing a JSON object with the following fields:</p>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">token</span></code>: a string containing the upload credential. The format
of the upload credential is implementation-defined and index-specific.</li>
<li><code class="docutils literal notranslate"><span class="pre">expires</span></code>: an <strong>optional</strong> integer containing a Unix timestamp
indicating when the upload credential expires. If this field is not
present, the uploading client <strong>MAY</strong> assume an expiration point
of not more than 15 minutes (900 seconds) after the time of
their request.<p>The server <strong>MUST NOT</strong> issue temporary upload credentials
that expire in less than 15 minutes (900 seconds) or more than
6 hours (21,600 seconds) from the time of the request.</p>
<p>The maximum expiry time of 6 hours is chosen to match common runtime limits
on popular CI/CD providers like GitHub Actions.</p>
<p>The uploading client <strong>MAY</strong> use this time (or the minimum specified
above) to determine when to refresh the upload credential, if needed.</p>
</li>
</ul>
<p>On failure, the server <strong>MUST</strong> respond with any standard HTTP
error code in the 400 or 500 range to indicate the appropriate error condition.</p>
</section>
<section id="feature-negotiation">
<h4><a class="toc-backref" href="#feature-negotiation" role="doc-backlink">Feature Negotiation</a></h4>
<p>The protocol defined in this PEP supports an <em>optional</em> mechanism for
negotiating non-default features between the uploading client and the
receiving index server. These features are advertised as an array of
strings in the <code class="docutils literal notranslate"><span class="pre">features</span></code> field of the discovery response; the client
can then request one or more features by including them in the <code class="docutils literal notranslate"><span class="pre">features</span></code>
field of the token minting request.</p>
<p>The following features are defined:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">single-use-token</span></code>: the tokens minted by the index server
<strong>MUST</strong> be single-use tokens. In other words, the token returned
by the token minting endpoint <strong>MUST</strong> only be usable for a single
upload operation. Any subsequent upload attempts using the same
token <strong>MUST</strong> be rejected by the index server. Clients that request
the <code class="docutils literal notranslate"><span class="pre">single-use-token</span></code> feature <strong>MUST</strong> be prepared to perform
multiple token minting operations if multiple upload operations
are needed.</li>
<li><code class="docutils literal notranslate"><span class="pre">multi-use-token</span></code>: the tokens minted by the index server
<strong>MUST</strong> be multi-use tokens. In other words, the token returned
by the token minting endpoint <strong>MAY</strong> be usable for multiple
upload operations until it expires.</li>
</ul>
</section>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>This PEP seeks to improve the security and transparency of the Python packaging
ecosystem by formally standardizing the Trusted Publishing flow already
used by PyPI.</p>
<p>This PEP does not identify any positive or negative security implications
associated with the Trusted Publishing discovery or exchange flows themselves.</p>
<p>Separately from the flows, Trusted Publishing <em>itself</em> has a
<a class="reference external" href="https://docs.pypi.org/trusted-publishers/security-model/">security model on PyPI</a>
and is considered to be a more secure alternative to long-lived
API tokens or passwords. The primary positive security implications of
Trusted Publishing are:</p>
<ul class="simple">
<li>All issued upload credentials are short-lived and can be minimally scoped,
limiting the “blast radius” of a compromised credential. In particular,
automatic expiry means that attackers cannot mount “harvest now, use later”
campaigns against packages that use Trusted Publishing.</li>
<li>Trusted Publishing conceptually links an uploaded package to the identity
of the CI/CD or cloud provider that’s authorized to upload it. This linkage
is implicit from the perspective of downstream consumers, but can be made
explicit through <a class="pep reference internal" href="../pep-0740/" title="PEP 740 – Index support for digital attestations">PEP 740</a> attestations or (less formally)
<a class="reference external" href="https://docs.pypi.org/project_metadata/#via-trusted-publishing">URL verification</a>.</li>
</ul>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>This PEP does not change any existing behavior and is fully backwards compatible
with existing upload clients and indices.</p>
<p>Existing clients that perform PyPI’s non-standard Trusted Publishing
upload flow will continue to work as before, as will existing uploads
to all indices that do not implement Trusted Publishing.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How To Teach This</a></h2>
<p>This PEP is a <em>formalization</em> of Trusted Publishing, which has already
seen widespread adoption in the Python packaging ecosystem. That adoption
has been accompanied by a variety of educational resources on
adopting Trusted Publishing as an end user, including:</p>
<ul class="simple">
<li>Python Packaging User Guide: <a class="reference external" href="https://packaging.python.org/en/latest/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows/#trusted-publishing" title="(in Python Packaging User Guide)"><span>Publishing package distribution releases using GitHub Actions CI/CD workflows</span></a></li>
<li>PyPI: <a class="reference external" href="https://docs.pypi.org/trusted-publishers/">Publishing to PyPI with a Trusted Publisher</a></li>
<li>pyOpenSci: <a class="reference external" href="https://www.pyopensci.org/python-package-guide/tutorials/trusted-publishing.html">Setup Trusted Publishing for secure and automated publishing via GitHub Actions</a></li>
</ul>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="lateral-discovery">
<h3><a class="toc-backref" href="#lateral-discovery" role="doc-backlink">“Lateral” Discovery</a></h3>
<p>This PEP’s discovery mechanism uses the <code class="docutils literal notranslate"><span class="pre">.well-known</span></code> location scheme
defined in <span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8615.html"><strong>RFC 8615</strong></a>. This scheme is widely adopted by machine-to-machine
protocols, including OpenID Connect itself (for <a class="reference external" href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery</a>).</p>
<p>An alternative idea considered was to use a “lateral” discovery mechanism,
in which the uploading client would attempt discovery by constructing a
adjacent path relative to the upload URL. For example, for
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/legacy/</span></code>, the uploading client would
attempt to discover Trusted Publishing support at
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/legacy/pytp</span></code> (or some equivalent).</p>
<p>The advantage of this approach is that it doesn’t require index operators
to have control over their (sub-)domain, which the <code class="docutils literal notranslate"><span class="pre">.well-known</span></code> scheme
expects (as well-known URIs can only be served from the root of a domain).</p>
<p>However, this approach also has downsides:</p>
<ul class="simple">
<li>It assumes that arbitrary indices can provide an adjacent path without
interfering with existing functionality, which isn’t necessarily true.
For example, a given third-party implementation may already use
all routes under <code class="docutils literal notranslate"><span class="pre">/legacy/{*}</span></code> for other purposes.</li>
<li>It’s less consistent with existing machine-to-machine protocol
conventions, which overwhelmingly use the <code class="docutils literal notranslate"><span class="pre">.well-known</span></code> scheme. Developing
a custom location scheme here would require additional informational
materials for server administrators and operators who are accustomed
to the <code class="docutils literal notranslate"><span class="pre">.well-known</span></code> scheme.</li>
</ul>
</section>
<section id="implicit-discovery">
<h3><a class="toc-backref" href="#implicit-discovery" role="doc-backlink">“Implicit” Discovery</a></h3>
<p>Another alternative idea considered was the perform “implicit” discovery,
similar to what PyPI currently does for Trusted Publishing: instead of an
explicit <a class="reference internal" href="#trusted-publishing-discovery">discovery</a> step, the uploading client could jump
straight to attempting the audience and token minting steps, and
handle any errors that arise.</p>
<p>The advantage of this approach is simplicity: it eliminates the network
round-trip needed for the discovery step, and eliminates the indirection
of obtaining the audience and token minting endpoints from the discovery
response.</p>
<p>This approach too has downsides:</p>
<ul class="simple">
<li>It implicitly limits a given domain to a single index/upload implementation,
since the implicit “discovery” step on PyPI is to construct the audience
and token minting endpoints against the base domain of the upload URL.
This limitation is acceptable in the context of a single index host
like PyPI, but does not generalize to other index topologies (like
index hosts that provide isolated private indices).</li>
<li>It relies on entirely static endpoint construction rules for
the audience and token minting endpoints, which means significant disruption
to existing clients if those endpoints ever need to change.</li>
</ul>
</section>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fn-discovery-key" role="doc-footnote">
<dt class="label" id="fn-discovery-key">[<a href="#id1">1</a>]</dt>
<dd>The discovery key may be computed thusly:<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;/legacy/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="go">&#39;%2Flegacy%2F&#39;</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="fn-oidc" role="doc-footnote">
<dt class="label" id="fn-oidc">[<a href="#id2">2</a>]</dt>
<dd>Widely used CI/CD and cloud providers variously implement “ambient”
OIDC token retrieval mechanisms that aren’t standardized.
These various mechanisms are currently abstracted over by
existing components of the Python packaging ecosystem,
such as the <a class="extlink-pypi reference external" href="https://pypi.org/project/id/">id</a> package.</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0807.rst">https://github.com/python/peps/blob/main/peps/pep-0807.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0807.rst">2026-01-23 20:54:56 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#constraints">Constraints</a></li>
<li><a class="reference internal" href="#trusted-publishing-discovery">Trusted Publishing Discovery</a></li>
<li><a class="reference internal" href="#trusted-publishing-token-exchange">Trusted Publishing Token Exchange</a><ul>
<li><a class="reference internal" href="#audience-retrieval">Audience Retrieval</a></li>
<li><a class="reference internal" href="#token-minting">Token Minting</a></li>
<li><a class="reference internal" href="#feature-negotiation">Feature Negotiation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How To Teach This</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#lateral-discovery">“Lateral” Discovery</a></li>
<li><a class="reference internal" href="#implicit-discovery">“Implicit” Discovery</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0807.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>