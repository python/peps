
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 3128 – BList: A Faster List-like Type | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-3128/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 3128 – BList: A Faster List-like Type | peps.python.org'>
    <meta property="og:description" content="The common case for list operations is on small lists.  The current array-based list implementation excels at small lists due to the strong locality of reference and infrequency of memory allocation operations.  However, an array takes O(n) time to inse...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-3128/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="The common case for list operations is on small lists.  The current array-based list implementation excels at small lists due to the strong locality of reference and infrequency of memory allocation operations.  However, an array takes O(n) time to inse...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 3128</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 3128 – BList: A Faster List-like Type" data-pagefind-weight="10" class="visually-hidden">PEP 3128 – BList: A Faster List-like Type</span>
            <section id="pep-content">
<h1 class="page-title">PEP 3128 – BList: A Faster List-like Type</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Daniel Stutzbach &lt;daniel&#32;&#97;t&#32;stutzbachenterprises.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/pipermail/python-3000/">Python-3000 list</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Formally declined and will not be accepted">Rejected</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">30-Apr-2007</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">2.6, 3.0</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd">30-Apr-2007</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#rejection-notice">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#use-case-trade-offs">Use Case Trade-offs</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#memory-usage">Memory Usage</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#porting-to-other-python-variants">Porting to Other Python Variants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#on-going-tasks">On-going Tasks</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="rejection-notice">
<h2><a class="toc-backref" href="#rejection-notice" role="doc-backlink">Rejection Notice</a></h2>
<p>Rejected based on Raymond Hettinger’s sage advice <a class="footnote-reference brackets" href="#id9" id="id1">[4]</a>:</p>
<blockquote>
<div>After looking at the source, I think this has almost zero chance
for replacing list().  There is too much value in a simple C API,
low space overhead for small lists, good performance is common use
cases, and having performance that is easily understood.  The
BList implementation lacks these virtues and it trades-off a little
performance in common cases in for much better performance in
uncommon cases.  As a Py3.0 PEP, I think it can be rejected.<p>Depending on its success as a third-party module, it still has a
chance for inclusion in the collections module.  The essential
criteria for that is whether it is a superior choice for some
real-world use cases.  I’ve scanned my own code and found no instances
where BList would have been preferable to a regular list.  However,
that scan has a selection bias because it doesn’t reflect what I would
have written had BList been available.  So, after a few months, I
intend to poll comp.lang.python for BList success stories.  If they
exist, then I have no problem with inclusion in the collections
module.  After all, its learning curve is near zero – the only cost
is the clutter factor stemming from indecision about the most
appropriate data structure for a given task.</p>
</div></blockquote>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>The common case for list operations is on small lists.  The current
array-based list implementation excels at small lists due to the
strong locality of reference and infrequency of memory allocation
operations.  However, an array takes O(n) time to insert and delete
elements, which can become problematic as the list gets large.</p>
<p>This PEP introduces a new data type, the BList, that has array-like
and tree-like aspects.  It enjoys the same good performance on small
lists as the existing array-based implementation, but offers superior
asymptotic performance for most operations.  This PEP proposes
replacing the makes two mutually exclusive proposals for including the
BList type in Python:</p>
<ol class="arabic simple">
<li>Add it to the collections module, or</li>
<li>Replace the existing list type</li>
</ol>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The BList grew out of the frustration of needing to rewrite intuitive
algorithms that worked fine for small inputs but took O(n**2) time for
large inputs due to the underlying O(n) behavior of array-based lists.
The deque type, introduced in Python 2.4, solved the most common
problem of needing a fast FIFO queue.  However, the deque type doesn’t
help if we need to repeatedly insert or delete elements from the
middle of a long list.</p>
<p>A wide variety of data structure provide good asymptotic performance
for insertions and deletions, but they either have O(n) performance
for other operations (e.g., linked lists) or have inferior performance
for small lists (e.g., binary trees and skip lists).</p>
<p>The BList type proposed in this PEP is based on the principles of
B+Trees, which have array-like and tree-like aspects.  The BList
offers array-like performance on small lists, while offering O(log n)
asymptotic performance for all insert and delete operations.
Additionally, the BList implements copy-on-write under-the-hood, so
even operations like getslice take O(log n) time.  The table below
compares the asymptotic performance of the current array-based list
implementation with the asymptotic performance of the BList.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Array-based list</th>
<th class="head">BList</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td>Copy</td>
<td>O(n)</td>
<td><strong>O(1)</strong></td>
</tr>
<tr class="row-odd"><td>Append</td>
<td><strong>O(1)</strong></td>
<td>O(log n)</td>
</tr>
<tr class="row-even"><td>Insert</td>
<td>O(n)</td>
<td><strong>O(log n)</strong></td>
</tr>
<tr class="row-odd"><td>Get Item</td>
<td><strong>O(1)</strong></td>
<td>O(log n)</td>
</tr>
<tr class="row-even"><td>Set Item</td>
<td><strong>O(1)</strong></td>
<td><strong>O(log n)</strong></td>
</tr>
<tr class="row-odd"><td>Del Item</td>
<td>O(n)</td>
<td><strong>O(log n)</strong></td>
</tr>
<tr class="row-even"><td>Iteration</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr class="row-odd"><td>Get Slice</td>
<td>O(k)</td>
<td><strong>O(log n)</strong></td>
</tr>
<tr class="row-even"><td>Del Slice</td>
<td>O(n)</td>
<td><strong>O(log n)</strong></td>
</tr>
<tr class="row-odd"><td>Set Slice</td>
<td>O(n+k)</td>
<td><strong>O(log k + log n)</strong></td>
</tr>
<tr class="row-even"><td>Extend</td>
<td>O(k)</td>
<td><strong>O(log k + log n)</strong></td>
</tr>
<tr class="row-odd"><td>Sort</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
</tr>
<tr class="row-even"><td>Multiply</td>
<td>O(nk)</td>
<td><strong>O(log k)</strong></td>
</tr>
</tbody>
</table>
<p>An extensive empirical comparison of Python’s array-based list and the
BList are available at <a class="footnote-reference brackets" href="#id7" id="id2">[2]</a>.</p>
</section>
<section id="use-case-trade-offs">
<h2><a class="toc-backref" href="#use-case-trade-offs" role="doc-backlink">Use Case Trade-offs</a></h2>
<p>The BList offers superior performance for many, but not all,
operations.  Choosing the correct data type for a particular use case
depends on which operations are used.  Choosing the correct data type
as a built-in depends on balancing the importance of different use
cases and the magnitude of the performance differences.</p>
<p>For the common uses cases of small lists, the array-based list and the
BList have similar performance characteristics.</p>
<p>For the slightly less common case of large lists, there are two common
uses cases where the existing array-based list outperforms the
existing BList reference implementation.  These are:</p>
<ol class="arabic simple">
<li>A large LIFO stack, where there are many .append() and .pop(-1)
operations.  Each operation is O(1) for an array-based list, but
O(log n) for the BList.</li>
<li>A large list that does not change size.  The getitem and setitem
calls are O(1) for an array-based list, but O(log n) for the BList.</li>
</ol>
<p>In performance tests on a 10,000 element list, BLists exhibited a 50%
and 5% increase in execution time for these two uses cases,
respectively.</p>
<p>The performance for the LIFO use case could be improved to O(n) time,
by caching a pointer to the right-most leaf within the root node.  For
lists that do not change size, the common case of sequential access
could also be improved to O(n) time via caching in the root node.
However, the performance of these approaches has not been empirically
tested.</p>
<p>Many operations exhibit a tremendous speed-up (O(n) to O(log n)) when
switching from the array-based list to BLists.  In performance tests
on a 10,000 element list, operations such as getslice, setslice, and
FIFO-style insert and deletes on a BList take only 1% of the time
needed on array-based lists.</p>
<p>In light of the large performance speed-ups for many operations, the
small performance costs for some operations will be worthwhile for
many (but not all) applications.</p>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>The BList is based on the B+Tree data structure.  The BList is a wide,
bushy tree where each node contains an array of up to 128 pointers to
its children.  If the node is a leaf, its children are the
user-visible objects that the user has placed in the list.  If node is
not a leaf, its children are other BList nodes that are not
user-visible.  If the list contains only a few elements, they will all
be a children of single node that is both the root and a leaf.  Since
a node is little more than array of pointers, small lists operate in
effectively the same way as an array-based data type and share the
same good performance characteristics.</p>
<p>The BList maintains a few invariants to ensure good (O(log n))
asymptotic performance regardless of the sequence of insert and delete
operations.  The principle invariants are as follows:</p>
<ol class="arabic simple">
<li>Each node has at most 128 children.</li>
<li>Each non-root node has at least 64 children.</li>
<li>The root node has at least 2 children, unless the list contains
fewer than 2 elements.</li>
<li>The tree is of uniform depth.</li>
</ol>
<p>If an insert would cause a node to exceed 128 children, the node
spawns a sibling and transfers half of its children to the sibling.
The sibling is inserted into the node’s parent.  If the node is the
root node (and thus has no parent), a new parent is created and the
depth of the tree increases by one.</p>
<p>If a deletion would cause a node to have fewer than 64 children, the
node moves elements from one of its siblings if possible.  If both of
its siblings also only have 64 children, then two of the nodes merge
and the empty one is removed from its parent.  If the root node is
reduced to only one child, its single child becomes the new root
(i.e., the depth of the tree is reduced by one).</p>
<p>In addition to tree-like asymptotic performance and array-like
performance on small-lists, BLists support transparent
<strong>copy-on-write</strong>.  If a non-root node needs to be copied (as part of
a getslice, copy, setslice, etc.), the node is shared between multiple
parents instead of being copied.  If it needs to be modified later, it
will be copied at that time.  This is completely behind-the-scenes;
from the user’s point of view, the BList works just like a regular
Python list.</p>
</section>
<section id="memory-usage">
<h2><a class="toc-backref" href="#memory-usage" role="doc-backlink">Memory Usage</a></h2>
<p>In the worst case, the leaf nodes of a BList have only 64 children
each, rather than a full 128, meaning that memory usage is around
twice that of a best-case array implementation.  Non-leaf nodes use up
a negligible amount of additional memory, since there are at least 63
times as many leaf nodes as non-leaf nodes.</p>
<p>The existing array-based list implementation must grow and shrink as
items are added and removed.  To be efficient, it grows and shrinks
only when the list has grow or shrunk exponentially.  In the worst
case, it, too, uses twice as much memory as the best case.</p>
<p>In summary, the BList’s memory footprint is not significantly
different from the existing array-based implementation.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>If the BList is added to the collections module, backwards
compatibility is not an issue.  This section focuses on the option of
replacing the existing array-based list with the BList.  For users of
the Python interpreter, a BList has an identical interface to the
current list-implementation.  For virtually all operations, the
behavior is identical, aside from execution speed.</p>
<p>For the C API, BList has a different interface than the existing
list-implementation.  Due to its more complex structure, the BList
does not lend itself well to poking and prodding by external sources.
Thankfully, the existing list-implementation defines an API of
functions and macros for accessing data from list objects.  Google
Code Search suggests that the majority of third-party modules uses the
well-defined API rather than relying on the list’s structure
directly.  The table below summarizes the search queries and results:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Search String</th>
<th class="head">Number of Results</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td>PyList_GetItem</td>
<td>2,000</td>
</tr>
<tr class="row-odd"><td>PySequence_GetItem</td>
<td>800</td>
</tr>
<tr class="row-even"><td>PySequence_Fast_GET_ITEM</td>
<td>100</td>
</tr>
<tr class="row-odd"><td>PyList_GET_ITEM</td>
<td>400</td>
</tr>
<tr class="row-even"><td>[^a-zA-Z_]ob_item</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>This can be achieved in one of two ways:</p>
<ol class="arabic">
<li>Redefine the various accessor functions and macros in listobject.h
to access a BList instead.  The interface would be unchanged.  The
functions can easily be redefined.  The macros need a bit more care
and would have to resort to function calls for large lists.<p>The macros would need to evaluate their arguments more than once,
which could be a problem if the arguments have side effects.  A
Google Code Search for “PyList_GET_ITEM([^)]+(” found only a
handful of cases where this occurs, so the impact appears to be
low.</p>
<p>The few extension modules that use list’s undocumented structure
directly, instead of using the API, would break.  The core code
itself uses the accessor macros fairly consistently and should be
easy to port.</p>
</li>
<li>Deprecate the existing list type, but continue to include it.
Extension modules wishing to use the new BList type must do so
explicitly.  The BList C interface can be changed to match the
existing PyList interface so that a simple search-replace will be
sufficient for 99% of module writers.<p>Existing modules would continue to compile and work without change,
but they would need to make a deliberate (but small) effort to
migrate to the BList.</p>
<p>The downside of this approach is that mixing modules that use
BLists and array-based lists might lead to slow down if conversions
are frequently necessary.</p>
</li>
</ol>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementations of the BList is available for CPython at <a class="footnote-reference brackets" href="#id6" id="id3">[1]</a>.</p>
<p>The source package also includes a pure Python implementation,
originally developed as a prototype for the CPython version.
Naturally, the pure Python version is rather slow and the asymptotic
improvements don’t win out until the list is quite large.</p>
<p>When compiled with Py_DEBUG, the C implementation checks the
BList invariants when entering and exiting most functions.</p>
<p>An extensive set of test cases is also included in the source package.
The test cases include the existing Python sequence and list test
cases as a subset.  When the interpreter is built with Py_DEBUG, the
test cases also check for reference leaks.</p>
<section id="porting-to-other-python-variants">
<h3><a class="toc-backref" href="#porting-to-other-python-variants" role="doc-backlink">Porting to Other Python Variants</a></h3>
<p>If the BList is added to the collections module, other Python variants
can support it in one of three ways:</p>
<ol class="arabic simple">
<li>Make blist an alias for list.  The asymptotic performance won’t be
as good, but it’ll work.</li>
<li>Use the pure Python reference implementation.  The performance for
small lists won’t be as good, but it’ll work.</li>
<li>Port the reference implementation.</li>
</ol>
</section>
</section>
<section id="discussion">
<h2><a class="toc-backref" href="#discussion" role="doc-backlink">Discussion</a></h2>
<p>This proposal has been discussed briefly on the Python-3000 mailing
list <a class="footnote-reference brackets" href="#id8" id="id4">[3]</a>.  Although a number of people favored the proposal, there
were also some objections.  Below summarizes the pros and cons as
observed by posters to the thread.</p>
<p>General comments:</p>
<ul class="simple">
<li>Pro: Will outperform the array-based list in most cases</li>
<li>Pro: “I’ve implemented variants of this … a few different times”</li>
<li>Con: Desirability and performance in actual applications is unproven</li>
</ul>
<p>Comments on adding BList to the collections module:</p>
<ul class="simple">
<li>Pro: Matching the list-API reduces the learning curve to near-zero</li>
<li>Pro: Useful for intermediate-level users; won’t get in the way of beginners</li>
<li>Con: Proliferation of data types makes the choices for developers harder.</li>
</ul>
<p>Comments on replacing the array-based list with the BList:</p>
<ul class="simple">
<li>Con: Impact on extension modules (addressed in <a class="reference internal" href="#backwards-compatibility">Backwards
Compatibility</a>)</li>
<li>Con: The use cases where BLists are slower are important
(see <a class="reference internal" href="#use-case-trade-offs">Use Case Trade-Offs</a> for how these might be addressed).</li>
<li>Con: The array-based list code is simple and easy to maintain</li>
</ul>
<p>To assess the desirability and performance in actual applications,
Raymond Hettinger suggested releasing the BList as an extension module
(now available at <a class="footnote-reference brackets" href="#id6" id="id5">[1]</a>).  If it proves useful, he felt it would be a
strong candidate for inclusion in 2.6 as part of the collections
module.  If widely popular, then it could be considered for replacing
the array-based list, but not otherwise.</p>
<p>Guido van Rossum commented that he opposed the proliferation of data
types, but favored replacing the array-based list if backwards
compatibility could be addressed and the BList’s performance was
uniformly better.</p>
</section>
<section id="on-going-tasks">
<h2><a class="toc-backref" href="#on-going-tasks" role="doc-backlink">On-going Tasks</a></h2>
<ul class="simple">
<li>Reduce the memory footprint of small lists</li>
<li>Implement TimSort for BLists, so that best-case sorting is O(n)
instead of O(log n).</li>
<li>Implement __reversed__</li>
<li>Cache a pointer in the root to the rightmost leaf, to make LIFO
operation O(n) time.</li>
</ul>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<dt class="label" id="id6">[1]<em> (<a href='#id3'>1</a>, <a href='#id5'>2</a>) </em></dt>
<dd>Reference Implementations for C and Python:
<a class="reference external" href="http://www.python.org/pypi/blist/">http://www.python.org/pypi/blist/</a></aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<dt class="label" id="id7">[<a href="#id2">2</a>]</dt>
<dd>Empirical performance comparison between Python’s array-based
list and the blist: <a class="reference external" href="http://stutzbachenterprises.com/blist/">http://stutzbachenterprises.com/blist/</a></aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<dt class="label" id="id8">[<a href="#id4">3</a>]</dt>
<dd>Discussion on python-3000 starting at post:
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-April/006757.html">https://mail.python.org/pipermail/python-3000/2007-April/006757.html</a></aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<dt class="label" id="id9">[<a href="#id1">4</a>]</dt>
<dd>Raymond Hettinger’s feedback on python-3000:
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-May/007491.html">https://mail.python.org/pipermail/python-3000/2007-May/007491.html</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-3128.rst">https://github.com/python/peps/blob/main/peps/pep-3128.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-3128.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#rejection-notice">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#use-case-trade-offs">Use Case Trade-offs</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#memory-usage">Memory Usage</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#porting-to-other-python-variants">Porting to Other Python Variants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#on-going-tasks">On-going Tasks</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-3128.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>