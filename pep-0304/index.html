
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 304 – Controlling Generation of Bytecode Files | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0304/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 304 – Controlling Generation of Bytecode Files | peps.python.org'>
    <meta property="og:description" content="This PEP outlines a mechanism for controlling the generation and location of compiled Python bytecode files.  This idea originally arose as a patch request 1 and evolved into a discussion thread on the python-dev mailing list 2.  The introduction of an ...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0304/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP outlines a mechanism for controlling the generation and location of compiled Python bytecode files.  This idea originally arose as a patch request 1 and evolved into a discussion thread on the python-dev mailing list 2.  The introduction of an ...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 304</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 304 – Controlling Generation of Bytecode Files</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Skip Montanaro</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Removed from consideration by sponsor or authors">Withdrawn</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">22-Jan-2003</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd">27-Jan-2003, 31-Jan-2003, 17-Jun-2005</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#historical-note">Historical Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a><ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
<li><a class="reference internal" href="#locating-bytecode-files">Locating bytecode files</a></li>
<li><a class="reference internal" href="#writing-bytecode-files">Writing bytecode files</a></li>
<li><a class="reference internal" href="#defining-augmented-directories">Defining augmented directories</a></li>
<li><a class="reference internal" href="#fixing-the-location-of-the-bytecode-base">Fixing the location of the bytecode base</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#issues">Issues</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="historical-note">
<h2><a class="toc-backref" href="#historical-note" role="doc-backlink">Historical Note</a></h2>
<p>While this original PEP was withdrawn, a variant of this feature
was eventually implemented for Python 3.8 in <a class="reference external" href="https://bugs.python.org/issue33499">https://bugs.python.org/issue33499</a></p>
<p>Several of the issues and concerns originally raised in this PEP were resolved
by other changes in the intervening years:</p>
<ul class="simple">
<li>the introduction of isolated mode to handle potential security concerns</li>
<li>the switch to <code class="docutils literal notranslate"><span class="pre">importlib</span></code>, a fully import-hook based import system implementation</li>
<li><a class="pep reference internal" href="../pep-3147/" title="PEP 3147 – PYC Repository Directories">PEP 3147</a>’s change in the bytecode cache layout to use <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code>
subdirectories, including the <code class="docutils literal notranslate"><span class="pre">source_to_cache(path)</span></code> and
<code class="docutils literal notranslate"><span class="pre">cache_to_source(path)</span></code> APIs that allow the interpreter to automatically
handle the redirection to a separate cache directory</li>
</ul>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP outlines a mechanism for controlling the generation and
location of compiled Python bytecode files.  This idea originally
arose as a patch request <a class="footnote-reference brackets" href="#id7" id="id1">[1]</a> and evolved into a discussion thread on
the python-dev mailing list <a class="footnote-reference brackets" href="#id8" id="id2">[2]</a>.  The introduction of an environment
variable will allow people installing Python or Python-based
third-party packages to control whether or not bytecode files should
be generated at installation time, and if so, where they should be
written.  It will also allow users to control whether or not bytecode
files should be generated at application run-time, and if so, where
they should be written.</p>
</section>
<section id="proposal">
<h2><a class="toc-backref" href="#proposal" role="doc-backlink">Proposal</a></h2>
<p>Add a new environment variable, PYTHONBYTECODEBASE, to the mix of
environment variables which Python understands.  PYTHONBYTECODEBASE is
interpreted as follows:</p>
<ul>
<li>If not defined, Python bytecode is generated in exactly the same way
as is currently done.  sys.bytecodebase is set to the root directory
(either / on Unix and Mac OSX or the root directory of the startup
(installation???) drive – typically <code class="docutils literal notranslate"><span class="pre">C:\</span></code> – on Windows).</li>
<li>If defined and it refers to an existing directory to which the user
has write permission, sys.bytecodebase is set to that directory and
bytecode files are written into a directory structure rooted at that
location.</li>
<li>If defined but empty, sys.bytecodebase is set to None and generation
of bytecode files is suppressed altogether.</li>
<li>If defined and one of the following is true:<ul class="simple">
<li>it does not refer to a directory,</li>
<li>it refers to a directory, but not one for which the user has write
permission</li>
</ul>
<p>a warning is displayed, sys.bytecodebase is set to None and
generation of bytecode files is suppressed altogether.</p>
</li>
</ul>
<p>After startup initialization, all runtime references are to
sys.bytecodebase, not the PYTHONBYTECODEBASE environment variable.
sys.path is not modified.</p>
<p>From the above, we see sys.bytecodebase can only take on two valid
types of values: None or a string referring to a valid directory on
the system.</p>
<p>During import, this extension works as follows:</p>
<ul class="simple">
<li>The normal search for a module is conducted.  The search order is
roughly: dynamically loaded extension module, Python source file,
Python bytecode file.  The only time this mechanism comes into play
is if a Python source file is found.</li>
<li>Once we’ve found a source module, an attempt to read a byte-compiled
file in the same directory is made.  (This is the same as before.)</li>
<li>If no byte-compiled file is found, an attempt to read a
byte-compiled file from the augmented directory is made.</li>
<li>If bytecode generation is required, the generated bytecode is written
to the augmented directory if possible.</li>
</ul>
<p>Note that this PEP is explicitly <em>not</em> about providing
module-by-module or directory-by-directory control over the
disposition of bytecode files.</p>
<section id="glossary">
<h3><a class="toc-backref" href="#glossary" role="doc-backlink">Glossary</a></h3>
<ul class="simple">
<li>“bytecode base” refers to the current setting of
sys.bytecodebase.</li>
<li>“augmented directory” refers to the directory formed from the
bytecode base and the directory name of the source file.</li>
<li>PYTHONBYTECODEBASE refers to the environment variable when necessary
to distinguish it from “bytecode base”.</li>
</ul>
</section>
<section id="locating-bytecode-files">
<h3><a class="toc-backref" href="#locating-bytecode-files" role="doc-backlink">Locating bytecode files</a></h3>
<p>When the interpreter is searching for a module, it will use sys.path
as usual.  However, when a possible bytecode file is considered, an
extra probe for a bytecode file may be made.  First, a check is made
for the bytecode file using the directory in sys.path which holds the
source file (the current behavior).  If a valid bytecode file is not
found there (either one does not exist or exists but is out-of-date)
and the bytecode base is not None, a second probe is made using the
directory in sys.path prefixed appropriately by the bytecode base.</p>
</section>
<section id="writing-bytecode-files">
<h3><a class="toc-backref" href="#writing-bytecode-files" role="doc-backlink">Writing bytecode files</a></h3>
<p>When the bytecode base is not None, a new bytecode file is written to
the appropriate augmented directory, never directly to a directory in
sys.path.</p>
</section>
<section id="defining-augmented-directories">
<h3><a class="toc-backref" href="#defining-augmented-directories" role="doc-backlink">Defining augmented directories</a></h3>
<p>Conceptually, the augmented directory for a bytecode file is the
directory in which the source file exists prefixed by the bytecode
base.  In a Unix environment this would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">bytecodebase</span><span class="p">)</span>
<span class="k">if</span> <span class="n">sourcefile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">:</span> <span class="n">sourcefile</span> <span class="o">=</span> <span class="n">sourcefile</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">augdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pcb</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">sourcefile</span><span class="p">))</span>
</pre></div>
</div>
<p>On Windows, which does not have a single-rooted directory tree, the
drive letter of the directory containing the source file is treated as
a directory component after removing the trailing colon.  The
augmented directory is thus derived as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">bytecodebase</span><span class="p">)</span>
<span class="n">drive</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitdrive</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">sourcefile</span><span class="p">))</span>
<span class="n">drive</span> <span class="o">=</span> <span class="n">drive</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">augdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pcb</span><span class="p">,</span> <span class="n">drive</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fixing-the-location-of-the-bytecode-base">
<h3><a class="toc-backref" href="#fixing-the-location-of-the-bytecode-base" role="doc-backlink">Fixing the location of the bytecode base</a></h3>
<p>During program startup, the value of the PYTHONBYTECODEBASE
environment variable is made absolute, checked for validity and added
to the sys module, effectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYTHONBYTECODEBASE&quot;</span><span class="p">])</span>
<span class="n">probe</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pcb</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">open</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">bytecodebase</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">probe</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">bytecodebase</span> <span class="o">=</span> <span class="n">pcb</span>
</pre></div>
</div>
<p>This allows the user to specify the bytecode base as a relative path,
but not have it subject to changes to the current working directory
during program execution.  (I can’t imagine you’d want it to move
around during program execution.)</p>
<p>There is nothing special about sys.bytecodebase.  The user may change
it at runtime if desired, but normally it will not be modified.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>In many environments it is not possible for non-root users to write
into directories containing Python source files.  Most of the time,
this is not a problem as Python source is generally byte compiled
during installation.  However, there are situations where bytecode
files are either missing or need to be updated.  If the directory
containing the source file is not writable by the current user a
performance penalty is incurred each time a program importing the
module is run. <a class="footnote-reference brackets" href="#id9" id="id3">[3]</a> Warning messages may also be generated in certain
circumstances.  If the directory is writable, nearly simultaneous
attempts to write the bytecode file by two separate processes
may occur, resulting in file corruption. <a class="footnote-reference brackets" href="#id10" id="id4">[4]</a></p>
<p>In environments with RAM disks available, it may be desirable for
performance reasons to write bytecode files to a directory on such a
disk.  Similarly, in environments where Python source code resides on
network file systems, it may be desirable to cache bytecode files on
local disks.</p>
</section>
<section id="alternatives">
<h2><a class="toc-backref" href="#alternatives" role="doc-backlink">Alternatives</a></h2>
<p>The only other alternative proposed so far <a class="footnote-reference brackets" href="#id7" id="id5">[1]</a> seems to be to add a
-R flag to the interpreter to disable writing bytecode files
altogether.  This proposal subsumes that.  Adding a command-line
option is certainly possible, but is probably not sufficient, as the
interpreter’s command line is not readily available during
installation (early during program startup???).</p>
</section>
<section id="issues">
<h2><a class="toc-backref" href="#issues" role="doc-backlink">Issues</a></h2>
<ul class="simple">
<li>Interpretation of a module’s __file__ attribute.  I believe the
__file__ attribute of a module should reflect the true location of
the bytecode file.  If people want to locate a module’s source code,
they should use imp.find_module(module).</li>
<li>Security - What if root has PYTHONBYTECODEBASE set?  Yes, this can
present a security risk, but so can many other things the root user
does.  The root user should probably not set PYTHONBYTECODEBASE
except possibly during installation.  Still, perhaps this problem
can be minimized.  When running as root the interpreter should check
to see if PYTHONBYTECODEBASE refers to a directory which is writable
by anyone other than root.  If so, it could raise an exception or
warning and set sys.bytecodebase to None.  Or, see the next item.</li>
<li>More security - What if PYTHONBYTECODEBASE refers to a general
directory (say, /tmp)?  In this case, perhaps loading of a
preexisting bytecode file should occur only if the file is owned by
the current user or root.  (Does this matter on Windows?)</li>
<li>The interaction of this PEP with import hooks has not been
considered yet.  In fact, the best way to implement this idea might
be as an import hook.  See <a class="pep reference internal" href="../pep-0302/" title="PEP 302 – New Import Hooks">PEP 302</a>.</li>
<li>In the current (pre-<a class="pep reference internal" href="../pep-0304/" title="PEP 304 – Controlling Generation of Bytecode Files">PEP 304</a>) environment, it is safe to delete a
source file after the corresponding bytecode file has been created,
since they reside in the same directory.  With <a class="pep reference internal" href="../pep-0304/" title="PEP 304 – Controlling Generation of Bytecode Files">PEP 304</a> as currently
defined, this is not the case.  A bytecode file in the augmented
directory is only considered when the source file is present and it
thus never considered when looking for module files ending in
“.pyc”.  I think this behavior may have to change.</li>
</ul>
</section>
<section id="examples">
<h2><a class="toc-backref" href="#examples" role="doc-backlink">Examples</a></h2>
<p>In the examples which follow, the urllib source code resides in
/usr/lib/python2.3/urllib.py and /usr/lib/python2.3 is in sys.path but
is not writable by the current user.</p>
<ul class="simple">
<li>The bytecode base is /tmp.  /usr/lib/python2.3/urllib.pyc exists and
is valid.  When urllib is imported, the contents of
/usr/lib/python2.3/urllib.pyc are used.  The augmented directory is
not consulted.  No other bytecode file is generated.</li>
<li>The bytecode base is /tmp.  /usr/lib/python2.3/urllib.pyc exists,
but is out-of-date.  When urllib is imported, the generated bytecode
file is written to urllib.pyc in the augmented directory which has
the value /tmp/usr/lib/python2.3.  Intermediate directories will be
created as needed.</li>
<li>The bytecode base is None.  No urllib.pyc file is found.  When
urllib is imported, no bytecode file is written.</li>
<li>The bytecode base is /tmp.  No urllib.pyc file is found.  When
urllib is imported, the generated bytecode file is written to the
augmented directory which has the value /tmp/usr/lib/python2.3.
Intermediate directories will be created as needed.</li>
<li>At startup, PYTHONBYTECODEBASE is /tmp/foobar, which does not exist.
A warning is emitted, sys.bytecodebase is set to None and no
bytecode files are written during program execution unless
sys.bytecodebase is later changed to refer to a valid,
writable directory.</li>
<li>At startup, PYTHONBYTECODEBASE is set to /, which exists, but is not
writable by the current user.  A warning is emitted,
sys.bytecodebase is set to None and no bytecode files are
written during program execution unless sys.bytecodebase is
later changed to refer to a valid, writable directory.  Note that
even though the augmented directory constructed for a particular
bytecode file may be writable by the current user, what counts is
that the bytecode base directory itself is writable.</li>
<li>At startup PYTHONBYTECODEBASE is set to the empty string.
sys.bytecodebase is set to None.  No warning is generated, however.
If no urllib.pyc file is found when urllib is imported, no bytecode
file is written.</li>
</ul>
<p>In the Windows examples which follow, the urllib source code resides
in <code class="docutils literal notranslate"><span class="pre">C:\PYTHON22\urllib.py</span></code>.  <code class="docutils literal notranslate"><span class="pre">C:\PYTHON22</span></code> is in sys.path but is
not writable by the current user.</p>
<ul class="simple">
<li>The bytecode base is set to <code class="docutils literal notranslate"><span class="pre">C:\TEMP</span></code>.  <code class="docutils literal notranslate"><span class="pre">C:\PYTHON22\urllib.pyc</span></code>
exists and is valid.  When urllib is imported, the contents of
<code class="docutils literal notranslate"><span class="pre">C:\PYTHON22\urllib.pyc</span></code> are used.  The augmented directory is not
consulted.</li>
<li>The bytecode base is set to <code class="docutils literal notranslate"><span class="pre">C:\TEMP</span></code>.  <code class="docutils literal notranslate"><span class="pre">C:\PYTHON22\urllib.pyc</span></code>
exists, but is out-of-date.  When urllib is imported, a new bytecode
file is written to the augmented directory which has the value
<code class="docutils literal notranslate"><span class="pre">C:\TEMP\C\PYTHON22</span></code>.  Intermediate directories will be created as
needed.</li>
<li>At startup PYTHONBYTECODEBASE is set to <code class="docutils literal notranslate"><span class="pre">TEMP</span></code> and the current
working directory at application startup is <code class="docutils literal notranslate"><span class="pre">H:\NET</span></code>.  The
potential bytecode base is thus <code class="docutils literal notranslate"><span class="pre">H:\NET\TEMP</span></code>.  If this directory
exists and is writable by the current user, sys.bytecodebase will be
set to that value.  If not, a warning will be emitted and
sys.bytecodebase will be set to None.</li>
<li>The bytecode base is <code class="docutils literal notranslate"><span class="pre">C:\TEMP</span></code>.  No urllib.pyc file is found.
When urllib is imported, the generated bytecode file is written to
the augmented directory which has the value <code class="docutils literal notranslate"><span class="pre">C:\TEMP\C\PYTHON22</span></code>.
Intermediate directories will be created as needed.</li>
</ul>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>See the patch on Sourceforge. <a class="footnote-reference brackets" href="#id11" id="id6">[6]</a></p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<dt class="label" id="id7">[1]<em> (<a href='#id1'>1</a>, <a href='#id5'>2</a>) </em></dt>
<dd>patch 602345, Option for not writing py.[co] files, Klose
(<a class="reference external" href="https://bugs.python.org/issue602345">https://bugs.python.org/issue602345</a>)</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<dt class="label" id="id8">[<a href="#id2">2</a>]</dt>
<dd>python-dev thread, Disable writing .py[co], Norwitz
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-January/032270.html">https://mail.python.org/pipermail/python-dev/2003-January/032270.html</a>)</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<dt class="label" id="id9">[<a href="#id3">3</a>]</dt>
<dd>Debian bug report, Mailman is writing to /usr in cron, Wegner
(<a class="reference external" href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=96111">http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=96111</a>)</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<dt class="label" id="id10">[<a href="#id4">4</a>]</dt>
<dd>python-dev thread, Parallel pyc construction, Dubois
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-January/032060.html">https://mail.python.org/pipermail/python-dev/2003-January/032060.html</a>)</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<dt class="label" id="id11">[<a href="#id6">6</a>]</dt>
<dd>patch 677103, PYTHONBYTECODEBASE patch (PEP 304), Montanaro
(<a class="reference external" href="https://bugs.python.org/issue677103">https://bugs.python.org/issue677103</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0304.rst">https://github.com/python/peps/blob/main/peps/pep-0304.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0304.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#historical-note">Historical Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a><ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
<li><a class="reference internal" href="#locating-bytecode-files">Locating bytecode files</a></li>
<li><a class="reference internal" href="#writing-bytecode-files">Writing bytecode files</a></li>
<li><a class="reference internal" href="#defining-augmented-directories">Defining augmented directories</a></li>
<li><a class="reference internal" href="#fixing-the-location-of-the-bytecode-base">Fixing the location of the bytecode base</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#issues">Issues</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0304.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>