
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 367 – New Super | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0367/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 367 – New Super | peps.python.org'>
    <meta property="og:description" content="This PEP proposes syntactic sugar for use of the super type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0367/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes syntactic sugar for use of the super type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 367</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 367 – New Super" data-pagefind-weight="10" class="visually-hidden">PEP 367 – New Super</span>
            <section id="pep-content">
<h1 class="page-title">PEP 367 – New Super</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Calvin Spealman &lt;ironfroggy&#32;&#97;t&#32;gmail.com&gt;,
Tim Delaney &lt;timothy.c.delaney&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Replaced by another succeeding PEP">Superseded</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">28-Apr-2007</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">2.6</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072807.html" title="Python-Dev message">28-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072835.html" title="Python-Dev message">29-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072858.html" title="Python-Dev message">29-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-May/073127.html" title="Python-Dev message">14-May-2007</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#numbering-note">Numbering Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#determining-the-class-object-to-use">Determining the class object to use</a></li>
<li><a class="reference internal" href="#should-super-actually-become-a-keyword">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#closed-issues">Closed Issues</a><ul>
<li><a class="reference internal" href="#super-used-with-call-attributes">super used with __call__ attributes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#alternative-proposals">Alternative Proposals</a><ul>
<li><a class="reference internal" href="#no-changes">No Changes</a></li>
<li><a class="reference internal" href="#dynamic-attribute-on-super-type">Dynamic attribute on super type</a></li>
<li><a class="reference internal" href="#super-this-class-self">super(__this_class__, self)</a></li>
<li><a class="reference internal" href="#self-super-foo-args">self.__super__.foo(*args)</a></li>
<li><a class="reference internal" href="#super-self-args-or-super-self-args">super(self, *args) or __super__(self, *args)</a></li>
<li><a class="reference internal" href="#super-foo-self-args">super.foo(self, *args)</a></li>
<li><a class="reference internal" href="#super-or-super">super or super()</a></li>
<li><a class="reference internal" href="#super-p-kw">super(*p, **kw)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#history">History</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="numbering-note">
<h2><a class="toc-backref" href="#numbering-note" role="doc-backlink">Numbering Note</a></h2>
<p>This PEP has been renumbered to <a class="pep reference internal" href="../pep-3135/" title="PEP 3135 – New Super">PEP 3135</a>.  The text below is the last
version submitted under the old number.</p>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes syntactic sugar for use of the <code class="docutils literal notranslate"><span class="pre">super</span></code> type to automatically
construct instances of the super type binding to the class that a method was
defined in, and the instance (or class object for classmethods) that the method
is currently acting upon.</p>
<p>The premise of the new super usage suggested is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>to replace the old:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>and the current <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code> be aliased to <code class="docutils literal notranslate"><span class="pre">__builtin__.__super__</span></code>
(with <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code> to be removed in Python 3.0).</p>
<p>It is further proposed that assignment to <code class="docutils literal notranslate"><span class="pre">super</span></code> become a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>,
similar to the behaviour of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The current usage of super requires an explicit passing of both the class and
instance it must operate from, requiring a breaking of the DRY (Don’t Repeat
Yourself) rule. This hinders any change in class name, and is often considered
a wart by many.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Within the specification section, some special terminology will be used to
distinguish similar and closely related concepts. “super type” will refer to
the actual builtin type named “super”. A “super instance” is simply an instance
of the super type, which is associated with a class and possibly with an
instance of that class.</p>
<p>Because the new <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics are not backwards compatible with Python
2.5, the new semantics will require a <code class="docutils literal notranslate"><span class="pre">__future__</span></code> import:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">new_super</span>
</pre></div>
</div>
<p>The current <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code> will be aliased to <code class="docutils literal notranslate"><span class="pre">__builtin__.__super__</span></code>.
This will occur regardless of whether the new <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics are active.
It is not possible to simply rename <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code>, as that would affect
modules that do not use the new <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics. In Python 3.0 it is
proposed that the name <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code> will be removed.</p>
<p>Replacing the old usage of super, calls to the next class in the MRO (method
resolution order) can be made without explicitly creating a <code class="docutils literal notranslate"><span class="pre">super</span></code>
instance (although doing so will still be supported via <code class="docutils literal notranslate"><span class="pre">__super__</span></code>). Every
function will have an implicit local named <code class="docutils literal notranslate"><span class="pre">super</span></code>. This name behaves
identically to a normal local, including use by inner functions via a cell,
with the following exceptions:</p>
<ol class="arabic simple">
<li>Assigning to the name <code class="docutils literal notranslate"><span class="pre">super</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> at compile time;</li>
<li>Calling a static method or normal function that accesses the name <code class="docutils literal notranslate"><span class="pre">super</span></code>
will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> at runtime.</li>
</ol>
<p>Every function that uses the name <code class="docutils literal notranslate"><span class="pre">super</span></code>, or has an inner function that
uses the name <code class="docutils literal notranslate"><span class="pre">super</span></code>, will include a preamble that performs the equivalent
of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span> <span class="o">=</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">__super__</span><span class="p">(</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">instance</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&lt;class&gt;</span></code> is the class that the method was defined in, and
<code class="docutils literal notranslate"><span class="pre">&lt;instance&gt;</span></code> is the first parameter of the method (normally <code class="docutils literal notranslate"><span class="pre">self</span></code> for
instance methods, and <code class="docutils literal notranslate"><span class="pre">cls</span></code> for class methods). For static methods and normal
functions, <code class="docutils literal notranslate"><span class="pre">&lt;class&gt;</span></code> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>, resulting in a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> being
raised during the preamble.</p>
<p>Note: The relationship between <code class="docutils literal notranslate"><span class="pre">super</span></code> and <code class="docutils literal notranslate"><span class="pre">__super__</span></code> is similar to that
between <code class="docutils literal notranslate"><span class="pre">import</span></code> and <code class="docutils literal notranslate"><span class="pre">__import__</span></code>.</p>
<p>Much of this was discussed in the thread of the python-dev list, “Fixing super
anyone?” <a class="footnote-reference brackets" href="#id3" id="id1">[1]</a>.</p>
<section id="open-issues">
<h3><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h3>
<section id="determining-the-class-object-to-use">
<h4><a class="toc-backref" href="#determining-the-class-object-to-use" role="doc-backlink">Determining the class object to use</a></h4>
<p>The exact mechanism for associating the method with the defining class is not
specified in this PEP, and should be chosen for maximum performance. For
CPython, it is suggested that the class instance be held in a C-level variable
on the function object which is bound to one of <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (not part of a class),
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code> (static method) or a class object (instance or class method).</p>
</section>
<section id="should-super-actually-become-a-keyword">
<h4><a class="toc-backref" href="#should-super-actually-become-a-keyword" role="doc-backlink">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></h4>
<p>With this proposal, <code class="docutils literal notranslate"><span class="pre">super</span></code> would become a keyword to the same extent that
<code class="docutils literal notranslate"><span class="pre">None</span></code> is a keyword. It is possible that further restricting the <code class="docutils literal notranslate"><span class="pre">super</span></code>
name may simplify implementation, however some are against the actual
keyword-ization of super. The simplest solution is often the correct solution
and the simplest solution may well not be adding additional keywords to the
language when they are not needed. Still, it may solve other open issues.</p>
</section>
</section>
<section id="closed-issues">
<h3><a class="toc-backref" href="#closed-issues" role="doc-backlink">Closed Issues</a></h3>
<section id="super-used-with-call-attributes">
<h4><a class="toc-backref" href="#super-used-with-call-attributes" role="doc-backlink">super used with __call__ attributes</a></h4>
<p>It was considered that it might be a problem that instantiating super instances
the classic way, because calling it would lookup the __call__ attribute and
thus try to perform an automatic super lookup to the next class in the MRO.
However, this was found to be false, because calling an object only looks up
the __call__ method directly on the object’s type. The following example shows
this in action.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;__call__&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;__getattribute__&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">a</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="fm">__call__</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;__getattribute__&#39;</span>
</pre></div>
</div>
<p>In any case, with the renaming of <code class="docutils literal notranslate"><span class="pre">__builtin__.super</span></code> to
<code class="docutils literal notranslate"><span class="pre">__builtin__.__super__</span></code> this issue goes away entirely.</p>
</section>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>It is impossible to implement the above specification entirely in Python. This
reference implementation has the following differences to the specification:</p>
<ol class="arabic simple">
<li>New <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics are implemented using bytecode hacking.</li>
<li>Assignment to <code class="docutils literal notranslate"><span class="pre">super</span></code> is not a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>. Also see point #4.</li>
<li>Classes must either use the metaclass <code class="docutils literal notranslate"><span class="pre">autosuper_meta</span></code> or inherit from
the base class <code class="docutils literal notranslate"><span class="pre">autosuper</span></code> to acquire the new <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics.</li>
<li><code class="docutils literal notranslate"><span class="pre">super</span></code> is not an implicit local variable. In particular, for inner
functions to be able to use the super instance, there must be an assignment
of the form <code class="docutils literal notranslate"><span class="pre">super</span> <span class="pre">=</span> <span class="pre">super</span></code> in the method.</li>
</ol>
<p>The reference implementation assumes that it is being run on Python 2.5+.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># autosuper.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">array</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dis</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">new</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">__builtin__</span>
<span class="n">__builtin__</span><span class="o">.</span><span class="n">__super__</span> <span class="o">=</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">super</span>
<span class="k">del</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">super</span>

<span class="c1"># We need these for modifying bytecode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">opcode</span><span class="w"> </span><span class="kn">import</span> <span class="n">opmap</span><span class="p">,</span> <span class="n">HAVE_ARGUMENT</span><span class="p">,</span> <span class="n">EXTENDED_ARG</span>

<span class="n">LOAD_GLOBAL</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_GLOBAL&#39;</span><span class="p">]</span>
<span class="n">LOAD_NAME</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_NAME&#39;</span><span class="p">]</span>
<span class="n">LOAD_CONST</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_CONST&#39;</span><span class="p">]</span>
<span class="n">LOAD_FAST</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_FAST&#39;</span><span class="p">]</span>
<span class="n">LOAD_ATTR</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_ATTR&#39;</span><span class="p">]</span>
<span class="n">STORE_FAST</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;STORE_FAST&#39;</span><span class="p">]</span>
<span class="n">LOAD_DEREF</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;LOAD_DEREF&#39;</span><span class="p">]</span>
<span class="n">STORE_DEREF</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;STORE_DEREF&#39;</span><span class="p">]</span>
<span class="n">CALL_FUNCTION</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;CALL_FUNCTION&#39;</span><span class="p">]</span>
<span class="n">STORE_GLOBAL</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;STORE_GLOBAL&#39;</span><span class="p">]</span>
<span class="n">DUP_TOP</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;DUP_TOP&#39;</span><span class="p">]</span>
<span class="n">POP_TOP</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;POP_TOP&#39;</span><span class="p">]</span>
<span class="n">NOP</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;NOP&#39;</span><span class="p">]</span>
<span class="n">JUMP_FORWARD</span> <span class="o">=</span> <span class="n">opmap</span><span class="p">[</span><span class="s1">&#39;JUMP_FORWARD&#39;</span><span class="p">]</span>
<span class="n">ABSOLUTE_TARGET</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">hasjabs</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_oparg</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">opcode_pos</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">code</span><span class="p">[</span><span class="n">opcode_pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">opcode_pos</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_bind_autosuper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="n">co</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_code</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_name</span>
    <span class="n">newcode</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">co</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
    <span class="n">codelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newcode</span><span class="p">)</span>
    <span class="n">newconsts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">co_consts</span><span class="p">)</span>
    <span class="n">newvarnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>

    <span class="c1"># Check if the global &#39;super&#39; keyword is already present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sn_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">co_names</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">sn_pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Check if the varname &#39;super&#39; keyword is already present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sv_pos</span> <span class="o">=</span> <span class="n">newvarnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">sv_pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Check if the cellvar &#39;super&#39; keyword is already present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sc_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">co_cellvars</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">sc_pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># If &#39;super&#39; isn&#39;t used anywhere in the function, we don&#39;t have anything to do</span>
    <span class="k">if</span> <span class="n">sn_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sv_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sc_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="n">c_pos</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">s_pos</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Check if the &#39;cls_name&#39; and &#39;super&#39; objects are already in the constants</span>
    <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">newconsts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="n">c_pos</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">__super__</span><span class="p">:</span>
            <span class="n">s_pos</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">n_pos</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="c1"># Add in any missing objects to constants and varnames</span>
    <span class="k">if</span> <span class="n">c_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">c_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newconsts</span><span class="p">)</span>
        <span class="n">newconsts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newconsts</span><span class="p">)</span>
        <span class="n">newconsts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">s_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newconsts</span><span class="p">)</span>
        <span class="n">newconsts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__super__</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sv_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sv_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newvarnames</span><span class="p">)</span>
        <span class="n">newvarnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">)</span>

    <span class="c1"># This goes at the start of the function. It is:</span>
    <span class="c1">#</span>
    <span class="c1">#   super = __super__(cls, self)</span>
    <span class="c1">#</span>
    <span class="c1"># If &#39;super&#39; is a cell variable, we store to both the</span>
    <span class="c1"># local and cell variables (i.e. STORE_FAST and STORE_DEREF).</span>
    <span class="c1">#</span>
    <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">LOAD_CONST</span><span class="p">,</span> <span class="n">s_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">s_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">LOAD_CONST</span><span class="p">,</span> <span class="n">c_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">c_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">LOAD_FAST</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">CALL_FUNCTION</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">sc_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># &#39;super&#39; is not a cell variable - we can just use the local variable</span>
        <span class="n">preamble</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">STORE_FAST</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If &#39;super&#39; is a cell variable, we need to handle LOAD_DEREF.</span>
        <span class="n">preamble</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">DUP_TOP</span><span class="p">,</span>
            <span class="n">STORE_FAST</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
            <span class="n">STORE_DEREF</span><span class="p">,</span> <span class="n">sc_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">sc_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
        <span class="p">]</span>

    <span class="n">preamble</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">preamble</span><span class="p">)</span>

    <span class="c1"># Bytecode for loading the local &#39;super&#39; variable.</span>
    <span class="n">load_super</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">LOAD_FAST</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">sv_pos</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
    <span class="p">])</span>

    <span class="n">preamble_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">preamble</span><span class="p">)</span>
    <span class="n">need_preamble</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codelen</span><span class="p">:</span>
        <span class="n">opcode</span> <span class="o">=</span> <span class="n">newcode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">need_load</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">remove_store</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">EXTENDED_ARG</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot use &#39;super&#39; in function with EXTENDED_ARG opcode&quot;</span><span class="p">)</span>

        <span class="c1"># If the opcode is an absolute target it needs to be adjusted</span>
        <span class="c1"># to take into account the preamble.</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">ABSOLUTE_TARGET</span><span class="p">:</span>
            <span class="n">oparg</span> <span class="o">=</span> <span class="n">_oparg</span><span class="p">(</span><span class="n">newcode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">preamble_len</span>
            <span class="n">newcode</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">oparg</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
            <span class="n">newcode</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">oparg</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>

        <span class="c1"># If LOAD_GLOBAL(super) or LOAD_NAME(super) then we want to change it into</span>
        <span class="c1"># LOAD_FAST(super)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">LOAD_GLOBAL</span> <span class="ow">or</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">LOAD_NAME</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_oparg</span><span class="p">(</span><span class="n">newcode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">sn_pos</span><span class="p">:</span>
            <span class="n">need_preamble</span> <span class="o">=</span> <span class="n">need_load</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># If LOAD_FAST(super) then we just need to add the preamble</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">LOAD_FAST</span> <span class="ow">and</span> <span class="n">_oparg</span><span class="p">(</span><span class="n">newcode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">sv_pos</span><span class="p">:</span>
            <span class="n">need_preamble</span> <span class="o">=</span> <span class="n">need_load</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># If LOAD_DEREF(super) then we change it into LOAD_FAST(super) because</span>
        <span class="c1"># it&#39;s slightly faster.</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">LOAD_DEREF</span> <span class="ow">and</span> <span class="n">_oparg</span><span class="p">(</span><span class="n">newcode</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">sc_pos</span><span class="p">:</span>
            <span class="n">need_preamble</span> <span class="o">=</span> <span class="n">need_load</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">need_load</span><span class="p">:</span>
            <span class="n">newcode</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">load_super</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">opcode</span> <span class="o">&gt;=</span> <span class="n">HAVE_ARGUMENT</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="c1"># No changes needed - get out.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">need_preamble</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="c1"># Our preamble will have 3 things on the stack</span>
    <span class="n">co_stacksize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">co</span><span class="o">.</span><span class="n">co_stacksize</span><span class="p">)</span>

    <span class="c1"># Conceptually, our preamble is on the `def` line.</span>
    <span class="n">co_lnotab</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">co</span><span class="o">.</span><span class="n">co_lnotab</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">co_lnotab</span><span class="p">:</span>
        <span class="n">co_lnotab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">preamble_len</span>

    <span class="n">co_lnotab</span> <span class="o">=</span> <span class="n">co_lnotab</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>

    <span class="c1"># Our code consists of the preamble and the modified code.</span>
    <span class="n">codestr</span> <span class="o">=</span> <span class="p">(</span><span class="n">preamble</span> <span class="o">+</span> <span class="n">newcode</span><span class="p">)</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>

    <span class="n">codeobj</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">code</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newvarnames</span><span class="p">),</span> <span class="n">co_stacksize</span><span class="p">,</span>
                       <span class="n">co</span><span class="o">.</span><span class="n">co_flags</span><span class="p">,</span> <span class="n">codestr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newconsts</span><span class="p">),</span> <span class="n">co</span><span class="o">.</span><span class="n">co_names</span><span class="p">,</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="n">newvarnames</span><span class="p">),</span> <span class="n">co</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span> <span class="n">co</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span>
                       <span class="n">co</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">,</span> <span class="n">co_lnotab</span><span class="p">,</span> <span class="n">co</span><span class="o">.</span><span class="n">co_freevars</span><span class="p">,</span>
                       <span class="n">co</span><span class="o">.</span><span class="n">co_cellvars</span><span class="p">)</span>

    <span class="n">func</span><span class="o">.</span><span class="n">func_code</span> <span class="o">=</span> <span class="n">codeobj</span>
    <span class="n">func</span><span class="o">.</span><span class="n">func_class</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="k">class</span><span class="w"> </span><span class="nc">autosuper_meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">UnboundMethodType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">UnboundMethodType</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">UnboundMethodType</span><span class="p">):</span>
                <span class="n">_bind_autosuper</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">im_func</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">autosuper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">autosuper_meta</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">(</span><span class="n">autosuper</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;A&#39;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;B&#39;</span> <span class="o">+</span> <span class="nb">super</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">():</span>
                <span class="k">return</span> <span class="s1">&#39;C&#39;</span> <span class="o">+</span> <span class="nb">super</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>

            <span class="c1"># Needed to put &#39;super&#39; into a cell</span>
            <span class="nb">super</span> <span class="o">=</span> <span class="nb">super</span>
            <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="s1">&#39;D&#39;</span> <span class="o">+</span> <span class="nb">super</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;DBCA&#39;</span>
</pre></div>
</div>
<p>Disassembly of B.f and C.f reveals the different preambles used when <code class="docutils literal notranslate"><span class="pre">super</span></code>
is simply a local variable compared to when it is used by an inner function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

<span class="go">214           0 LOAD_CONST               4 (&lt;type &#39;super&#39;&gt;)</span>
<span class="go">              3 LOAD_CONST               2 (&lt;class &#39;__main__.B&#39;&gt;)</span>
<span class="go">              6 LOAD_FAST                0 (self)</span>
<span class="go">              9 CALL_FUNCTION            2</span>
<span class="go">             12 STORE_FAST               1 (super)</span>

<span class="go">215          15 LOAD_CONST               1 (&#39;B&#39;)</span>
<span class="go">             18 LOAD_FAST                1 (super)</span>
<span class="go">             21 LOAD_ATTR                1 (f)</span>
<span class="go">             24 CALL_FUNCTION            0</span>
<span class="go">             27 BINARY_ADD</span>
<span class="go">             28 RETURN_VALUE</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

<span class="go">218           0 LOAD_CONST               4 (&lt;type &#39;super&#39;&gt;)</span>
<span class="go">              3 LOAD_CONST               2 (&lt;class &#39;__main__.C&#39;&gt;)</span>
<span class="go">              6 LOAD_FAST                0 (self)</span>
<span class="go">              9 CALL_FUNCTION            2</span>
<span class="go">             12 DUP_TOP</span>
<span class="go">             13 STORE_FAST               1 (super)</span>
<span class="go">             16 STORE_DEREF              0 (super)</span>

<span class="go">219          19 LOAD_CLOSURE             0 (super)</span>
<span class="go">             22 LOAD_CONST               1 (&lt;code object inner at 00C160A0, file &quot;autosuper.py&quot;, line 219&gt;)</span>
<span class="go">             25 MAKE_CLOSURE             0</span>
<span class="go">             28 STORE_FAST               2 (inner)</span>

<span class="go">223          31 LOAD_FAST                1 (super)</span>
<span class="go">             34 STORE_DEREF              0 (super)</span>

<span class="go">224          37 LOAD_FAST                2 (inner)</span>
<span class="go">             40 CALL_FUNCTION            0</span>
<span class="go">             43 RETURN_VALUE</span>
</pre></div>
</div>
<p>Note that in the final implementation, the preamble would not be part of the
bytecode of the method, but would occur immediately following unpacking of
parameters.</p>
</section>
<section id="alternative-proposals">
<h2><a class="toc-backref" href="#alternative-proposals" role="doc-backlink">Alternative Proposals</a></h2>
<section id="no-changes">
<h3><a class="toc-backref" href="#no-changes" role="doc-backlink">No Changes</a></h3>
<p>Although its always attractive to just keep things how they are, people have
sought a change in the usage of super calling for some time, and for good
reason, all mentioned previously.</p>
<ul class="simple">
<li>Decoupling from the class name (which might not even be bound to the
right class anymore!)</li>
<li>Simpler looking, cleaner super calls would be better</li>
</ul>
</section>
<section id="dynamic-attribute-on-super-type">
<h3><a class="toc-backref" href="#dynamic-attribute-on-super-type" role="doc-backlink">Dynamic attribute on super type</a></h3>
<p>The proposal adds a dynamic attribute lookup to the super type, which will
automatically determine the proper class and instance parameters. Each super
attribute lookup identifies these parameters and performs the super lookup on
the instance, as the current super implementation does with the explicit
invocation of a super instance upon a class and instance.</p>
<p>This proposal relies on sys._getframe(), which is not appropriate for anything
except a prototype implementation.</p>
</section>
<section id="super-this-class-self">
<h3><a class="toc-backref" href="#super-this-class-self" role="doc-backlink">super(__this_class__, self)</a></h3>
<p>This is nearly an anti-proposal, as it basically relies on the acceptance of
the __this_class__ PEP, which proposes a special name that would always be
bound to the class within which it is used. If that is accepted, __this_class__
could simply be used instead of the class’ name explicitly, solving the name
binding issues <a class="footnote-reference brackets" href="#id4" id="id2">[2]</a>.</p>
</section>
<section id="self-super-foo-args">
<h3><a class="toc-backref" href="#self-super-foo-args" role="doc-backlink">self.__super__.foo(*args)</a></h3>
<p>The __super__ attribute is mentioned in this PEP in several places, and could
be a candidate for the complete solution, actually using it explicitly instead
of any super usage directly. However, double-underscore names are usually an
internal detail, and attempted to be kept out of everyday code.</p>
</section>
<section id="super-self-args-or-super-self-args">
<h3><a class="toc-backref" href="#super-self-args-or-super-self-args" role="doc-backlink">super(self, *args) or __super__(self, *args)</a></h3>
<p>This solution only solves the problem of the type indication, does not handle
differently named super methods, and is explicit about the name of the
instance. It is less flexible without being able to enacted on other method
names, in cases where that is needed. One use case this fails is where a
base-class has a factory classmethod and a subclass has two factory
classmethods, both of which needing to properly make super calls to the one
in the base-class.</p>
</section>
<section id="super-foo-self-args">
<h3><a class="toc-backref" href="#super-foo-self-args" role="doc-backlink">super.foo(self, *args)</a></h3>
<p>This variation actually eliminates the problems with locating the proper
instance, and if any of the alternatives were pushed into the spotlight, I
would want it to be this one.</p>
</section>
<section id="super-or-super">
<h3><a class="toc-backref" href="#super-or-super" role="doc-backlink">super or super()</a></h3>
<p>This proposal leaves no room for different names, signatures, or application
to other classes, or instances. A way to allow some similar use alongside the
normal proposal would be favorable, encouraging good design of multiple
inheritance trees and compatible methods.</p>
</section>
<section id="super-p-kw">
<h3><a class="toc-backref" href="#super-p-kw" role="doc-backlink">super(*p, **kw)</a></h3>
<p>There has been the proposal that directly calling <code class="docutils literal notranslate"><span class="pre">super(*p,</span> <span class="pre">**kw)</span></code> would
be equivalent to calling the method on the <code class="docutils literal notranslate"><span class="pre">super</span></code> object with the same name
as the method currently being executed i.e. the following two methods would be
equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="nb">super</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>There is strong sentiment for and against this, but implementation and style
concerns are obvious. Guido has suggested that this should be excluded from
this PEP on the principle of KISS (Keep It Simple Stupid).</p>
</section>
</section>
<section id="history">
<h2><a class="toc-backref" href="#history" role="doc-backlink">History</a></h2>
<dl class="simple">
<dt>29-Apr-2007 - Changed title from “Super As A Keyword” to “New Super”</dt><dd><ul class="simple">
<li>Updated much of the language and added a terminology section
for clarification in confusing places.</li>
<li>Added reference implementation and history sections.</li>
</ul>
</dd>
<dt>06-May-2007 - Updated by Tim Delaney to reflect discussions on the python-3000</dt><dd>and python-dev mailing lists.</dd>
</dl>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<dt class="label" id="id3">[<a href="#id1">1</a>]</dt>
<dd>Fixing super anyone?
(<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-April/006667.html">https://mail.python.org/pipermail/python-3000/2007-April/006667.html</a>)</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<dt class="label" id="id4">[<a href="#id2">2</a>]</dt>
<dd>PEP 3130: Access to Module/Class/Function Currently Being Defined (this)
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2007-April/000542.html">https://mail.python.org/pipermail/python-ideas/2007-April/000542.html</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0367.rst">https://github.com/python/peps/blob/main/peps/pep-0367.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0367.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#numbering-note">Numbering Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#determining-the-class-object-to-use">Determining the class object to use</a></li>
<li><a class="reference internal" href="#should-super-actually-become-a-keyword">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#closed-issues">Closed Issues</a><ul>
<li><a class="reference internal" href="#super-used-with-call-attributes">super used with __call__ attributes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#alternative-proposals">Alternative Proposals</a><ul>
<li><a class="reference internal" href="#no-changes">No Changes</a></li>
<li><a class="reference internal" href="#dynamic-attribute-on-super-type">Dynamic attribute on super type</a></li>
<li><a class="reference internal" href="#super-this-class-self">super(__this_class__, self)</a></li>
<li><a class="reference internal" href="#self-super-foo-args">self.__super__.foo(*args)</a></li>
<li><a class="reference internal" href="#super-self-args-or-super-self-args">super(self, *args) or __super__(self, *args)</a></li>
<li><a class="reference internal" href="#super-foo-self-args">super.foo(self, *args)</a></li>
<li><a class="reference internal" href="#super-or-super">super or super()</a></li>
<li><a class="reference internal" href="#super-p-kw">super(*p, **kw)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#history">History</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0367.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>