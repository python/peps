
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 573 – Module State Access from C Extension Methods | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0573/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 573 – Module State Access from C Extension Methods | peps.python.org'>
    <meta property="og:description" content="This PEP proposes to add a way for CPython extension methods to access context, such as the state of the modules they are defined in.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0573/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes to add a way for CPython extension methods to access context, such as the state of the modules they are defined in.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 573</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 573 – Module State Access from C Extension Methods</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Petr Viktorin &lt;encukou&#32;&#97;t&#32;gmail.com&gt;,
Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;,
Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;,
Marcel Plch &lt;gmarcel.plch&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">BDFL-Delegate<span class="colon">:</span></dt>
<dd class="field-even">Stefan Behnel</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/import-sig/">Import-SIG list</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">02-Jun-2016</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.9</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a><ul>
<li><a class="reference internal" href="#process-global-state">Process-Global State</a></li>
<li><a class="reference internal" href="#per-module-state">Per-module State</a></li>
<li><a class="reference internal" href="#static-type">Static Type</a></li>
<li><a class="reference internal" href="#heap-type">Heap Type</a></li>
<li><a class="reference internal" href="#defining-class">Defining Class</a></li>
<li><a class="reference internal" href="#c-api">C-API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a><ul>
<li><a class="reference internal" href="#slot-methods">Slot methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#adding-module-references-to-heap-types">Adding module references to heap types</a></li>
<li><a class="reference internal" href="#passing-the-defining-class-to-extension-methods">Passing the defining class to extension methods</a></li>
<li><a class="reference internal" href="#argument-clinic">Argument Clinic</a></li>
<li><a class="reference internal" href="#helpers">Helpers</a></li>
<li><a class="reference internal" href="#modules-converted-in-the-initial-implementation">Modules Converted in the Initial Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-api-changes-and-additions">Summary of API Changes and Additions</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#possible-future-extensions">Possible Future Extensions</a><ul>
<li><a class="reference internal" href="#id5">Slot methods</a></li>
<li><a class="reference internal" href="#easy-creation-of-types-with-module-references">Easy creation of types with module references</a></li>
<li><a class="reference internal" href="#optimization">Optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes to add a way for CPython extension methods to access context,
such as the state of the modules they are defined in.</p>
<p>This will allow extension methods to use direct pointer dereferences
rather than PyState_FindModule for looking up module state, reducing or
eliminating the performance cost of using module-scoped state over process
global state.</p>
<p>This fixes one of the remaining roadblocks for adoption of <a class="pep reference internal" href="../pep-3121/" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a> (Extension
module initialization and finalization) and <a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a>
(Multi-phase extension module initialization).</p>
<p>While this PEP takes an additional step towards fully solving the problems that
<a class="pep reference internal" href="../pep-3121/" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a> and <a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a> started tackling, it does not attempt to resolve <em>all</em>
remaining concerns. In particular, access to the module state
from slot methods (<code class="docutils literal notranslate"><span class="pre">nb_add</span></code>, etc) is not solved.</p>
</section>
<section id="terminology">
<h2><a class="toc-backref" href="#terminology" role="doc-backlink">Terminology</a></h2>
<section id="process-global-state">
<h3><a class="toc-backref" href="#process-global-state" role="doc-backlink">Process-Global State</a></h3>
<p>C-level static variables. Since this is very low-level
memory storage, it must be managed carefully.</p>
</section>
<section id="per-module-state">
<h3><a class="toc-backref" href="#per-module-state" role="doc-backlink">Per-module State</a></h3>
<p>State local to a module object, allocated dynamically as part of a
module object’s initialization. This isolates the state from other
instances of the module (including those in other subinterpreters).</p>
<p>Accessed by <code class="docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code>.</p>
</section>
<section id="static-type">
<h3><a class="toc-backref" href="#static-type" role="doc-backlink">Static Type</a></h3>
<p>A type object defined as a C-level static variable, i.e. a compiled-in type
object.</p>
<p>A static type needs to be shared between module instances and has no
information of what module it belongs to.
Static types do not have <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> (although their instances might).</p>
</section>
<section id="heap-type">
<h3><a class="toc-backref" href="#heap-type" role="doc-backlink">Heap Type</a></h3>
<p>A type object created at run time.</p>
</section>
<section id="defining-class">
<h3><a class="toc-backref" href="#defining-class" role="doc-backlink">Defining Class</a></h3>
<p>The defining class of a method (either bound or unbound) is the class on which
the method was defined.
A class that merely inherits the method from its base is not the defining class.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">int</span></code> is the defining class of <code class="docutils literal notranslate"><span class="pre">True.to_bytes</span></code>,
<code class="docutils literal notranslate"><span class="pre">True.__floor__</span></code> and <code class="docutils literal notranslate"><span class="pre">int.__repr__</span></code>.</p>
<p>In C, the defining class is the one defined with the corresponding
<code class="docutils literal notranslate"><span class="pre">tp_methods</span></code> or “tp slots” <a class="footnote-reference brackets" href="#tp-slots" id="id1">[1]</a> entry.
For methods defined in Python, the defining class is saved in the
<code class="docutils literal notranslate"><span class="pre">__class__</span></code> closure cell.</p>
</section>
<section id="c-api">
<h3><a class="toc-backref" href="#c-api" role="doc-backlink">C-API</a></h3>
<p>The “Python/C API” as described in Python documentation.
CPython implements the C-API, but other implementations exist.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p><a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a> introduced a new way to initialize extension modules, which brings
several advantages to extensions that implement it:</p>
<ul class="simple">
<li>The extension modules behave more like their Python counterparts.</li>
<li>The extension modules can easily support loading into pre-existing
module objects, which paves the way for extension module support for
<code class="docutils literal notranslate"><span class="pre">runpy</span></code> or for systems that enable extension module reloading.</li>
<li>Loading multiple modules from the same extension is possible, which
makes it possible to test module isolation (a key feature for proper
sub-interpreter support) from a single interpreter.</li>
</ul>
<p>The biggest hurdle for adoption of <a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a> is allowing access to module state
from methods of extension types.
Currently, the way to access this state from extension methods is by looking up
the module via <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> (in contrast to module level functions in
extension modules, which receive a module reference as an argument).
However, <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> queries the thread-local state, making it
relatively costly compared to C level process global access and consequently
deterring module authors from using it.</p>
<p>Also, <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> relies on the assumption that in each
subinterpreter, there is at most one module corresponding to
a given <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>.  This assumption does not hold for modules that use
<a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a>’s multi-phase initialization, so <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> is unavailable
for these modules.</p>
<p>A faster, safer way of accessing module-level state from extension methods
is needed.</p>
</section>
<section id="background">
<h2><a class="toc-backref" href="#background" role="doc-backlink">Background</a></h2>
<p>The implementation of a Python method may need access to one or more of
the following pieces of information:</p>
<ul class="simple">
<li>The instance it is called on (<code class="docutils literal notranslate"><span class="pre">self</span></code>)</li>
<li>The underlying function</li>
<li>The <em>defining class</em>, i. e. the class the method was defined in</li>
<li>The corresponding module</li>
<li>The module state</li>
</ul>
<p>In Python code, the Python-level equivalents may be retrieved as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">module_globals</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
        <span class="n">module_object</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>  <span class="c1"># (1)</span>
        <span class="n">underlying_function</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="n">meth</span>         <span class="c1"># (1)</span>
        <span class="n">defining_class</span> <span class="o">=</span> <span class="n">Foo</span>                   <span class="c1"># (1)</span>
        <span class="n">defining_class</span> <span class="o">=</span> <span class="vm">__class__</span>             <span class="c1"># (2)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The defining class is not <code class="docutils literal notranslate"><span class="pre">type(self)</span></code>, since <code class="docutils literal notranslate"><span class="pre">type(self)</span></code> might
be a subclass of <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p>
</div>
<p>The statements marked (1) implicitly rely on name-based lookup via the
function’s <code class="docutils literal notranslate"><span class="pre">__globals__</span></code>: either the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> attribute to access the defining
class and Python function object, or <code class="docutils literal notranslate"><span class="pre">__name__</span></code> to find the module object in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<p>In Python code, this is feasible, as <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> is set appropriately when
the function definition is executed, and even if the namespace has been
manipulated to return a different object, at worst an exception will be raised.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__class__</span></code> closure, (2), is a safer way to get the defining class, but it
still relies on <code class="docutils literal notranslate"><span class="pre">__closure__</span></code> being set appropriately.</p>
<p>By contrast, extension methods are typically implemented as normal C functions.
This means that they only have access to their arguments and C level thread-local
and process-global states. Traditionally, many extension modules have stored
their shared state in C-level process globals, causing problems when:</p>
<ul class="simple">
<li>running multiple initialize/finalize cycles in the same process</li>
<li>reloading modules (e.g. to test conditional imports)</li>
<li>loading extension modules in subinterpreters</li>
</ul>
<p><a class="pep reference internal" href="../pep-3121/" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a> attempted to resolve this by offering the <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> API,
but this still has significant problems when it comes to extension methods
(rather than module level functions):</p>
<ul class="simple">
<li>it is markedly slower than directly accessing C-level process-global state</li>
<li>there is still some inherent reliance on process global state that means it
still doesn’t reliably handle module reloading</li>
</ul>
<p>It’s also the case that when looking up a C-level struct such as module state,
supplying an unexpected object layout can crash the interpreter, so it’s
significantly more important to ensure that extension methods receive the kind
of object they expect.</p>
</section>
<section id="proposal">
<h2><a class="toc-backref" href="#proposal" role="doc-backlink">Proposal</a></h2>
<p>Currently, a bound extension method (<code class="docutils literal notranslate"><span class="pre">PyCFunction</span></code> or
<code class="docutils literal notranslate"><span class="pre">PyCFunctionWithKeywords</span></code>) receives only <code class="docutils literal notranslate"><span class="pre">self</span></code>, and (if applicable) the
supplied positional and keyword arguments.</p>
<p>While module-level extension functions already receive access to the defining
module object via their <code class="docutils literal notranslate"><span class="pre">self</span></code> argument, methods of extension types don’t have
that luxury: they receive the bound instance via <code class="docutils literal notranslate"><span class="pre">self</span></code>, and hence have no
direct access to the defining class or the module level state.</p>
<p>The additional module level context described above can be made available with
two changes.
Both additions are optional; extension authors need to opt in to start
using them:</p>
<ul>
<li>Add a pointer to the module to heap type objects.</li>
<li>Pass the defining class to the underlying C function.<p>In CPython, the defining class is readily available at the time the built-in
method object (<code class="docutils literal notranslate"><span class="pre">PyCFunctionObject</span></code>) is created, so it can be stored
in a new struct that extends <code class="docutils literal notranslate"><span class="pre">PyCFunctionObject</span></code>.</p>
</li>
</ul>
<p>The module state can then be retrieved from the module object via
<code class="docutils literal notranslate"><span class="pre">PyModule_GetState</span></code>.</p>
<p>Note that this proposal implies that any type whose methods need to access
<a class="reference internal" href="#per-module-state">per-module state</a> must be a heap type, rather than a static type. This is
necessary to support loading multiple module objects from a single
extension: a static type, as a C-level global, has no information about
which module object it belongs to.</p>
<section id="slot-methods">
<h3><a class="toc-backref" href="#slot-methods" role="doc-backlink">Slot methods</a></h3>
<p>The above changes don’t cover slot methods, such as <code class="docutils literal notranslate"><span class="pre">tp_iter</span></code> or <code class="docutils literal notranslate"><span class="pre">nb_add</span></code>.</p>
<p>The problem with slot methods is that their C API is fixed, so we can’t
simply add a new argument to pass in the defining class.
Two possible solutions have been proposed to this problem:</p>
<ul class="simple">
<li>Look up the class through walking the MRO.
This is potentially expensive, but will be usable if performance is not
a problem (such as when raising a module-level exception).</li>
<li>Storing a pointer to the defining class of each slot in a separate table,
<code class="docutils literal notranslate"><span class="pre">__typeslots__</span></code> <a class="footnote-reference brackets" href="#typeslots-mail" id="id2">[2]</a>.  This is technically feasible and fast,
but quite invasive.</li>
</ul>
<p>Modules affected by this concern also have the option of using
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#thread-local-storage-support">thread-local state</a> or <a class="reference external" href="https://docs.python.org/3/c-api/contextvars.html">PEP 567 context variables</a> as a caching mechanism, or
else defining their own reload-friendly lookup caching scheme.</p>
<p>Solving the issue generally is deferred to a future PEP.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="adding-module-references-to-heap-types">
<h3><a class="toc-backref" href="#adding-module-references-to-heap-types" role="doc-backlink">Adding module references to heap types</a></h3>
<p>A new factory method will be added to the C-API for creating modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="o">*</span> <span class="n">PyType_FromModuleAndSpec</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
                                   <span class="n">PyType_Spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
                                   <span class="n">PyObject</span> <span class="o">*</span><span class="n">bases</span><span class="p">)</span>
</pre></div>
</div>
<p>This acts the same as <code class="docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases</span></code>, and additionally associates
the provided module object with the new type. (In CPython, this will set
<code class="docutils literal notranslate"><span class="pre">ht_module</span></code> described below.)</p>
<p>Additionally, an accessor, <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span> <span class="pre">PyType_GetModule(PyTypeObject</span> <span class="pre">*)</span></code>
will be provided.
It will return the type’s associated module if one is set,
otherwise it will set <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> and return NULL.
When given a static type, it will always set <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> and return NULL.</p>
<p>To implement this in CPython, the <code class="docutils literal notranslate"><span class="pre">PyHeapTypeObject</span></code> struct will get a
new member, <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*ht_module</span></code>, that will store a pointer to the
associated module.
It will be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> by default and should not be modified after the type
object is created.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ht_module</span></code> member will not be inherited by subclasses; it needs to be
set using <code class="docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases</span></code> for each individual type that needs it.</p>
<p>Usually, creating a class with <code class="docutils literal notranslate"><span class="pre">ht_module</span></code> set will create a reference
cycle involving the class and the module.
This is not a problem, as tearing down modules is not a performance-sensitive
operation, and module-level functions typically also create reference cycles.
The existing “set all module globals to None” code that breaks function cycles
through <code class="docutils literal notranslate"><span class="pre">f_globals</span></code> will also break the new cycles through <code class="docutils literal notranslate"><span class="pre">ht_module</span></code>.</p>
</section>
<section id="passing-the-defining-class-to-extension-methods">
<h3><a class="toc-backref" href="#passing-the-defining-class-to-extension-methods" role="doc-backlink">Passing the defining class to extension methods</a></h3>
<p>A new signature flag, <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code>, will be added for use in
<code class="docutils literal notranslate"><span class="pre">PyMethodDef.ml_flags</span></code>. Conceptually, it adds <code class="docutils literal notranslate"><span class="pre">defining_class</span></code>
to the function signature.
To make the initial implementation easier, the flag can only be used as
<code class="docutils literal notranslate"><span class="pre">(METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span> <span class="pre">|</span> <span class="pre">METH_METHOD)</span></code>.
(It can’t be used with other flags like <code class="docutils literal notranslate"><span class="pre">METH_O</span></code> or bare <code class="docutils literal notranslate"><span class="pre">METH_FASTCALL</span></code>,
though it may be combined with <code class="docutils literal notranslate"><span class="pre">METH_CLASS</span></code> or <code class="docutils literal notranslate"><span class="pre">METH_STATIC</span></code>).</p>
<p>C functions for methods defined using this flag combination will be called
using a new C signature called <code class="docutils literal notranslate"><span class="pre">PyCMethod</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">PyCMethod</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">defining_class</span><span class="p">,</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">const</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="n">size_t</span> <span class="n">nargsf</span><span class="p">,</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwnames</span><span class="p">)</span>
</pre></div>
</div>
<p>Additional combinations like <code class="docutils literal notranslate"><span class="pre">(METH_VARARGS</span> <span class="pre">|</span> <span class="pre">METH_METHOD)</span></code> may be added
in the future (or even in the initial implementation of this PEP).
However, <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> should always be an <em>additional</em> flag, i.e., the
defining class should only be passed in if needed.</p>
<p>In CPython, a new structure extending <code class="docutils literal notranslate"><span class="pre">PyCFunctionObject</span></code> will be added
to hold the extra information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">PyCFunctionObject</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">mm_class</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Passed</span> <span class="k">as</span> <span class="s1">&#39;defining_class&#39;</span> <span class="n">arg</span> <span class="n">to</span> <span class="n">the</span> <span class="n">C</span> <span class="n">func</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">PyCMethodObject</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PyCFunction</span></code> implementation will pass <code class="docutils literal notranslate"><span class="pre">mm_class</span></code> into a
<code class="docutils literal notranslate"><span class="pre">PyCMethod</span></code> C function when it finds the <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> flag being set.
A new macro <code class="docutils literal notranslate"><span class="pre">PyCFunction_GET_CLASS(cls)</span></code> will be added for easier access
to <code class="docutils literal notranslate"><span class="pre">mm_class</span></code>.</p>
<p>C methods may continue to use the other <code class="docutils literal notranslate"><span class="pre">METH_*</span></code> signatures if they do
not require access to their defining class/module.
If <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> is not set, casting to <code class="docutils literal notranslate"><span class="pre">PyCMethodObject</span></code> is invalid.</p>
</section>
<section id="argument-clinic">
<h3><a class="toc-backref" href="#argument-clinic" role="doc-backlink">Argument Clinic</a></h3>
<p>To support passing the defining class to methods using Argument Clinic,
a new converter called <code class="docutils literal notranslate"><span class="pre">defining_class</span></code> will be added to CPython’s Argument
Clinic tool.</p>
<p>Each method may only have one argument using this converter, and it must
appear after <code class="docutils literal notranslate"><span class="pre">self</span></code>, or, if <code class="docutils literal notranslate"><span class="pre">self</span></code> is not used, as the first argument.
The argument will be of type <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span> <span class="pre">*</span></code>.</p>
<p>When used, Argument Clinic will select
<code class="docutils literal notranslate"><span class="pre">METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span> <span class="pre">|</span> <span class="pre">METH_METHOD</span></code> as the calling convention.
The argument will not appear in <code class="docutils literal notranslate"><span class="pre">__text_signature__</span></code>.</p>
<p>The new converter will initially not be compatible with <code class="docutils literal notranslate"><span class="pre">__init__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> methods, which cannot use the <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> convention.</p>
</section>
<section id="helpers">
<h3><a class="toc-backref" href="#helpers" role="doc-backlink">Helpers</a></h3>
<p>Getting to <a class="reference internal" href="#per-module-state">per-module state</a> from a heap type is a very common task. To make
this easier, a helper will be added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span><span class="n">PyType_GetModuleState</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>This function takes a heap type and on success, it returns pointer to the state
of the module that the heap type belongs to.</p>
<p>On failure, two scenarios may occur. When a non-type object, or a type without a
module is passed in, <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is set and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> returned. If the module
is found, the pointer to the state, which may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, is returned without
setting any exception.</p>
</section>
<section id="modules-converted-in-the-initial-implementation">
<h3><a class="toc-backref" href="#modules-converted-in-the-initial-implementation" role="doc-backlink">Modules Converted in the Initial Implementation</a></h3>
<p>To validate the approach, the <code class="docutils literal notranslate"><span class="pre">_elementtree</span></code> module will be modified during
the initial implementation.</p>
</section>
</section>
<section id="summary-of-api-changes-and-additions">
<h2><a class="toc-backref" href="#summary-of-api-changes-and-additions" role="doc-backlink">Summary of API Changes and Additions</a></h2>
<p>The following will be added to Python C-API:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec</span></code> function</li>
<li><code class="docutils literal notranslate"><span class="pre">PyType_GetModule</span></code> function</li>
<li><code class="docutils literal notranslate"><span class="pre">PyType_GetModuleState</span></code> function</li>
<li><code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> call flag</li>
<li><code class="docutils literal notranslate"><span class="pre">PyCMethod</span></code> function signature</li>
</ul>
</div></blockquote>
<p>The following additions will be added as CPython implementation details,
and won’t be documented:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyCFunction_GET_CLASS</span></code> macro</li>
<li><code class="docutils literal notranslate"><span class="pre">PyCMethodObject</span></code> struct</li>
<li><code class="docutils literal notranslate"><span class="pre">ht_module</span></code> member of <code class="docutils literal notranslate"><span class="pre">_heaptypeobject</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">defining_class</span></code> converter in Argument Clinic</li>
</ul>
</div></blockquote>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>One new pointer is added to all heap types.
All other changes are adding new functions and structures,
or changes to private implementation details.</p>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>An initial implementation is available in a Github repository <a class="footnote-reference brackets" href="#gh-repo" id="id3">[3]</a>;
a patchset is at <a class="footnote-reference brackets" href="#gh-patch" id="id4">[4]</a>.</p>
</section>
<section id="possible-future-extensions">
<h2><a class="toc-backref" href="#possible-future-extensions" role="doc-backlink">Possible Future Extensions</a></h2>
<section id="id5">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Slot methods</a></h3>
<p>A way of passing defining class (or module state) to slot methods may be
added in the future.</p>
<p>A previous version of this PEP proposed a helper function that would determine
a defining class by searching the MRO for a class that defines a slot to a
particular function. However, this approach would fail if a class is mutated
(which is, for heap types, possible from Python code).
Solving this problem is left to future discussions.</p>
</section>
<section id="easy-creation-of-types-with-module-references">
<h3><a class="toc-backref" href="#easy-creation-of-types-with-module-references" role="doc-backlink">Easy creation of types with module references</a></h3>
<p>It would be possible to add a <a class="pep reference internal" href="../pep-0489/" title="PEP 489 – Multi-phase extension module initialization">PEP 489</a> execution slot type to make
creating heap types significantly easier than calling
<code class="docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec</span></code>.
This is left to a future PEP.</p>
<p>It may be good to add a good way to create static exception types from the
limited API. Such exception types could be shared between subinterpreters,
but instantiated without needing specific module state.
This is also left to possible future discussions.</p>
</section>
<section id="optimization">
<h3><a class="toc-backref" href="#optimization" role="doc-backlink">Optimization</a></h3>
<p>As proposed here, methods defined with the <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> flag only support
one specific signature.</p>
<p>If it turns out that other signatures are needed for performance reasons,
they may be added.</p>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="tp-slots" role="doc-footnote">
<dt class="label" id="tp-slots">[<a href="#id1">1</a>]</dt>
<dd><a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#tp-slots">https://docs.python.org/3/c-api/typeobj.html#tp-slots</a></aside>
<aside class="footnote brackets" id="typeslots-mail" role="doc-footnote">
<dt class="label" id="typeslots-mail">[<a href="#id2">2</a>]</dt>
<dd>[Import-SIG] On singleton modules, heap types, and subinterpreters
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2015-July/001035.html">https://mail.python.org/pipermail/import-sig/2015-July/001035.html</a>)</aside>
<aside class="footnote brackets" id="gh-repo" role="doc-footnote">
<dt class="label" id="gh-repo">[<a href="#id3">3</a>]</dt>
<dd><a class="reference external" href="https://github.com/Dormouse759/cpython/tree/pep-c-rebase_newer">https://github.com/Dormouse759/cpython/tree/pep-c-rebase_newer</a></aside>
<aside class="footnote brackets" id="gh-patch" role="doc-footnote">
<dt class="label" id="gh-patch">[<a href="#id4">4</a>]</dt>
<dd><a class="reference external" href="https://github.com/Dormouse759/cpython/compare/master...Dormouse759:pep-c-rebase_newer">https://github.com/Dormouse759/cpython/compare/master…Dormouse759:pep-c-rebase_newer</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0573.rst">https://github.com/python/peps/blob/main/peps/pep-0573.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0573.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a><ul>
<li><a class="reference internal" href="#process-global-state">Process-Global State</a></li>
<li><a class="reference internal" href="#per-module-state">Per-module State</a></li>
<li><a class="reference internal" href="#static-type">Static Type</a></li>
<li><a class="reference internal" href="#heap-type">Heap Type</a></li>
<li><a class="reference internal" href="#defining-class">Defining Class</a></li>
<li><a class="reference internal" href="#c-api">C-API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a><ul>
<li><a class="reference internal" href="#slot-methods">Slot methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#adding-module-references-to-heap-types">Adding module references to heap types</a></li>
<li><a class="reference internal" href="#passing-the-defining-class-to-extension-methods">Passing the defining class to extension methods</a></li>
<li><a class="reference internal" href="#argument-clinic">Argument Clinic</a></li>
<li><a class="reference internal" href="#helpers">Helpers</a></li>
<li><a class="reference internal" href="#modules-converted-in-the-initial-implementation">Modules Converted in the Initial Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-api-changes-and-additions">Summary of API Changes and Additions</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#possible-future-extensions">Possible Future Extensions</a><ul>
<li><a class="reference internal" href="#id5">Slot methods</a></li>
<li><a class="reference internal" href="#easy-creation-of-types-with-module-references">Easy creation of types with module references</a></li>
<li><a class="reference internal" href="#optimization">Optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0573.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>