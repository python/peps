
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 642 – Explicit Pattern Syntax for Structural Pattern Matching | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0642/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 642 – Explicit Pattern Syntax for Structural Pattern Matching | peps.python.org'>
    <meta property="og:description" content="This PEP covers an alternative syntax proposal for PEP 634’s structural pattern matching that requires explicit prefixes on all capture patterns and value constraints. It also proposes a new dedicated syntax for instance attribute patterns that aligns m...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0642/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP covers an alternative syntax proposal for PEP 634’s structural pattern matching that requires explicit prefixes on all capture patterns and value constraints. It also proposes a new dedicated syntax for instance attribute patterns that aligns m...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 642</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 642 – Explicit Pattern Syntax for Structural Pattern Matching" data-pagefind-weight="10" class="visually-hidden">PEP 642 – Explicit Pattern Syntax for Structural Pattern Matching</span>
            <section id="pep-content">
<h1 class="page-title">PEP 642 – Explicit Pattern Syntax for Structural Pattern Matching</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">BDFL-Delegate<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/">Python-Dev list</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Formally declined and will not be accepted">Rejected</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Requires<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="../pep-0634/">634</a></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">26-Sep-2020</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.10</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd">31-Oct-2020, 08-Nov-2020, 03-Jan-2021</dd>
<dt class="field-even">Resolution<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/SQC2FTLFV5A7DV7RCEAR2I2IKJKGK7W3/">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#the-match-statement">The Match Statement</a><ul>
<li><a class="reference internal" href="#match-semantics">Match Semantics</a></li>
<li><a class="reference internal" href="#guards">Guards</a></li>
<li><a class="reference internal" href="#irrefutable-case-blocks">Irrefutable case blocks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#patterns">Patterns</a><ul>
<li><a class="reference internal" href="#as-patterns">AS Patterns</a></li>
<li><a class="reference internal" href="#or-patterns">OR Patterns</a></li>
<li><a class="reference internal" href="#value-constraints">Value constraints</a></li>
<li><a class="reference internal" href="#wildcard-pattern">Wildcard Pattern</a></li>
<li><a class="reference internal" href="#group-patterns">Group Patterns</a></li>
<li><a class="reference internal" href="#structural-constraints">Structural constraints</a></li>
<li><a class="reference internal" href="#sequence-constraints">Sequence constraints</a></li>
<li><a class="reference internal" href="#mapping-constraints">Mapping constraints</a></li>
<li><a class="reference internal" href="#instance-attribute-constraints">Instance attribute constraints</a></li>
<li><a class="reference internal" href="#class-defined-constraints">Class defined constraints</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design Discussion</a><ul>
<li><a class="reference internal" href="#requiring-explicit-qualification-of-simple-names-in-match-patterns">Requiring explicit qualification of simple names in match patterns</a></li>
<li><a class="reference internal" href="#resisting-the-temptation-to-guess">Resisting the temptation to guess</a></li>
<li><a class="reference internal" href="#interaction-with-caching-of-attribute-lookups-in-local-variables">Interaction with caching of attribute lookups in local variables</a></li>
<li><a class="reference internal" href="#using-existing-comparison-operators-as-the-value-constraint-prefix">Using existing comparison operators as the value constraint prefix</a></li>
<li><a class="reference internal" href="#using-as-the-wildcard-pattern-marker">Using <code class="docutils literal notranslate"><span class="pre">__</span></code> as the wildcard pattern marker</a></li>
<li><a class="reference internal" href="#representing-patterns-explicitly-in-the-abstract-syntax-tree">Representing patterns explicitly in the Abstract Syntax Tree</a></li>
<li><a class="reference internal" href="#changes-to-sequence-patterns">Changes to sequence patterns</a></li>
<li><a class="reference internal" href="#changes-to-mapping-patterns">Changes to mapping patterns</a></li>
<li><a class="reference internal" href="#changes-to-class-patterns">Changes to class patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-ideas">Deferred Ideas</a><ul>
<li><a class="reference internal" href="#inferred-value-constraints">Inferred value constraints</a></li>
<li><a class="reference internal" href="#making-some-required-parentheses-optional">Making some required parentheses optional</a></li>
<li><a class="reference internal" href="#accepting-complex-literals-as-closed-expressions">Accepting complex literals as closed expressions</a></li>
<li><a class="reference internal" href="#allowing-negated-constraints-in-match-patterns">Allowing negated constraints in match patterns</a></li>
<li><a class="reference internal" href="#allowing-membership-checks-in-match-patterns">Allowing membership checks in match patterns</a></li>
<li><a class="reference internal" href="#inferring-a-default-type-for-instance-attribute-constraints">Inferring a default type for instance attribute constraints</a></li>
<li><a class="reference internal" href="#avoiding-special-cases-in-sequence-patterns">Avoiding special cases in sequence patterns</a></li>
<li><a class="reference internal" href="#expression-syntax-to-retrieve-multiple-attributes-from-an-instance">Expression syntax to retrieve multiple attributes from an instance</a></li>
<li><a class="reference internal" href="#id8">Expression syntax to retrieve multiple attributes from an instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#restricting-permitted-expressions-in-value-constraints-and-mapping-pattern-keys">Restricting permitted expressions in value constraints and mapping pattern keys</a></li>
<li><a class="reference internal" href="#requiring-the-use-of-constraint-prefix-markers-for-mapping-pattern-keys">Requiring the use of constraint prefix markers for mapping pattern keys</a></li>
<li><a class="reference internal" href="#allowing-the-key-value-separator-to-be-omitted-for-mapping-value-constraints">Allowing the key/value separator to be omitted for mapping value constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#appendix-a-full-grammar">Appendix A – Full Grammar</a></li>
<li><a class="reference internal" href="#appendix-b-summary-of-abstract-syntax-tree-changes">Appendix B: Summary of Abstract Syntax Tree changes</a></li>
<li><a class="reference internal" href="#appendix-c-summary-of-changes-relative-to-pep-634">Appendix C: Summary of changes relative to PEP 634</a></li>
<li><a class="reference internal" href="#appendix-d-history-of-changes-to-this-proposal">Appendix D: History of changes to this proposal</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP covers an alternative syntax proposal for <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s structural pattern
matching that requires explicit prefixes on all capture patterns and value
constraints. It also proposes a new dedicated syntax for instance attribute
patterns that aligns more closely with the proposed mapping pattern syntax.</p>
<p>While the result is necessarily more verbose than the proposed syntax in
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, it is still significantly less verbose than the status quo.</p>
<p>As an example, the following match statement would extract “host” and “port”
details from a 2 item sequence, a mapping with “host” and “port” keys, any
object with “host” and “port” attributes, or a “host:port” string, treating
the “port” as optional in the latter three cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">port</span> <span class="o">=</span> <span class="n">DEFAULT_PORT</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">[</span><span class="k">as</span> <span class="n">host</span><span class="p">,</span> <span class="k">as</span> <span class="n">port</span><span class="p">]:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;host&quot;</span> <span class="k">as</span> <span class="n">host</span><span class="p">,</span> <span class="s2">&quot;port&quot;</span> <span class="k">as</span> <span class="n">port</span><span class="p">}:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;host&quot;</span> <span class="k">as</span> <span class="n">host</span><span class="p">}:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">{</span><span class="o">.</span><span class="n">host</span> <span class="k">as</span> <span class="n">host</span><span class="p">,</span> <span class="o">.</span><span class="n">port</span> <span class="k">as</span> <span class="n">port</span><span class="p">}:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">{</span><span class="o">.</span><span class="n">host</span> <span class="k">as</span> <span class="n">host</span><span class="p">}:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="nb">str</span><span class="p">{}</span> <span class="k">as</span> <span class="n">addr</span><span class="p">:</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">optional_port</span> <span class="o">=</span> <span class="n">addr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optional_port</span><span class="p">:</span>
            <span class="n">port</span> <span class="o">=</span> <span class="n">optional_port</span>
    <span class="k">case</span> <span class="n">__</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown address format: </span><span class="si">{</span><span class="n">m</span><span class="si">!r:</span><span class="s2">.200</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
</pre></div>
</div>
<p>At a high level, this PEP proposes to categorise the different available pattern
types as follows:</p>
<ul class="simple">
<li>wildcard pattern: <code class="docutils literal notranslate"><span class="pre">__</span></code></li>
<li>group patterns: <code class="docutils literal notranslate"><span class="pre">(PTRN)</span></code></li>
<li><dl class="simple">
<dt>value constraint patterns:</dt><dd><ul>
<li>equality constraints: <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">EXPR</span></code></li>
<li>identity constraints: <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">EXPR</span></code></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>structural constraint patterns:</dt><dd><ul>
<li>sequence constraint patterns: <code class="docutils literal notranslate"><span class="pre">[PTRN,</span> <span class="pre">as</span> <span class="pre">NAME,</span> <span class="pre">PTRN</span> <span class="pre">as</span> <span class="pre">NAME]</span></code></li>
<li>mapping constraint patterns: <code class="docutils literal notranslate"><span class="pre">{EXPR:</span> <span class="pre">PTRN,</span> <span class="pre">EXPR</span> <span class="pre">as</span> <span class="pre">NAME}</span></code></li>
<li>instance attribute constraint patterns:
<code class="docutils literal notranslate"><span class="pre">CLS{.NAME,</span> <span class="pre">.NAME:</span> <span class="pre">PTRN,</span> <span class="pre">.NAME</span> <span class="pre">==</span> <span class="pre">EXPR,</span> <span class="pre">.NAME</span> <span class="pre">as</span> <span class="pre">NAME}</span></code></li>
<li>class defined constraint patterns:
<code class="docutils literal notranslate"><span class="pre">CLS(PTRN,</span> <span class="pre">PTRN,</span> <span class="pre">**{.NAME,</span> <span class="pre">.NAME:</span> <span class="pre">PTRN,</span> <span class="pre">.NAME</span> <span class="pre">==</span> <span class="pre">EXPR,</span> <span class="pre">.NAME</span> <span class="pre">as</span> <span class="pre">NAME})</span></code></li>
</ul>
</dd>
</dl>
</li>
<li>OR patterns: <code class="docutils literal notranslate"><span class="pre">PTRN</span> <span class="pre">|</span> <span class="pre">PTRN</span> <span class="pre">|</span> <span class="pre">PTRN</span></code></li>
<li>AS patterns: <code class="docutils literal notranslate"><span class="pre">PTRN</span> <span class="pre">as</span> <span class="pre">NAME</span></code> (omitting the pattern implies <code class="docutils literal notranslate"><span class="pre">__</span></code>)</li>
</ul>
<p>The intent of this approach is to:</p>
<ul class="simple">
<li>allow an initial form of pattern matching to be developed and released without
needing to decide up front on the best default options for handling bare names,
attribute lookups, and literal values</li>
<li>ensure that pattern matching is defined explicitly at the Abstract Syntax Tree
level, allowing the specifications of the semantics and the surface syntax for
pattern matching to be clearly separated</li>
<li>define a clear and concise “ducktyping” syntax that could potentially be
adopted in ordinary expressions as a way to more easily retrieve a tuple
containing multiple attributes from the same object</li>
</ul>
<p>Relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, the proposal also deliberately eliminates any syntax that
“binds to the right” without using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword (using capture patterns
in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s mapping patterns and class patterns) or binds to both the left and
the right in the same pattern (using <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s capture patterns with AS patterns)</p>
</section>
<section id="relationship-with-other-peps">
<h2><a class="toc-backref" href="#relationship-with-other-peps" role="doc-backlink">Relationship with other PEPs</a></h2>
<p>This PEP both depends on and competes with <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> - the PEP author agrees that
match statements would be a sufficiently valuable addition to the language to
be worth the additional complexity that they add to the learning process, but
disagrees with the idea that “simple name vs literal or attribute lookup”
really offers an adequate syntactic distinction between name binding and value
lookup operations in match patterns (at least for Python).</p>
<p>This PEP agrees with the spirit of <a class="pep reference internal" href="../pep-0640/" title="PEP 640 – Unused variable syntax">PEP 640</a> (that the chosen wildcard pattern to
skip a name binding should be supported everywhere, not just in match patterns),
but is now proposing a different spelling for the wildcard syntax (<code class="docutils literal notranslate"><span class="pre">__</span></code> rather
than <code class="docutils literal notranslate"><span class="pre">?</span></code>). As such, it competes with <a class="pep reference internal" href="../pep-0640/" title="PEP 640 – Unused variable syntax">PEP 640</a> as written, but would complement
a proposal to deprecate the use of <code class="docutils literal notranslate"><span class="pre">__</span></code> as an ordinary identifier and instead
turn it into a general purpose wildcard marker that always skips making a new
local variable binding.</p>
<p>While it has not yet been put forward as a PEP, Mark Shannon has a pre-PEP draft
<a class="footnote-reference brackets" href="#id18" id="id1">[8]</a> expressing several concerns about the runtime semantics of the pattern
matching proposal in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>. This PEP is somewhat complementary to that one, as
even though this PEP is mostly about surface syntax changes rather than major
semantic changes, it does propose that the Abstract Syntax Tree definition be
made more explicit to better separate the details of the surface syntax from the
semantics of the code generation step. There is one specific idea in that pre-PEP
draft that this PEP explicitly rejects: the idea that the different kinds of
matching are mutually exclusive. It’s entirely possible for the same value to
match different kinds of structural pattern, and which one takes precedence will
intentionally be governed by the order of the cases in the match statement.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The original <a class="pep reference internal" href="../pep-0622/" title="PEP 622 – Structural Pattern Matching">PEP 622</a> (which was later split into <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, <a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a>, and <a class="pep reference internal" href="../pep-0636/" title="PEP 636 – Structural Pattern Matching: Tutorial">PEP 636</a>)
incorporated an unstated but essential assumption in its syntax design: that
neither ordinary expressions <em>nor</em> the existing assignment target syntax provide
an adequate foundation for the syntax used in match patterns.</p>
<p>While the PEP didn’t explicitly state this assumption, one of the PEP authors
explained it clearly on python-dev <a class="footnote-reference brackets" href="#id11" id="id2">[1]</a>:</p>
<blockquote>
<div>The actual problem that I see is that we have different cultures/intuitions
fundamentally clashing here.  In particular, so many programmers welcome
pattern matching as an “extended switch statement” and find it therefore
strange that names are binding and not expressions for comparison.  Others
argue that it is at odds with current assignment statements, say, and
question why dotted names are _/not/_ binding.  What all groups seem to
have in common, though, is that they refer to _/their/_ understanding and
interpretation of the new match statement as ‘consistent’ or ‘intuitive’
— naturally pointing out where we as PEP authors went wrong with our
design.<p>But here is the catch: at least in the Python world, pattern matching as
proposed by this PEP is an unprecedented and new way of approaching a common
problem.  It is not simply an extension of something already there.  Even
worse: while designing the PEP we found that no matter from which angle you
approach it, you will run into issues of seeming ‘inconsistencies’ (which is
to say that pattern matching cannot be reduced to a ‘linear’ extension of
existing features in a meaningful way): there is always something that goes
fundamentally beyond what is already there in Python.  That’s why I argue
that arguments based on what is ‘intuitive’ or ‘consistent’ just do not
make sense _/in this case/_.</p>
</div></blockquote>
<p>The first iteration of this PEP was then born out of an attempt to show that the
second assertion was not accurate, and that match patterns could be treated
as a variation on assignment targets without leading to inherent contradictions.
(An earlier PR submitted to list this option in the “Rejected Ideas” section
of the original <a class="pep reference internal" href="../pep-0622/" title="PEP 622 – Structural Pattern Matching">PEP 622</a> had previously been declined <a class="footnote-reference brackets" href="#id12" id="id3">[2]</a>).</p>
<p>However, the review process for this PEP strongly suggested that not only did
the contradictions that Tobias mentioned in his email exist, but they were also
concerning enough to cast doubts on the syntax proposal presented in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.
Accordingly, this PEP was changed to go even further than <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, and largely
abandon alignment between the sequence matching syntax and the existing iterable
unpacking syntax (effectively answering “Not really, as least as far as the
exact syntax is concerned” to the first question raised in the DLS’20 paper
<a class="footnote-reference brackets" href="#id19" id="id4">[9]</a>: “Can we extend a feature like iterable unpacking to work for more general
object and data layouts?”).</p>
<p>This resulted in a complete reversal of the goals of the PEP: rather than
attempting to emphasise the similarities between assignment and pattern matching,
the PEP now attempts to make sure that assignment target syntax isn’t being
reused <em>at all</em>, reducing the likelihood of incorrect inferences being drawn
about the new construct based on experience with existing ones.</p>
<p>Finally, before completing the 3rd iteration of the proposal (which dropped
inferred patterns entirely), the PEP author spent quite a bit of time reflecting
on the following entries in <a class="pep reference internal" href="../pep-0020/" title="PEP 20 – The Zen of Python">PEP 20</a>:</p>
<ul class="simple">
<li>Explicit is better than implicit.</li>
<li>Special cases aren’t special enough to break the rules.</li>
<li>In the face of ambiguity, refuse the temptation to guess.</li>
</ul>
<p>If we start with an explicit syntax, we can always add syntactic shortcuts later
(e.g. consider the recent proposals to add shortcuts for <code class="docutils literal notranslate"><span class="pre">Union</span></code> and
<code class="docutils literal notranslate"><span class="pre">Optional</span></code> type hints only after years of experience with the original more
verbose forms), while if we start out with only the abbreviated forms,
then we don’t have any real way to revisit those decisions in a future release.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>This PEP retains the overall <code class="docutils literal notranslate"><span class="pre">match</span></code>/<code class="docutils literal notranslate"><span class="pre">case</span></code> statement structure and semantics
from <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, but proposes multiple changes that mean that user intent is
explicitly specified in the concrete syntax rather than needing to be inferred
from the pattern matching context.</p>
<p>In the proposed Abstract Syntax Tree, the semantics are also always explicit,
with no inference required.</p>
<section id="the-match-statement">
<h3><a class="toc-backref" href="#the-match-statement" role="doc-backlink">The Match Statement</a></h3>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>match_stmt: &quot;match&quot; subject_expr &#39;:&#39; NEWLINE INDENT case_block+ DEDENT
subject_expr:
    | star_named_expression &#39;,&#39; star_named_expressions?
    | named_expression
case_block: &quot;case&quot; (guarded_pattern | open_pattern) &#39;:&#39; block

guarded_pattern: closed_pattern &#39;if&#39; named_expression

open_pattern:
    | as_pattern
    | or_pattern

closed_pattern:
    | wildcard_pattern
    | group_pattern
    | structural_constraint
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Match(expr subject, match_case* cases)
match_case = (pattern pattern, expr? guard, stmt* body)
</pre></div>
</div>
<p>The rules <code class="docutils literal notranslate"><span class="pre">star_named_expression</span></code>, <code class="docutils literal notranslate"><span class="pre">star_named_expressions</span></code>,
<code class="docutils literal notranslate"><span class="pre">named_expression</span></code> and <code class="docutils literal notranslate"><span class="pre">block</span></code> are part of the <a class="reference external" href="https://docs.python.org/3.10/reference/grammar.html">standard Python
grammar</a>.</p>
<p>Open patterns are patterns which consist of multiple tokens, and aren’t
necessarily terminated by a closing delimiter (for example, <code class="docutils literal notranslate"><span class="pre">__</span> <span class="pre">as</span> <span class="pre">x</span></code>,
<code class="docutils literal notranslate"><span class="pre">int()</span> <span class="pre">|</span> <span class="pre">bool()</span></code>). To avoid ambiguity for human readers, their usage is
restricted to top level patterns and to group patterns (which are patterns
surrounded by parentheses).</p>
<p>Closed patterns are patterns which either consist of a single token
(i.e. <code class="docutils literal notranslate"><span class="pre">__</span></code>), or else have a closing delimiter as a required part of their
syntax (e.g. <code class="docutils literal notranslate"><span class="pre">[as</span> <span class="pre">x,</span> <span class="pre">as</span> <span class="pre">y]</span></code>, <code class="docutils literal notranslate"><span class="pre">object{.x</span> <span class="pre">as</span> <span class="pre">x,</span> <span class="pre">.y</span> <span class="pre">as</span> <span class="pre">y}</span></code>).</p>
<p>As in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, the <code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">case</span></code> keywords are soft keywords, i.e. they
are not reserved words in other grammatical contexts (including at the
start of a line if there is no colon where expected).  This means
that they are recognized as keywords when part of a match
statement or case block only, and are allowed to be used in all
other contexts as variable or argument names.</p>
<p>Unlike <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, patterns are explicitly defined as a new kind of node in the
abstract syntax tree - even when surface syntax is shared with existing
expression nodes, a distinct abstract node is emitted by the parser.</p>
<p>For context, <code class="docutils literal notranslate"><span class="pre">match_stmt</span></code> is a new alternative for
<code class="docutils literal notranslate"><span class="pre">compound_statement</span></code> in the surface syntax and <code class="docutils literal notranslate"><span class="pre">Match</span></code> is a new
alternative for <code class="docutils literal notranslate"><span class="pre">stmt</span></code> in the abstract syntax.</p>
<section id="match-semantics">
<h4><a class="toc-backref" href="#match-semantics" role="doc-backlink">Match Semantics</a></h4>
<p>This PEP largely retains the overall pattern matching semantics proposed in
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.</p>
<p>The proposed syntax for patterns changes significantly, and is discussed in
detail below.</p>
<p>There are also some proposed changes to the semantics of class defined
constraints (class patterns in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>) to eliminate the need to special case
any builtin types (instead, the introduction of dedicated syntax for instance
attribute constraints allows the behaviour needed by those builtin types to be
specified as applying to any type that sets <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
</section>
<section id="guards">
<h4><a class="toc-backref" href="#guards" role="doc-backlink">Guards</a></h4>
<p>This PEP retains the guard clause semantics proposed in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.</p>
<p>However, the syntax is changed slightly to require that when a guard clause
is present, the case pattern must be a <em>closed</em> pattern.</p>
<p>This makes it clearer to the reader where the pattern ends and the guard clause
begins. (This is mainly a potential problem with OR patterns, where the guard
clause looks kind of like the start of a conditional expression in the final
pattern. Actually doing that isn’t legal syntax, so there’s no ambiguity as far
as the compiler is concerned, but the distinction may not be as clear to a human
reader)</p>
</section>
<section id="irrefutable-case-blocks">
<h4><a class="toc-backref" href="#irrefutable-case-blocks" role="doc-backlink">Irrefutable case blocks</a></h4>
<p>The definition of irrefutable case blocks changes slightly in this PEP relative
to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, as capture patterns no longer exist as a separate concept from
AS patterns.</p>
<p>Aside from that caveat, the handling of irrefutable cases is the same as in
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>:</p>
<ul class="simple">
<li>wildcard patterns are irrefutable</li>
<li>AS patterns whose left-hand side is irrefutable</li>
<li>OR patterns containing at least one irrefutable pattern</li>
<li>parenthesized irrefutable patterns</li>
<li>a case block is considered irrefutable if it has no guard and its
pattern is irrefutable.</li>
<li>a match statement may have at most one irrefutable case block, and it
must be last.</li>
</ul>
</section>
</section>
<section id="patterns">
<h3><a class="toc-backref" href="#patterns" role="doc-backlink">Patterns</a></h3>
<p>The top-level surface syntax for patterns is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">open_pattern</span><span class="p">:</span> <span class="c1"># Pattern may use multiple tokens with no closing delimiter</span>
    <span class="o">|</span> <span class="n">as_pattern</span>
    <span class="o">|</span> <span class="n">or_pattern</span>

<span class="n">as_pattern</span><span class="p">:</span> <span class="p">[</span><span class="n">closed_pattern</span><span class="p">]</span> <span class="n">pattern_as_clause</span>

<span class="n">or_pattern</span><span class="p">:</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">simple_pattern</span><span class="o">+</span>

<span class="n">simple_pattern</span><span class="p">:</span> <span class="c1"># Subnode where &quot;as&quot; and &quot;or&quot; patterns must be parenthesised</span>
    <span class="o">|</span> <span class="n">closed_pattern</span>
    <span class="o">|</span> <span class="n">value_constraint</span>

<span class="n">closed_pattern</span><span class="p">:</span> <span class="c1"># Require a single token or a closing delimiter in pattern</span>
    <span class="o">|</span> <span class="n">wildcard_pattern</span>
    <span class="o">|</span> <span class="n">group_pattern</span>
    <span class="o">|</span> <span class="n">structural_constraint</span>
</pre></div>
</div>
<p>As described above, the usage of open patterns is limited to top level case
clauses and when parenthesised in a group pattern.</p>
<p>The abstract syntax for patterns explicitly indicates which elements are
subpatterns and which elements are subexpressions or identifiers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pattern = MatchAlways
     | MatchValue(matchop op, expr value)
     | MatchSequence(pattern* patterns)
     | MatchMapping(expr* keys, pattern* patterns)
     | MatchAttrs(expr cls, identifier* attrs, pattern* patterns)
     | MatchClass(expr cls, pattern* patterns, identifier* extra_attrs, pattern* extra_patterns)

     | MatchRestOfSequence(identifier? target)
     -- A NULL entry in the MatchMapping key list handles capturing extra mapping keys

     | MatchAs(pattern? pattern, identifier target)
     | MatchOr(pattern* patterns)
</pre></div>
</div>
<section id="as-patterns">
<h4><a class="toc-backref" href="#as-patterns" role="doc-backlink">AS Patterns</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>as_pattern: [closed_pattern] pattern_as_clause
pattern_as_clause: &#39;as&#39; pattern_capture_target
pattern_capture_target: !&quot;__&quot; NAME !(&#39;.&#39; | &#39;(&#39; | &#39;=&#39;)
</pre></div>
</div>
<p>(Note: the name on the right may not be <code class="docutils literal notranslate"><span class="pre">__</span></code>.)</p>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MatchAs(pattern? pattern, identifier target)
</pre></div>
</div>
<p>An AS pattern matches the closed pattern on the left of the <code class="docutils literal notranslate"><span class="pre">as</span></code>
keyword against the subject.  If this fails, the AS pattern fails.
Otherwise, the AS pattern binds the subject to the name on the right
of the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword and succeeds.</p>
<p>If no pattern to match is given, the wildcard pattern (<code class="docutils literal notranslate"><span class="pre">__</span></code>) is implied.</p>
<p>To avoid confusion with the <a class="reference internal" href="#wildcard-pattern">wildcard pattern</a>, the double underscore (<code class="docutils literal notranslate"><span class="pre">__</span></code>)
is not permitted as a capture target (this is what <code class="docutils literal notranslate"><span class="pre">!&quot;__&quot;</span></code> expresses).</p>
<p>A capture pattern always succeeds.  It binds the subject value to the
name using the scoping rules for name binding established for named expressions
in <a class="pep reference internal" href="../pep-0572/" title="PEP 572 – Assignment Expressions">PEP 572</a>.  (Summary: the name becomes a local
variable in the closest containing function scope unless there’s an
applicable <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> or <code class="docutils literal notranslate"><span class="pre">global</span></code> statement.)</p>
<p>In a given pattern, a given name may be bound only once.  This
disallows for example <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[as</span> <span class="pre">x,</span> <span class="pre">as</span> <span class="pre">x]:</span> <span class="pre">...</span></code> but allows
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[as</span> <span class="pre">x]</span> <span class="pre">|</span> <span class="pre">(as</span> <span class="pre">x)</span></code>:</p>
<p>As an open pattern, the usage of AS patterns is limited to top level case
clauses and when parenthesised in a group pattern. However, several of the
structural constraints allow the use of <code class="docutils literal notranslate"><span class="pre">pattern_as_clause</span></code> in relevant
locations to bind extracted elements of the matched subject to local variables.
These are mostly represented in the abstract syntax tree as <code class="docutils literal notranslate"><span class="pre">MatchAs</span></code> nodes,
aside from the dedicated <code class="docutils literal notranslate"><span class="pre">MatchRestOfSequence</span></code> node in sequence patterns.</p>
</section>
<section id="or-patterns">
<h4><a class="toc-backref" href="#or-patterns" role="doc-backlink">OR Patterns</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">or_pattern</span><span class="p">:</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">simple_pattern</span><span class="o">+</span>

<span class="n">simple_pattern</span><span class="p">:</span> <span class="c1"># Subnode where &quot;as&quot; and &quot;or&quot; patterns must be parenthesised</span>
    <span class="o">|</span> <span class="n">closed_pattern</span>
    <span class="o">|</span> <span class="n">value_constraint</span>
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchOr</span><span class="p">(</span><span class="n">pattern</span><span class="o">*</span> <span class="n">patterns</span><span class="p">)</span>
</pre></div>
</div>
<p>When two or more patterns are separated by vertical bars (<code class="docutils literal notranslate"><span class="pre">|</span></code>),
this is called an OR pattern. (A single simple pattern is just that)</p>
<p>Only the final subpattern may be irrefutable.</p>
<p>Each subpattern must bind the same set of names.</p>
<p>An OR pattern matches each of its subpatterns in turn to the subject,
until one succeeds.  The OR pattern is then deemed to succeed.
If none of the subpatterns succeed the OR pattern fails.</p>
<p>Subpatterns are mostly required to be closed patterns, but the parentheses may
be omitted for value constraints.</p>
</section>
<section id="value-constraints">
<h4><a class="toc-backref" href="#value-constraints" role="doc-backlink">Value constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">value_constraint</span><span class="p">:</span>
    <span class="o">|</span> <span class="n">eq_constraint</span>
    <span class="o">|</span> <span class="n">id_constraint</span>

<span class="n">eq_constraint</span><span class="p">:</span> <span class="s1">&#39;==&#39;</span> <span class="n">closed_expr</span>
<span class="n">id_constraint</span><span class="p">:</span> <span class="s1">&#39;is&#39;</span> <span class="n">closed_expr</span>

<span class="n">closed_expr</span><span class="p">:</span> <span class="c1"># Require a single token or a closing delimiter in expression</span>
    <span class="o">|</span> <span class="n">primary</span>
    <span class="o">|</span> <span class="n">closed_factor</span>

<span class="n">closed_factor</span><span class="p">:</span> <span class="c1"># &quot;factor&quot; is the main grammar node for these unary ops</span>
    <span class="o">|</span> <span class="s1">&#39;+&#39;</span> <span class="n">primary</span>
    <span class="o">|</span> <span class="s1">&#39;-&#39;</span> <span class="n">primary</span>
    <span class="o">|</span> <span class="s1">&#39;~&#39;</span> <span class="n">primary</span>
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchValue</span><span class="p">(</span><span class="n">matchop</span> <span class="n">op</span><span class="p">,</span> <span class="n">expr</span> <span class="n">value</span><span class="p">)</span>
<span class="n">matchop</span> <span class="o">=</span> <span class="n">EqCheck</span> <span class="o">|</span> <span class="n">IdCheck</span>
</pre></div>
</div>
<p>The rule <code class="docutils literal notranslate"><span class="pre">primary</span></code> is defined in the standard Python grammar, and only
allows expressions that either consist of a single token, or else are required
to end with a closing delimiter.</p>
<p>Value constraints replace <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s literal patterns and value patterns.</p>
<p>Equality constraints are written as <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">EXPR</span></code>, while identity constraints are
written as <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">EXPR</span></code>.</p>
<p>An equality constraint succeeds if the subject value compares equal to the
value given on the right, while an identity constraint succeeds only if they are
the exact same object.</p>
<p>The expressions to be compared against are largely restricted to either
single tokens (e.g. names, strings, numbers, builtin constants), or else to
expressions that are required to end with a closing delimiter.</p>
<p>The use of the high precedence unary operators is also permitted, as the risk of
perceived ambiguity is low, and being able to specify negative numbers without
parentheses is desirable.</p>
<p>When the same constraint expression occurs multiple times in the same match
statement, the interpreter may cache the first value calculated and reuse it,
rather than repeat the expression evaluation. (As for <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> value patterns,
this cache is strictly tied to a given execution of a given match statement.)</p>
<p>Unlike literal patterns in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, this PEP requires that complex
literals be parenthesised to be accepted by the parser. See the Deferred
Ideas section for discussion on that point.</p>
<p>If this PEP were to be adopted in preference to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, then all literal and
value patterns would instead be written more explicitly as value constraints:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Literal patterns</span>
<span class="k">match</span> <span class="n">number</span><span class="p">:</span>
    <span class="n">case</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nothing&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Just one&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A couple&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One less than nothing&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Good luck with that...&quot;</span><span class="p">)</span>

<span class="c1"># Additional literal patterns</span>
<span class="k">match</span> <span class="n">value</span><span class="p">:</span>
    <span class="n">case</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;True or 1&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;False or 0&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="s2">&quot;Hello&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text &#39;Hello&#39;&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary &#39;World!&#39;&quot;</span><span class="p">)</span>

<span class="c1"># Matching by identity rather than equality</span>
<span class="n">SENTINEL</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="k">match</span> <span class="n">value</span><span class="p">:</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;True, not 1&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;False, not 0&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None, following PEP 8 comparison guidelines&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;May be useful when writing __getitem__ methods?&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="n">SENTINEL</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Matches the sentinel by identity, not just value&quot;</span><span class="p">)</span>

<span class="c1"># Matching against variables and attributes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sides</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="n">SPAM</span> <span class="o">=</span> <span class="s2">&quot;Spam&quot;</span>
    <span class="n">EGGS</span> <span class="o">=</span> <span class="s2">&quot;eggs&quot;</span>
    <span class="o">...</span>

<span class="n">preferred_side</span> <span class="o">=</span> <span class="n">Sides</span><span class="o">.</span><span class="n">EGGS</span>
<span class="k">match</span> <span class="n">entree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">case</span> <span class="o">==</span> <span class="n">Sides</span><span class="o">.</span><span class="n">SPAM</span><span class="p">:</span>  <span class="c1"># Compares entree[-1] == Sides.SPAM.</span>
        <span class="n">response</span> <span class="o">=</span> <span class="s2">&quot;Have you got anything without Spam?&quot;</span>
    <span class="n">case</span> <span class="o">==</span> <span class="n">preferred_side</span><span class="p">:</span>  <span class="c1"># Compares entree[-1] == preferred_side</span>
        <span class="n">response</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Oh, I love </span><span class="si">{</span><span class="n">preferred_side</span><span class="si">}</span><span class="s2">!&quot;</span>
    <span class="n">case</span> <span class="k">as</span> <span class="n">side</span><span class="p">:</span>  <span class="c1"># Assigns side = entree[-1].</span>
        <span class="n">response</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Well, could I have their Spam instead of the </span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s2"> then?&quot;</span>
</pre></div>
</div>
<p>Note the <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">preferred_side</span></code> example: using an explicit prefix marker on
constraint expressions removes the restriction to only working with attributes
or literals for value lookups.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">(1-1j)</span></code> example illustrates the use of parentheses to turn any
subexpression into a closed one.</p>
</section>
<section id="wildcard-pattern">
<h4><a class="toc-backref" href="#wildcard-pattern" role="doc-backlink">Wildcard Pattern</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wildcard_pattern</span><span class="p">:</span> <span class="s2">&quot;__&quot;</span>
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchAlways</span>
</pre></div>
</div>
<p>A wildcard pattern always succeeds.  As in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, it binds no name.</p>
<p>Where <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> chooses the single underscore as its wildcard pattern for
consistency with other languages, this PEP chooses the double underscore as that
has a clearer path towards potentially being made consistent across the entire
language, whereas that path is blocked for <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> by i18n related use cases.</p>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">sequence</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">[</span><span class="n">__</span><span class="p">]:</span>               <span class="c1"># any sequence with a single element</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">case</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">__</span><span class="p">,</span> <span class="n">end</span><span class="p">]:</span>  <span class="c1"># a sequence with at least two elements</span>
        <span class="k">return</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span>
    <span class="k">case</span> <span class="n">__</span><span class="p">:</span>                 <span class="c1"># anything</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</section>
<section id="group-patterns">
<h4><a class="toc-backref" href="#group-patterns" role="doc-backlink">Group Patterns</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">group_pattern</span><span class="p">:</span> <span class="s1">&#39;(&#39;</span> <span class="n">open_pattern</span> <span class="s1">&#39;)&#39;</span>
</pre></div>
</div>
<p>For the syntax of <code class="docutils literal notranslate"><span class="pre">open_pattern</span></code>, see Patterns above.</p>
<p>A parenthesized pattern has no additional syntax and is not represented in the
abstract syntax tree.  It allows users to add parentheses around patterns to
emphasize the intended grouping, and to allow nesting of open patterns when the
grammar requires a closed pattern.</p>
<p>Unlike <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, there is no potential ambiguity with sequence patterns, as
this PEP requires that all sequence patterns be written with square brackets.</p>
</section>
<section id="structural-constraints">
<h4><a class="toc-backref" href="#structural-constraints" role="doc-backlink">Structural constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">structural_constraint</span><span class="p">:</span>
    <span class="o">|</span> <span class="n">sequence_constraint</span>
    <span class="o">|</span> <span class="n">mapping_constraint</span>
    <span class="o">|</span> <span class="n">attrs_constraint</span>
    <span class="o">|</span> <span class="n">class_constraint</span>
</pre></div>
</div>
<p>Note: the separate “structural constraint” subcategory isn’t used in the
abstract syntax tree, it’s merely used as a convenient grouping node in the
surface syntax definition.</p>
<p>Structural constraints are patterns used to both make assertions about complex
objects and to extract values from them.</p>
<p>These patterns may all bind multiple values, either through the use of nested
AS patterns, or else through the use of <code class="docutils literal notranslate"><span class="pre">pattern_as_clause</span></code> elements included
in the definition of the pattern.</p>
</section>
<section id="sequence-constraints">
<h4><a class="toc-backref" href="#sequence-constraints" role="doc-backlink">Sequence constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sequence_constraint: &#39;[&#39; [sequence_constraint_elements] &#39;]&#39;
sequence_constraint_elements: &#39;,&#39;.sequence_constraint_element+ &#39;,&#39;?
sequence_constraint_element:
    | star_pattern
    | simple_pattern
    | pattern_as_clause
star_pattern: &#39;*&#39; (pattern_as_clause | wildcard_pattern)

simple_pattern: # Subnode where &quot;as&quot; and &quot;or&quot; patterns must be parenthesised
    | closed_pattern
    | value_constraint

pattern_as_clause: &#39;as&#39; pattern_capture_target
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MatchSequence(pattern* patterns)

MatchRestOfSequence(identifier? target)
</pre></div>
</div>
<p>Sequence constraints allow items within a sequence to be checked and
optionally extracted.</p>
<p>A sequence pattern fails if the subject value is not an instance of
<code class="docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code>.  It also fails if the subject value is
an instance of <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> (see Deferred Ideas for
a discussion on potentially removing the need for this special casing).</p>
<p>A sequence pattern may contain at most one star subpattern.  The star
subpattern may occur in any position and is represented in the AST using the
<code class="docutils literal notranslate"><span class="pre">MatchRestOfSequence</span></code> node.</p>
<p>If no star subpattern is present, the sequence pattern is a fixed-length
sequence pattern; otherwise it is a variable-length sequence pattern.</p>
<p>A fixed-length sequence pattern fails if the length of the subject
sequence is not equal to the number of subpatterns.</p>
<p>A variable-length sequence pattern fails if the length of the subject
sequence is less than the number of non-star subpatterns.</p>
<p>The length of the subject sequence is obtained using the builtin
<code class="docutils literal notranslate"><span class="pre">len()</span></code> function (i.e., via the <code class="docutils literal notranslate"><span class="pre">__len__</span></code> protocol).  However, the
interpreter may cache this value in a similar manner as described for
value constraint expressions.</p>
<p>A fixed-length sequence pattern matches the subpatterns to
corresponding items of the subject sequence, from left to right.
Matching stops (with a failure) as soon as a subpattern fails.  If all
subpatterns succeed in matching their corresponding item, the sequence
pattern succeeds.</p>
<p>A variable-length sequence pattern first matches the leading non-star
subpatterns to the corresponding items of the subject sequence, as for
a fixed-length sequence.  If this succeeds, the star subpattern
matches a list formed of the remaining subject items, with items
removed from the end corresponding to the non-star subpatterns
following the star subpattern.  The remaining non-star subpatterns are
then matched to the corresponding subject items, as for a fixed-length
sequence.</p>
<p>Subpatterns are mostly required to be closed patterns, but the parentheses may
be omitted for value constraints. Sequence elements may also be captured
unconditionally without parentheses.</p>
<p>Note: where <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> allows all the same syntactic flexibility as iterable
unpacking in assignment statements, this PEP restricts sequence patterns
specifically to the square bracket form. Given that the open and parenthesised
forms are far more popular than square brackets for iterable unpacking, this
helps emphasise that iterable unpacking and sequence matching are <em>not</em> the
same operation. It also avoids the parenthesised form’s ambiguity problem
between single element sequence patterns and group patterns.</p>
</section>
<section id="mapping-constraints">
<h4><a class="toc-backref" href="#mapping-constraints" role="doc-backlink">Mapping constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mapping_constraint: &#39;{&#39; [mapping_constraint_elements] &#39;}&#39;
mapping_constraint_elements: &#39;,&#39;.key_value_constraint+ &#39;,&#39;?
key_value_constraint:
    | closed_expr pattern_as_clause
    | closed_expr &#39;:&#39; simple_pattern
    | double_star_capture
double_star_capture: &#39;**&#39; pattern_as_clause
</pre></div>
</div>
<p>(Note that <code class="docutils literal notranslate"><span class="pre">**__</span></code> is deliberately disallowed by this syntax, as additional
mapping entries are ignored by default)</p>
<p>closed_expr is defined above, under value constraints.</p>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchMapping</span><span class="p">(</span><span class="n">expr</span><span class="o">*</span> <span class="n">keys</span><span class="p">,</span> <span class="n">pattern</span><span class="o">*</span> <span class="n">patterns</span><span class="p">)</span>
</pre></div>
</div>
<p>Mapping constraints allow keys and values within a sequence to be checked and
values to optionally be extracted.</p>
<p>A mapping pattern fails if the subject value is not an instance of
<code class="docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code>.</p>
<p>A mapping pattern succeeds if every key given in the mapping pattern
is present in the subject mapping, and the pattern for
each key matches the corresponding item of the subject mapping.</p>
<p>The presence of keys is checked using the two argument form of the <code class="docutils literal notranslate"><span class="pre">get</span></code>
method and a unique sentinel value, which offers the following benefits:</p>
<ul class="simple">
<li>no exceptions need to be created in the lookup process</li>
<li>mappings that implement <code class="docutils literal notranslate"><span class="pre">__missing__</span></code> (such as <code class="docutils literal notranslate"><span class="pre">collections.defaultdict</span></code>)
only match on keys that they already contain, they don’t implicitly add keys</li>
</ul>
<p>A mapping pattern may not contain duplicate key values. If duplicate keys are
detected when checking the mapping pattern, the pattern is considered invalid,
and a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised. While it would theoretically be possible to
checked for duplicated constant keys at compile time, no such check is currently
defined or implemented.</p>
<p>(Note: This semantic description is derived from the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> reference
implementation, which differs from the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> specification text at time of
writing. The implementation seems reasonable, so amending the PEP text seems
like the best way to resolve the discrepancy)</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">'**'</span> <span class="pre">as</span> <span class="pre">NAME</span></code> double star pattern is present, that name is bound to a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> containing any remaining key-value pairs from the subject mapping
(the dict will be empty if there are no additional key-value pairs).</p>
<p>A mapping pattern may contain at most one double star pattern,
and it must be last.</p>
<p>Value subpatterns are mostly required to be closed patterns, but the parentheses
may be omitted for value constraints (the <code class="docutils literal notranslate"><span class="pre">:</span></code> key/value separator is still
required to ensure the entry doesn’t look like an ordinary comparison operation).</p>
<p>Mapping values may also be captured unconditionally using the <code class="docutils literal notranslate"><span class="pre">KEY</span> <span class="pre">as</span> <span class="pre">NAME</span></code>
form, without either parentheses or the <code class="docutils literal notranslate"><span class="pre">:</span></code> key/value separator.</p>
</section>
<section id="instance-attribute-constraints">
<h4><a class="toc-backref" href="#instance-attribute-constraints" role="doc-backlink">Instance attribute constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>attrs_constraint:
    | name_or_attr &#39;{&#39; [attrs_constraint_elements] &#39;}&#39;
attrs_constraint_elements: &#39;,&#39;.attr_value_pattern+ &#39;,&#39;?
attr_value_pattern:
    | &#39;.&#39; NAME pattern_as_clause
    | &#39;.&#39; NAME value_constraint
    | &#39;.&#39; NAME &#39;:&#39; simple_pattern
    | &#39;.&#39; NAME
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchAttrs</span><span class="p">(</span><span class="n">expr</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">identifier</span><span class="o">*</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">pattern</span><span class="o">*</span> <span class="n">patterns</span><span class="p">)</span>
</pre></div>
</div>
<p>Instance attribute constraints allow an instance’s type to be checked and
attributes to optionally be extracted.</p>
<p>An instance attribute constraint may not repeat the same attribute name multiple
times. Attempting to do so will result in a syntax error.</p>
<p>An instance attribute pattern fails if the subject is not an instance of
<code class="docutils literal notranslate"><span class="pre">name_or_attr</span></code>. This is tested using <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name_or_attr</span></code> is not an instance of the builtin <code class="docutils literal notranslate"><span class="pre">type</span></code>,
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
<p>If no attribute subpatterns are present, the constraint succeeds if the
<code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> check succeeds. Otherwise:</p>
<blockquote>
<div><ul class="simple">
<li>Each given attribute name is looked up as an attribute on the subject.<ul>
<li>If this raises an exception other than <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>,
the exception bubbles up.</li>
<li>If this raises <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> the constraint fails.</li>
<li>Otherwise, the subpattern associated with the keyword is matched
against the attribute value. If no subpattern is specified, the wildcard
pattern is assumed. If this fails, the constraint fails.
If it succeeds, the match proceeds to the next attribute.</li>
</ul>
</li>
<li>If all attribute subpatterns succeed, the constraint as a whole succeeds.</li>
</ul>
</div></blockquote>
<p>Instance attribute constraints allow ducktyping checks to be implemented by
using <code class="docutils literal notranslate"><span class="pre">object</span></code> as the required instance type (e.g.
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">object{.host</span> <span class="pre">as</span> <span class="pre">host,</span> <span class="pre">.port</span> <span class="pre">as</span> <span class="pre">port}:</span></code>).</p>
<p>The syntax being proposed here could potentially also be used as the basis for
a new syntax for retrieving multiple attributes from an object instance in one
assignment statement (e.g. <code class="docutils literal notranslate"><span class="pre">host,</span> <span class="pre">port</span> <span class="pre">=</span> <span class="pre">addr{.host,</span> <span class="pre">.port}</span></code>). See the
Deferred Ideas section for further discussion of this point.</p>
</section>
<section id="class-defined-constraints">
<h4><a class="toc-backref" href="#class-defined-constraints" role="doc-backlink">Class defined constraints</a></h4>
<p>Surface syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class_constraint:
    | name_or_attr &#39;(&#39; &#39;)&#39;
    | name_or_attr &#39;(&#39; positional_patterns &#39;,&#39;? &#39;)&#39;
    | name_or_attr &#39;(&#39; class_constraint_attrs &#39;)&#39;
    | name_or_attr &#39;(&#39; positional_patterns &#39;,&#39; class_constraint_attrs] &#39;)&#39;
positional_patterns: &#39;,&#39;.positional_pattern+
positional_pattern:
    | simple_pattern
    | pattern_as_clause
class_constraint_attrs:
    | &#39;**&#39; &#39;{&#39; [attrs_constraint_elements] &#39;}&#39;
</pre></div>
</div>
<p>Abstract syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MatchClass</span><span class="p">(</span><span class="n">expr</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">pattern</span><span class="o">*</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">identifier</span><span class="o">*</span> <span class="n">extra_attrs</span><span class="p">,</span> <span class="n">pattern</span><span class="o">*</span> <span class="n">extra_patterns</span><span class="p">)</span>
</pre></div>
</div>
<p>Class defined constraints allow a sequence of common attributes to be
specified on a class and checked positionally, rather than needing to specify
the attribute names in every related match pattern.</p>
<p>As for instance attribute patterns:</p>
<ul class="simple">
<li>a class defined pattern fails if the subject is not an instance of
<code class="docutils literal notranslate"><span class="pre">name_or_attr</span></code>. This is tested using <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>.</li>
<li>if <code class="docutils literal notranslate"><span class="pre">name_or_attr</span></code> is not an instance of the builtin <code class="docutils literal notranslate"><span class="pre">type</span></code>,
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</li>
</ul>
<p>Regardless of whether or not any arguments are present, the subject is checked
for a <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> attribute using the equivalent of
<code class="docutils literal notranslate"><span class="pre">getattr(cls,</span> <span class="pre">&quot;__match_args__&quot;,</span> <span class="pre">_SENTINEL))</span></code>.</p>
<p>If this raises an exception the exception bubbles up.</p>
<p>If the returned value is not a list, tuple, or <code class="docutils literal notranslate"><span class="pre">None</span></code>, the conversion fails
and <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised at runtime.</p>
<p>This means that only types that actually define <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> will be
usable in class defined patterns. Types that don’t define <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>
will still be usable in instance attribute patterns.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then only a single positional subpattern is
permitted. Attempting to specify additional attribute patterns either
positionally or using the double star syntax will cause <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> to be
raised at runtime.</p>
<p>This positional subpattern is then matched against the entire subject, allowing
a type check to be combined with another match pattern (e.g. checking both
the type and contents of a container, or the type and value of a number).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> is a list or tuple, then the class defined constraint is
converted to an instance attributes constraint as follows:</p>
<ul class="simple">
<li>if only the double star attribute constraints subpattern is present, matching
proceeds as if for the equivalent instance attributes constraint.</li>
<li>if there are more positional subpatterns than the length of
<code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> (as obtained using <code class="docutils literal notranslate"><span class="pre">len()</span></code>), <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</li>
<li>Otherwise, positional pattern <code class="docutils literal notranslate"><span class="pre">i</span></code> is converted to an attribute pattern
using <code class="docutils literal notranslate"><span class="pre">__match_args__[i]</span></code> as the attribute name.</li>
<li>if any element in <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> is not a string, <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</li>
<li>once the positional patterns have been converted to attribute patterns, then
they are combined with any attribute constraints given in the double star
attribute constraints subpattern, and matching proceeds as if for the
equivalent instance attributes constraint.</li>
</ul>
<p>Note: the <code class="docutils literal notranslate"><span class="pre">__match_args__</span> <span class="pre">is</span> <span class="pre">None</span></code> handling in this PEP replaces the special
casing of <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">dict</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>,
<code class="docutils literal notranslate"><span class="pre">frozenset</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, and <code class="docutils literal notranslate"><span class="pre">tuple</span></code> in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.
However, the optimised fast path for those types is retained in the
implementation.</p>
</section>
</section>
</section>
<section id="design-discussion">
<h2><a class="toc-backref" href="#design-discussion" role="doc-backlink">Design Discussion</a></h2>
<section id="requiring-explicit-qualification-of-simple-names-in-match-patterns">
<h3><a class="toc-backref" href="#requiring-explicit-qualification-of-simple-names-in-match-patterns" role="doc-backlink">Requiring explicit qualification of simple names in match patterns</a></h3>
<p>The first iteration of this PEP accepted the basic premise of <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> that
iterable unpacking syntax would provide a good foundation for defining a new
syntax for pattern matching.</p>
<p>During the review process, however, two major and one minor ambiguity problems
were highlighted that arise directly from that core assumption:</p>
<ul class="simple">
<li>most problematically, when binding simple names by default is extended to
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s proposed class pattern syntax, the <code class="docutils literal notranslate"><span class="pre">ATTR=TARGET_NAME</span></code> construct
binds to the right without using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword, and uses the normal
assignment-to-the-left sigil (<code class="docutils literal notranslate"><span class="pre">=</span></code>) to do it!</li>
<li>when binding simple names by default is extended to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s proposed mapping
pattern syntax, the <code class="docutils literal notranslate"><span class="pre">KEY:</span> <span class="pre">TARGET_NAME</span></code> construct binds to the right without
using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword</li>
<li>using a <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> capture pattern together with an AS pattern
(<code class="docutils literal notranslate"><span class="pre">TARGET_NAME_1</span> <span class="pre">as</span> <span class="pre">TARGET_NAME_2</span></code>) gives an odd “binds to both the left and
right” behaviour</li>
</ul>
<p>The third revision of this PEP accounted for this problem by abandoning the
alignment with iterable unpacking syntax, and instead requiring that all uses
of bare simple names for anything other than a variable lookup be qualified by
a preceding sigil or keyword:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">NAME</span></code>: local variable binding</li>
<li><code class="docutils literal notranslate"><span class="pre">.NAME</span></code>: attribute lookup</li>
<li><code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">NAME</span></code>: variable lookup</li>
<li><code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">NAME</span></code>: variable lookup</li>
<li>any other usage: variable lookup</li>
</ul>
<p>The key benefit of this approach is that it makes interpretation of simple names
in patterns a local activity: a leading <code class="docutils literal notranslate"><span class="pre">as</span></code> indicates a name binding, a
leading <code class="docutils literal notranslate"><span class="pre">.</span></code> indicates an attribute lookup, and anything else is a variable
lookup (regardless of whether we’re reading a subpattern or a subexpression).</p>
<p>With the syntax now proposed in this PEP, the problematic cases identified above
no longer read poorly:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.ATTR</span> <span class="pre">as</span> <span class="pre">TARGET_NAME</span></code> is more obviously a binding than <code class="docutils literal notranslate"><span class="pre">ATTR=TARGET_NAME</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">KEY</span> <span class="pre">as</span> <span class="pre">TARGET_NAME</span></code> is more obviously a binding than <code class="docutils literal notranslate"><span class="pre">KEY:</span> <span class="pre">TARGET_NAME</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">(as</span> <span class="pre">TARGET_NAME_1)</span> <span class="pre">as</span> <span class="pre">TARGET_NAME_2</span></code> is more obviously two bindings than
<code class="docutils literal notranslate"><span class="pre">TARGET_NAME_1</span> <span class="pre">as</span> <span class="pre">TARGET_NAME_2</span></code></li>
</ul>
</section>
<section id="resisting-the-temptation-to-guess">
<h3><a class="toc-backref" href="#resisting-the-temptation-to-guess" role="doc-backlink">Resisting the temptation to guess</a></h3>
<p><a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a> looks at the way pattern matching is used in other languages, and
attempts to use that information to make plausible predictions about the way
pattern matching will be used in Python:</p>
<ul class="simple">
<li>wanting to extract values to local names will <em>probably</em> be more common than
wanting to match against values stored in local names</li>
<li>wanting comparison by equality will <em>probably</em> be more common than wanting
comparison by identity</li>
<li>users will <em>probably</em> be able to at least remember that bare names bind values
and attribute references look up values, even if they can’t figure that out
for themselves without reading the documentation or having someone tell them</li>
</ul>
<p>To be clear, I think these predictions actually <em>are</em> plausible. However, I also
don’t think we need to guess about this up front: I think we can start out with
a more explicit syntax that requires users to state their intent using a prefix
marker (either <code class="docutils literal notranslate"><span class="pre">as</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, or <code class="docutils literal notranslate"><span class="pre">is</span></code>), and then reassess the situation in a
few years based on how pattern matching is actually being used <em>in Python</em>.</p>
<p>At that point, we’ll be able to choose amongst at least the following options:</p>
<ul class="simple">
<li>deciding the explicit syntax is concise enough, and not changing anything</li>
<li>adding inferred identity constraints for one or more of <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">...</span></code>,
<code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code></li>
<li>adding inferred equality constraints for other literals (potentially including
complex literals)</li>
<li>adding inferred equality constraints for attribute lookups</li>
<li>adding either inferred equality constraints or inferred capture patterns for
bare names</li>
</ul>
<p>All of those ideas could be considered independently on their own merits, rather
than being a potential barrier to introducing pattern matching in the first
place.</p>
<p>If any of these syntactic shortcuts were to eventually be introduced, they’d
also be straightforward to explain in terms of the underlying more explicit
syntax (the leading <code class="docutils literal notranslate"><span class="pre">as</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, or <code class="docutils literal notranslate"><span class="pre">is</span></code> would just be getting inferred
by the parser, without the user needing to provide it explicitly). At the
implementation level, only the parser should need to be change, as the existing
AST nodes could be reused.</p>
</section>
<section id="interaction-with-caching-of-attribute-lookups-in-local-variables">
<h3><a class="toc-backref" href="#interaction-with-caching-of-attribute-lookups-in-local-variables" role="doc-backlink">Interaction with caching of attribute lookups in local variables</a></h3>
<p>One of the major changes between this PEP and <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> is to use <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">EXPR</span></code>
for equality constraint lookups, rather than only offering <code class="docutils literal notranslate"><span class="pre">NAME.ATTR</span></code>. The
original motivation for this was to avoid the semantic conflict with regular
assignment targets, where <code class="docutils literal notranslate"><span class="pre">NAME.ATTR</span></code> is already used in assignment statements
to set attributes, so if <code class="docutils literal notranslate"><span class="pre">NAME.ATTR</span></code> were the <em>only</em> syntax for symbolic value
matching, then we’re pre-emptively ruling out any future attempts to allow
matching against single patterns using the existing assignment statement syntax.
The current motivation is more about the general desire to avoid guessing about
user’s intent, and instead requiring them to state it explicitly in the syntax.</p>
<p>However, even within match statements themselves, the <code class="docutils literal notranslate"><span class="pre">name.attr</span></code> syntax for
value patterns has an undesirable interaction with local variable assignment,
where routine refactorings that would be semantically neutral for any other
Python statement introduce a major semantic change when applied to a <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>
style match statement.</p>
<p>Consider the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># Some code that adjusts &quot;value&quot;</span>
</pre></div>
</div>
<p>The attribute lookup can be safely lifted out of the loop and only performed
once:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
<span class="k">while</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">_limit</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># Some code that adjusts &quot;value&quot;</span>
</pre></div>
</div>
<p>With the marker prefix based syntax proposal in this PEP, value constraints
would be similarly tolerant of match patterns being refactored to use a local
variable instead of an attribute lookup, with the following two statements
being functionally equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">}:</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr[&quot;key&quot;] == self.target&#39;</span>
    <span class="k">case</span> <span class="n">__</span><span class="p">:</span>
        <span class="o">...</span> <span class="c1"># Handle the non-matching case</span>

<span class="n">_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="o">==</span> <span class="n">_target</span><span class="p">}:</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr[&quot;key&quot;] == self.target&#39;</span>
    <span class="k">case</span> <span class="n">__</span><span class="p">:</span>
        <span class="o">...</span> <span class="c1"># Handle the non-matching case</span>
</pre></div>
</div>
<p>By contrast, when using <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s value and capture pattern syntaxes that omit
the marker prefix, the following two statements wouldn’t be equivalent at all:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># PEP 634&#39;s value pattern syntax</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">}:</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr[&quot;key&quot;] == self.target&#39;</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
        <span class="o">...</span> <span class="c1"># Handle the non-matching case</span>

<span class="c1"># PEP 634&#39;s capture pattern syntax</span>
<span class="n">_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">_target</span><span class="p">}:</span>
        <span class="o">...</span> <span class="c1"># Matches any mapping with &quot;key&quot;, binding its value to _target</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
        <span class="o">...</span> <span class="c1"># Handle the non-matching case</span>
</pre></div>
</div>
<p>This PEP ensures the original semantics are retained under this style of
simplistic refactoring: use <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">name</span></code> to force interpretation of the result
as a value constraint, use <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">name</span></code> for a name binding.</p>
<p><a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s proposal to offer only the shorthand syntax, with no explicitly
prefixed form, means that the primary answer on offer is “Well, don’t do that,
then, only compare against attributes in namespaces, don’t compare against
simple names”.</p>
<p><a class="pep reference internal" href="../pep-0622/" title="PEP 622 – Structural Pattern Matching">PEP 622</a>’s walrus pattern syntax had another odd interaction where it might not
bind the same object as the exact same walrus expression in the body of the
case clause, but <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> fixed that discrepancy by replacing walrus patterns
with AS patterns (where the fact that the value bound to the name on the RHS
might not be the same value as returned by the LHS is a standard feature common
to all uses of the “as” keyword).</p>
</section>
<section id="using-existing-comparison-operators-as-the-value-constraint-prefix">
<h3><a class="toc-backref" href="#using-existing-comparison-operators-as-the-value-constraint-prefix" role="doc-backlink">Using existing comparison operators as the value constraint prefix</a></h3>
<p>If the benefit of a dedicated value constraint prefix is accepted, then the
next question is to ask exactly what that prefix should be.</p>
<p>The initially published version of this PEP proposed using the previously
unused <code class="docutils literal notranslate"><span class="pre">?</span></code> symbol as the prefix for equality constraints, and <code class="docutils literal notranslate"><span class="pre">?is</span></code> as the
prefix for identity constraints. When reviewing the PEP, Steven D’Aprano
presented a compelling counterproposal <a class="footnote-reference brackets" href="#id15" id="id5">[5]</a> to use the existing comparison
operators (<code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">is</span></code>) instead.</p>
<p>There were a few concerns with <code class="docutils literal notranslate"><span class="pre">==</span></code> as a prefix that kept it from being
chosen as the prefix in the initial iteration of the PEP:</p>
<ul class="simple">
<li>for common use cases, it’s even more visually noisy than <code class="docutils literal notranslate"><span class="pre">?</span></code>, as a lot of
folks with <a class="pep reference internal" href="../pep-0008/" title="PEP 8 – Style Guide for Python Code">PEP 8</a> trained aesthetic sensibilities are going to want to put
a space between it and the following expression, effectively making it a 3
character prefix instead of 1</li>
<li>when used in a mapping pattern, there needs to be a space between the <code class="docutils literal notranslate"><span class="pre">:</span></code>
key/value separator and the <code class="docutils literal notranslate"><span class="pre">==</span></code> prefix, or the tokeniser will split them
up incorrectly (getting <code class="docutils literal notranslate"><span class="pre">:=</span></code> and <code class="docutils literal notranslate"><span class="pre">=</span></code> instead of <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code>)</li>
<li>when used in an OR pattern, there needs to be a space between the <code class="docutils literal notranslate"><span class="pre">|</span></code>
pattern separator and the <code class="docutils literal notranslate"><span class="pre">==</span></code> prefix, or the tokeniser will split them
up incorrectly (getting <code class="docutils literal notranslate"><span class="pre">|=</span></code> and <code class="docutils literal notranslate"><span class="pre">=</span></code> instead of <code class="docutils literal notranslate"><span class="pre">|</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code>)</li>
<li>if used in a <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> style class pattern, there needs to be a space between
the <code class="docutils literal notranslate"><span class="pre">=</span></code> keyword separator and the <code class="docutils literal notranslate"><span class="pre">==</span></code> prefix, or the tokeniser will split
them up incorrectly (getting <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">=</span></code> instead of <code class="docutils literal notranslate"><span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code>)</li>
</ul>
<p>Rather than introducing a completely new symbol, Steven’s proposed resolution to
this verbosity problem was to retain the ability to omit the prefix marker in
syntactically unambiguous cases.</p>
<p>While the idea of omitting the prefix marker was accepted for the second
revision of the proposal, it was dropped again in the third revision due to
ambiguity concerns. Instead, the following points apply:</p>
<ul class="simple">
<li>for class patterns, other syntax changes allow equality constraints to be
written as <code class="docutils literal notranslate"><span class="pre">.ATTR</span> <span class="pre">==</span> <span class="pre">EXPR</span></code>, and identity constraints to be written as
<code class="docutils literal notranslate"><span class="pre">.ATTR</span> <span class="pre">is</span> <span class="pre">EXPR</span></code>, both of which are quite easy to read</li>
<li>for mapping patterns, the extra syntactic noise is just tolerated (at least
for now)</li>
<li>for OR patterns, the extra syntactic noise is just tolerated (at least
for now). However, <a class="reference internal" href="#membership-constraints">membership constraints</a> may offer a future path to
reducing the need to combine OR patterns with equality constraints (instead,
the values to be checked against would be collected as a set, list, or tuple).</li>
</ul>
<p>Given that perspective, <a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a>’s arguments against using <code class="docutils literal notranslate"><span class="pre">?</span></code> as part of the
pattern matching syntax held for this proposal as well, and so the PEP was
amended accordingly.</p>
</section>
<section id="using-as-the-wildcard-pattern-marker">
<h3><a class="toc-backref" href="#using-as-the-wildcard-pattern-marker" role="doc-backlink">Using <code class="docutils literal notranslate"><span class="pre">__</span></code> as the wildcard pattern marker</a></h3>
<p><a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a> makes a solid case that introducing <code class="docutils literal notranslate"><span class="pre">?</span></code> <em>solely</em> as a wildcard pattern
marker would be a bad idea. With the syntax for value constraints changed
to use existing comparison operations rather than <code class="docutils literal notranslate"><span class="pre">?</span></code> and <code class="docutils literal notranslate"><span class="pre">?is</span></code>, that
argument holds for this PEP as well.</p>
<p>However, as noted by Thomas Wouters in <a class="footnote-reference brackets" href="#id16" id="id6">[6]</a>, <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s choice of <code class="docutils literal notranslate"><span class="pre">_</span></code> remains
problematic as it would likely mean that match patterns would have a <em>permanent</em>
difference from all other parts of Python - the use of <code class="docutils literal notranslate"><span class="pre">_</span></code> in software
internationalisation and at the interactive prompt means that there isn’t really
a plausible path towards using it as a general purpose “skipped binding” marker.</p>
<p><code class="docutils literal notranslate"><span class="pre">__</span></code> is an alternative “this value is not needed” marker drawn from a Stack
Overflow answer <a class="footnote-reference brackets" href="#id17" id="id7">[7]</a> (originally posted by the author of this PEP) on the
various meanings of <code class="docutils literal notranslate"><span class="pre">_</span></code> in existing Python code.</p>
<p>This PEP also proposes adopting an implementation technique that limits
the scope of the associated special casing of <code class="docutils literal notranslate"><span class="pre">__</span></code> to the parser: defining a
new AST node type (<code class="docutils literal notranslate"><span class="pre">MatchAlways</span></code>) specifically for wildcard markers, rather
than passing it through to the AST as a <code class="docutils literal notranslate"><span class="pre">Name</span></code> node.</p>
<p>Within the parser, <code class="docutils literal notranslate"><span class="pre">__</span></code> still means either a regular name or a wildcard
marker in a match pattern depending on where you were in the parse tree, but
within the rest of the compiler, <code class="docutils literal notranslate"><span class="pre">Name(&quot;__&quot;)</span></code> is still a normal variable name,
while <code class="docutils literal notranslate"><span class="pre">MatchAlways()</span></code> is always a wildcard marker in a match pattern.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">_</span></code>, the lack of other use cases for <code class="docutils literal notranslate"><span class="pre">__</span></code> means that there would be
a plausible path towards restoring identifier handling consistency with the rest
of the language by making <code class="docutils literal notranslate"><span class="pre">__</span></code> mean “skip this name binding” everywhere in
Python:</p>
<ul class="simple">
<li>in the interpreter itself, deprecate loading variables with the name <code class="docutils literal notranslate"><span class="pre">__</span></code>.
This would make reading from <code class="docutils literal notranslate"><span class="pre">__</span></code> emit a deprecation warning, while writing
to it would initially be unchanged. To avoid slowing down all name loads, this
could be handled by having the compiler emit additional code for the
deprecated name, rather than using a runtime check in the standard name
loading opcodes.</li>
<li>after a suitable number of releases, change the parser to emit
a new <code class="docutils literal notranslate"><span class="pre">SkippedBinding</span></code> AST node for all uses of <code class="docutils literal notranslate"><span class="pre">__</span></code> as an assignment
target, and update the rest of the compiler accordingly</li>
<li>consider making <code class="docutils literal notranslate"><span class="pre">__</span></code> a true hard keyword rather than a soft keyword</li>
</ul>
<p>This deprecation path couldn’t be followed for <code class="docutils literal notranslate"><span class="pre">_</span></code>, as there’s no way for the
interpreter to distinguish between attempts to read back <code class="docutils literal notranslate"><span class="pre">_</span></code> when nominally
used as a “don’t care” marker, and legitimate reads of <code class="docutils literal notranslate"><span class="pre">_</span></code> as either an
i18n text translation function or as the last statement result at the
interactive prompt.</p>
<p>Names starting with double-underscores are also already reserved for use by the
language, whether that is for compile time constants (i.e. <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>),
special methods, or class attribute name mangling, so using <code class="docutils literal notranslate"><span class="pre">__</span></code> here would
be consistent with that existing approach.</p>
</section>
<section id="representing-patterns-explicitly-in-the-abstract-syntax-tree">
<h3><a class="toc-backref" href="#representing-patterns-explicitly-in-the-abstract-syntax-tree" role="doc-backlink">Representing patterns explicitly in the Abstract Syntax Tree</a></h3>
<p><a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> doesn’t explicitly discuss how match statements should be represented
in the Abstract Syntax Tree, instead leaving that detail to be defined as part
of the implementation.</p>
<p>As a result, while the reference implementation of <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> definitely works (and
formed the basis of the reference implementation of this PEP), it does contain
a significant design flaw: despite the notes in <a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a> that patterns should be
considered as distinct from expressions, the reference implementation goes ahead
and represents them in the AST as expression nodes.</p>
<p>The result is an AST that isn’t very abstract at all: nodes that should be
compiled completely differently (because they’re patterns rather than
expressions) are represented the same way, and the type system of the
implementation language (e.g. C for CPython) can’t offer any assistance in
keeping track of which subnodes should be ordinary expressions and which should
be subpatterns.</p>
<p>Rather than continuing with that approach, this PEP has instead defined a new
explicit “pattern” node in the AST, which allows the patterns and their
permitted subnodes to be defined explicitly in the AST itself, making the code
implementing the new feature clearer, and allowing the C compiler to provide
more assistance in keeping track of when the code generator is dealing with
patterns or expressions.</p>
<p>This change in implementation approach is actually orthogonal to the surface
syntax changes proposed in this PEP, so it could still be adopted even if the
rest of the PEP were to be rejected.</p>
</section>
<section id="changes-to-sequence-patterns">
<h3><a class="toc-backref" href="#changes-to-sequence-patterns" role="doc-backlink">Changes to sequence patterns</a></h3>
<p>This PEP makes one notable change to sequence patterns relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>:</p>
<ul class="simple">
<li>only the square bracket form of sequence pattern is supported. Neither open
(no delimiters) nor tuple style (parentheses as delimiters) sequence patterns
are supported.</li>
</ul>
<p>Relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, sequence patterns are also significantly affected by the
change to require explicit qualification of capture patterns and value
constraints, as it means <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]:</span></code> must instead be written as
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[as</span> <span class="pre">a,</span> <span class="pre">as</span> <span class="pre">b,</span> <span class="pre">as</span> <span class="pre">c]:</span></code> and <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[0,</span> <span class="pre">1]:</span></code> must instead be written as
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">[==</span> <span class="pre">0,</span> <span class="pre">==</span> <span class="pre">1]:</span></code>.</p>
<p>With the syntax for sequence patterns no longer being derived directly from the
syntax for iterable unpacking, it no longer made sense to keep the syntactic
flexibility that had been included in the original syntax proposal purely for
consistency with iterable unpacking.</p>
<p>Allowing open and tuple style sequence patterns didn’t increase expressivity,
only ambiguity of intent (especially relative to group patterns), and encouraged
readers down the path of viewing pattern matching syntax as intrinsically linked
to assignment target syntax (which the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> authors have stated multiple
times is not a desirable path to have readers take, and a view the author of
this PEP now shares, despite disagreeing with it originally).</p>
</section>
<section id="changes-to-mapping-patterns">
<h3><a class="toc-backref" href="#changes-to-mapping-patterns" role="doc-backlink">Changes to mapping patterns</a></h3>
<p>This PEP makes two notable changes to mapping patterns relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>:</p>
<ul class="simple">
<li>value capturing is written as <code class="docutils literal notranslate"><span class="pre">KEY</span> <span class="pre">as</span> <span class="pre">NAME</span></code> rather than as <code class="docutils literal notranslate"><span class="pre">KEY:</span> <span class="pre">NAME</span></code></li>
<li>a wider range of keys are permitted: any “closed expression”, rather than
only literals and attribute references</li>
</ul>
<p>As discussed above, the first change is part of ensuring that all binding
operations with the target name to the right of a subexpression or pattern
use the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword.</p>
<p>The second change is mostly a matter of simplifying the parser and code
generator code by reusing the existing expression handling machinery. The
restriction to closed expressions is designed to help reduce ambiguity as to
where the key expression ends and the match pattern begins. This mostly allows
a superset of what <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> allows, except that complex literals must be written
in parentheses (at least for now).</p>
<p>Adapting <a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a>’s mapping pattern examples to the syntax proposed in this PEP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">json_pet</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="o">==</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span> <span class="k">as</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;pattern&quot;</span> <span class="k">as</span> <span class="n">pattern</span><span class="p">}:</span>
        <span class="k">return</span> <span class="n">Cat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="o">==</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span> <span class="k">as</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;breed&quot;</span> <span class="k">as</span> <span class="n">breed</span><span class="p">}:</span>
        <span class="k">return</span> <span class="n">Dog</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">breed</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">__</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not a suitable pet&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">change_red_to_blue</span><span class="p">(</span><span class="n">json_obj</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">json_obj</span><span class="p">:</span>
        <span class="k">case</span> <span class="p">{</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">==</span> <span class="s1">&#39;red&#39;</span> <span class="o">|</span> <span class="o">==</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">)</span> <span class="p">}:</span>
            <span class="n">json_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
        <span class="k">case</span> <span class="p">{</span> <span class="s1">&#39;children&#39;</span> <span class="k">as</span> <span class="n">children</span> <span class="p">}:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">change_red_to_blue</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>
</div>
<p>For reference, the equivalent <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">json_pet</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;pattern&quot;</span><span class="p">:</span> <span class="n">pattern</span><span class="p">}:</span>
        <span class="k">return</span> <span class="n">Cat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="n">breed</span><span class="p">}:</span>
        <span class="k">return</span> <span class="n">Dog</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">breed</span><span class="p">)</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not a suitable pet&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">change_red_to_blue</span><span class="p">(</span><span class="n">json_obj</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">json_obj</span><span class="p">:</span>
        <span class="k">case</span> <span class="p">{</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;red&#39;</span> <span class="o">|</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">)</span> <span class="p">}:</span>
            <span class="n">json_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
        <span class="k">case</span> <span class="p">{</span> <span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="n">children</span> <span class="p">}:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">change_red_to_blue</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="changes-to-class-patterns">
<h3><a class="toc-backref" href="#changes-to-class-patterns" role="doc-backlink">Changes to class patterns</a></h3>
<p>This PEP makes several notable changes to class patterns relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>:</p>
<ul class="simple">
<li>the syntactic alignment with class instantiation is abandoned as being
actively misleading and unhelpful. Instead, a new dedicated syntax for
checking additional attributes is introduced that draws inspiration from
mapping patterns rather than class instantiation</li>
<li>a new dedicated syntax for simple ducktyping that will work for any class
is introduced</li>
<li>the special casing of various builtin and standard library types is
supplemented by a general check for the existence of a <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>
attribute with the value of <code class="docutils literal notranslate"><span class="pre">None</span></code></li>
</ul>
<p>As discussed above, the first change has two purposes:</p>
<ul class="simple">
<li>it’s part of ensuring that all binding operations with the target name to the
right of a subexpression or pattern use the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword. Using <code class="docutils literal notranslate"><span class="pre">=</span></code> to
assign to the right is particularly problematic.</li>
<li>it’s part of ensuring that all uses of simple names in patterns have a prefix
that indicates their purpose (in this case, a leading <code class="docutils literal notranslate"><span class="pre">.</span></code> to indicate an
attribute lookup)</li>
</ul>
<p>The syntactic alignment with class instantion was also judged to be unhelpful
in general, as class patterns are about matching patterns against attributes,
while class instantiation is about matching call arguments to parameters in
class constructors, which may not bear much resemblance to the resulting
instance attributes at all.</p>
<p>The second change is intended to make it easier to use pattern matching for the
“ducktyping” style checks that are already common in Python.</p>
<p>The concrete syntax proposal for these patterns then arose from viewing
instances as mappings of attribute names to values, and combining the attribute
lookup syntax (<code class="docutils literal notranslate"><span class="pre">.ATTR</span></code>), with the mapping pattern syntax <code class="docutils literal notranslate"><span class="pre">{KEY:</span> <span class="pre">PATTERN}</span></code>
to give <code class="docutils literal notranslate"><span class="pre">cls{.ATTR:</span> <span class="pre">PATTERN}</span></code>.</p>
<p>Allowing <code class="docutils literal notranslate"><span class="pre">cls{.ATTR}</span></code> to mean the same thing as <code class="docutils literal notranslate"><span class="pre">cls{.ATTR:</span> <span class="pre">__}</span></code> was a
matter of considering the leading <code class="docutils literal notranslate"><span class="pre">.</span></code> sufficient to render the name usage
unambiguous (it’s clearly an attribute reference, whereas matching against a variable
key in a mapping pattern would be arguably ambiguous)</p>
<p>The final change just supplements a CPython-internal-only check in the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>
reference implementation by making it the default behaviour that classes get if
they don’t define <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> (the optimised fast path for the builtin
and standard library types named in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> is retained).</p>
<p>Adapting the class matching example
<a class="reference external" href="https://github.com/gvanrossum/patma/blob/be5969442d0584005492134c3b24eea408709db2/examples/expr.py#L231">linked from PEP 635</a>
shows that for purely positional class matching, the main impact comes from the
changes to value constraints and name binding, not from the class matching
changes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">left</span><span class="p">,</span> <span class="k">as</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">left</span><span class="p">,</span> <span class="k">as</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">left</span><span class="p">,</span> <span class="k">as</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">left</span><span class="p">,</span> <span class="k">as</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">UnaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">UnaryOp</span><span class="p">(</span><span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="k">as</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">VarExpr</span><span class="p">(</span><span class="k">as</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown value of: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nb">float</span><span class="p">()</span> <span class="o">|</span> <span class="nb">int</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">case</span> <span class="n">__</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid expression value: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For reference, the equivalent <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">BinaryOp</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">UnaryOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eval_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">UnaryOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">VarExpr</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown value of: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nb">float</span><span class="p">()</span> <span class="o">|</span> <span class="nb">int</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid expression value: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The changes to the class pattern syntax itself are more relevant when
checking for named attributes and extracting their values without relying on
<code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">{</span><span class="o">.</span><span class="n">host</span> <span class="k">as</span> <span class="n">host</span><span class="p">,</span> <span class="o">.</span><span class="n">port</span> <span class="k">as</span> <span class="n">port</span><span class="p">}:</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">{</span><span class="o">.</span><span class="n">host</span> <span class="k">as</span> <span class="n">host</span><span class="p">}:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Compare this to the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> equivalent, where it really isn’t clear which names
are referring to attributes of the match subject and which names are referring
to local variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">port</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">case</span> <span class="nb">object</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>In this specific case, that ambiguity doesn’t matter (since the attribute and
variable names are the same), but in the general case, knowing which is which
will be critical to reasoning correctly about the code being read.</p>
</section>
</section>
<section id="deferred-ideas">
<h2><a class="toc-backref" href="#deferred-ideas" role="doc-backlink">Deferred Ideas</a></h2>
<section id="inferred-value-constraints">
<h3><a class="toc-backref" href="#inferred-value-constraints" role="doc-backlink">Inferred value constraints</a></h3>
<p>As discussed above, this PEP doesn’t rule out the possibility of adding
inferred equality and identity constraints in the future.</p>
<p>These could be particularly valuable for literals, as it is quite likely that
many “magic” strings and numbers with self-evident meanings will be written
directly into match patterns, rather than being stored in named variables.
(Think constants like <code class="docutils literal notranslate"><span class="pre">None</span></code>, or obviously special numbers like <code class="docutils literal notranslate"><span class="pre">0</span></code> and
<code class="docutils literal notranslate"><span class="pre">1</span></code>, or strings where their contents are as descriptive as any variable name,
rather than cryptic checks against opaque numbers like <code class="docutils literal notranslate"><span class="pre">739452</span></code>)</p>
</section>
<section id="making-some-required-parentheses-optional">
<h3><a class="toc-backref" href="#making-some-required-parentheses-optional" role="doc-backlink">Making some required parentheses optional</a></h3>
<p>The PEP currently errs heavily on the side of requiring parentheses in the face
of potential ambiguity.</p>
<p>However, there are a number of cases where it at least arguably goes too far,
mostly involving AS patterns with an explicit pattern.</p>
<p>In any position that requires a closed pattern, AS patterns may end up starting
with doubled parentheses, as the nested pattern is also required to be a closed
pattern: <code class="docutils literal notranslate"><span class="pre">((OPEN</span> <span class="pre">PTRN)</span> <span class="pre">as</span> <span class="pre">NAME)</span></code></p>
<p>Due to the requirement that the subpattern be closed, it should be reasonable
in many of these cases (e.g. sequence pattern subpatterns) to accept
<code class="docutils literal notranslate"><span class="pre">CLOSED_PTRN</span> <span class="pre">as</span> <span class="pre">NAME</span></code> directly.</p>
<p>Further consideration of this point has been deferred, as making required
parentheses optional is a backwards compatible change, and hence relaxing the
restrictions later can be considered on a case-by-case basis.</p>
</section>
<section id="accepting-complex-literals-as-closed-expressions">
<h3><a class="toc-backref" href="#accepting-complex-literals-as-closed-expressions" role="doc-backlink">Accepting complex literals as closed expressions</a></h3>
<p><a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s reference implementation includes a lot of special casing of binary
operations in both the parser and the rest of the compiler in order to accept
complex literals without accepting arbitrary binary numeric operations on
literal values.</p>
<p>Ideally, this problem would be dealt with at the parser layer, with the parser
directly emitting a Constant AST node prepopulated with a complex number. If
that was the way things worked, then complex literals could be accepted through
a similar mechanism to any other literal.</p>
<p>This isn’t how complex literals are handled, however. Instead, they’re passed
through to the AST as regular <code class="docutils literal notranslate"><span class="pre">BinOp</span></code> nodes, and then the constant folding
pass on the AST resolves them down to <code class="docutils literal notranslate"><span class="pre">Constant</span></code> nodes with a complex value.</p>
<p>For the parser to resolve complex literals directly, the compiler would need to
be able to tell the tokenizer to generate a distinct token type for
imaginary numbers (e.g. <code class="docutils literal notranslate"><span class="pre">INUMBER</span></code>), which would then allow the parser to
handle <code class="docutils literal notranslate"><span class="pre">NUMBER</span> <span class="pre">+</span> <span class="pre">INUMBER</span></code> and <code class="docutils literal notranslate"><span class="pre">NUMBER</span> <span class="pre">-</span> <span class="pre">INUMBER</span></code> separately from other
binary operations.</p>
<p>Alternatively, a new <code class="docutils literal notranslate"><span class="pre">ComplexNumber</span></code> AST node type could be defined, which
would allow the parser to notify the subsequent compiler stages that a
particular node should specifically be a complex literal, rather than an
arbitrary binary operation. Then the parser could accept <code class="docutils literal notranslate"><span class="pre">NUMBER</span> <span class="pre">+</span> <span class="pre">NUMBER</span></code>
and <code class="docutils literal notranslate"><span class="pre">NUMBER</span> <span class="pre">-</span> <span class="pre">NUMBER</span></code> for that node, while letting the AST validation for
<code class="docutils literal notranslate"><span class="pre">ComplexNumber</span></code> take care of ensuring that the real and imaginary parts of
the literal were real and imaginary numbers as expected.</p>
<p>For now, this PEP has postponed dealing with this question, and instead just
requires that complex literals be parenthesised in order to be used in value
constraints and as mapping pattern keys.</p>
</section>
<section id="allowing-negated-constraints-in-match-patterns">
<h3><a class="toc-backref" href="#allowing-negated-constraints-in-match-patterns" role="doc-backlink">Allowing negated constraints in match patterns</a></h3>
<p>With the syntax proposed in this PEP, it isn’t permitted to write <code class="docutils literal notranslate"><span class="pre">!=</span> <span class="pre">expr</span></code>
or <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span> <span class="pre">expr</span></code> as a match pattern.</p>
<p>Both of these forms have clear potential interpretations as a negated equality
constraint (i.e. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">expr</span></code>) and a negated identity constraint
(i.e. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">expr</span></code>).</p>
<p>However, it’s far from clear either form would come up often enough to justify
the dedicated syntax, so the possible extension has been deferred pending further
community experience with match statements.</p>
</section>
<section id="allowing-membership-checks-in-match-patterns">
<span id="membership-constraints"></span><h3><a class="toc-backref" href="#allowing-membership-checks-in-match-patterns" role="doc-backlink">Allowing membership checks in match patterns</a></h3>
<p>The syntax used for equality and identity constraints would be straightforward
to extend to membership checks: <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">container</span></code>.</p>
<p>One downside of the proposals in both this PEP and <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> is that checking
for multiple values in the same case doesn’t look like any existing container
membership check in Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># PEP 634&#39;s literal patterns</span>
<span class="k">match</span> <span class="n">value</span><span class="p">:</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># This PEP&#39;s equality constraints</span>
<span class="k">match</span> <span class="n">value</span><span class="p">:</span>
    <span class="n">case</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Allowing inferred equality constraints under this PEP would only make it look
like the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> example, it still wouldn’t look like the equivalent <code class="docutils literal notranslate"><span class="pre">if</span></code>
statement header (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">value</span> <span class="pre">in</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3}:</span></code>).</p>
<p>Membership constraints would provide a more explicit, but still concise, way
to check if the match subject was present in a container, and it would look
the same as an ordinary containment check:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">value</span><span class="p">:</span>
    <span class="n">case</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}:</span>
        <span class="o">...</span>
    <span class="n">case</span> <span class="ow">in</span> <span class="p">{</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="n">four</span><span class="p">}:</span>
        <span class="o">...</span>
    <span class="n">case</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="c1"># It would accept any container, not just literal sets</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Such a feature would also be readily extensible to allow all kinds of case
clauses without any further syntax updates, simply by defining <code class="docutils literal notranslate"><span class="pre">__contains__</span></code>
appropriately on a custom class definition.</p>
<p>However, while this does seem like a useful extension, and a good way to resolve
this PEP’s verbosity problem when combining multiple equality checks in an
OR pattern, it isn’t essential to making match statements a valuable addition
to the language, so it seems more appropriate to defer it to a separate proposal,
rather than including it here.</p>
</section>
<section id="inferring-a-default-type-for-instance-attribute-constraints">
<h3><a class="toc-backref" href="#inferring-a-default-type-for-instance-attribute-constraints" role="doc-backlink">Inferring a default type for instance attribute constraints</a></h3>
<p>The dedicated syntax for instance attribute constraints means that <code class="docutils literal notranslate"><span class="pre">object</span></code>
could be omitted from <code class="docutils literal notranslate"><span class="pre">object{.ATTR}</span></code> to give <code class="docutils literal notranslate"><span class="pre">{.ATTR}</span></code> without introducing
any syntactic ambiguity (if no class was given, <code class="docutils literal notranslate"><span class="pre">object</span></code> would be implied,
just as it is for the base class list in class definitions).</p>
<p>However, it’s far from clear saving six characters is worth making it harder to
visually distinguish mapping patterns from instance attribute patterns, so
allowing this has been deferred as a topic for possible future consideration.</p>
</section>
<section id="avoiding-special-cases-in-sequence-patterns">
<h3><a class="toc-backref" href="#avoiding-special-cases-in-sequence-patterns" role="doc-backlink">Avoiding special cases in sequence patterns</a></h3>
<p>Sequence patterns in both this PEP and <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> currently special case <code class="docutils literal notranslate"><span class="pre">str</span></code>,
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>, and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> as specifically <em>never</em> matching a sequence
pattern.</p>
<p>This special casing could potentially be removed if we were to define a new
<code class="docutils literal notranslate"><span class="pre">collections.abc.AtomicSequence</span></code> abstract base class for types like these,
where they’re conceptually a single item, but still implement the sequence
protocol to allow random access to their component parts.</p>
</section>
<section id="expression-syntax-to-retrieve-multiple-attributes-from-an-instance">
<h3><a class="toc-backref" href="#expression-syntax-to-retrieve-multiple-attributes-from-an-instance" role="doc-backlink">Expression syntax to retrieve multiple attributes from an instance</a></h3>
<p>The instance attribute pattern syntax has been designed such that it could
be used as the basis for a general purpose syntax for retrieving multiple
attributes from an object in a single expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">obj</span><span class="p">{</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="o">.</span><span class="n">port</span><span class="p">}</span>
</pre></div>
</div>
<p>Similar to slice syntax only being allowed inside bracket subscrpts, the
<code class="docutils literal notranslate"><span class="pre">.attr</span></code> syntax for naming attributes would only be allowed inside brace
subscripts.</p>
<p>This idea isn’t required for pattern matching to be useful, so it isn’t part of
this PEP. However, it’s mentioned as a possible path towards making pattern
matching feel more integrated into the rest of the language, rather than
existing forever in its own completely separated world.</p>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Expression syntax to retrieve multiple attributes from an instance</a></h3>
<p>If the brace subscript syntax were to be accepted for instance attribute
pattern matching, and then subsequently extended to offer general purpose
extraction of multiple attributes, then it could be extended even further to
allow for retrieval of multiple items from containers based on the syntax
used for mapping pattern matching:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">obj</span><span class="p">{</span><span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="s2">&quot;port&quot;</span><span class="p">}</span>
<span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">obj</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
<p>Again, this idea isn’t required for pattern matching to be useful, so it isn’t
part of this PEP. As with retrieving multiple attributes, however, it is
included as an example of the proposed pattern matching syntax inspiring ideas
for making object deconstruction easier in general.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="restricting-permitted-expressions-in-value-constraints-and-mapping-pattern-keys">
<h3><a class="toc-backref" href="#restricting-permitted-expressions-in-value-constraints-and-mapping-pattern-keys" role="doc-backlink">Restricting permitted expressions in value constraints and mapping pattern keys</a></h3>
<p>While it’s entirely technically possible to restrict the kinds of expressions
permitted in value constraints and mapping pattern keys to just attribute
lookups and constant literals (as <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> does), there isn’t any clear runtime
value in doing so, so this PEP proposes allowing any kind of primary expression
(primary expressions are an existing node type in the grammar that includes
things like literals, names, attribute lookups, function calls, container
subscripts, parenthesised groups, etc), as well as high precedence unary
operations (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">~</span></code>) on primary expressions.</p>
<p>While <a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a> does emphasise several times that literal patterns and value
patterns are not full expressions, it doesn’t ever articulate a concrete benefit
that is obtained from that restriction (just a theoretical appeal to it being
useful to separate static checks from dynamic checks, which a code style
tool could still enforce, even if the compiler itself is more permissive).</p>
<p>The last time we imposed such a restriction was for decorator expressions and
the primary outcome of that was that users had to put up with years of awkward
syntactic workarounds (like nesting arbitrary expressions inside function calls
that just returned their argument) to express the behaviour they wanted before
the language definition was finally updated to allow arbitrary expressions and
let users make their own decisions about readability.</p>
<p>The situation in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> that bears a resemblance to the situation with decorator
expressions is that arbitrary expressions are technically supported in value
patterns, they just require awkward workarounds where either all the values to
match need to be specified in a helper class that is placed before the match
statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Allowing arbitrary match targets with PEP 634&#39;s value pattern syntax</span>
<span class="k">class</span><span class="w"> </span><span class="nc">mt</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr[1] == func()&#39;</span>
</pre></div>
</div>
<p>Or else they need to be written as a combination of a capture pattern and a
guard expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Allowing arbitrary match targets with PEP 634&#39;s guard expressions</span>
<span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="n">_matched</span><span class="p">)</span> <span class="k">if</span> <span class="n">_matched</span> <span class="o">==</span> <span class="n">func</span><span class="p">():</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr[1] == func()&#39;</span>
</pre></div>
</div>
<p>This PEP proposes skipping requiring any such workarounds, and instead
supporting arbitrary value constraints from the start:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">__</span><span class="p">,</span> <span class="o">==</span> <span class="n">func</span><span class="p">()):</span>
        <span class="o">...</span> <span class="c1"># Handle the case where &#39;expr == func()&#39;</span>
</pre></div>
</div>
<p>Whether actually writing that kind of code is a good idea would be a topic for
style guides and code linters, not the language compiler.</p>
<p>In particular, if static analysers can’t follow certain kinds of dynamic checks,
then they can limit the permitted expressions at analysis time, rather than the
compiler restricting them at compile time.</p>
<p>There are also some kinds of expressions that are almost certain to give
nonsensical results (e.g. <code class="docutils literal notranslate"><span class="pre">yield</span></code>, <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>, <code class="docutils literal notranslate"><span class="pre">await</span></code>) due to the
pattern caching rule, where the number of times the constraint expression
actually gets evaluated will be implementation dependent. Even here, the PEP
takes the view of letting users write nonsense if they really want to.</p>
<p>Aside from the recently updated decorator expressions, another situation where
Python’s formal syntax offers full freedom of expression that is almost never
used in practice is in <code class="docutils literal notranslate"><span class="pre">except</span></code> clauses: the exceptions to match against
almost always take the form of a simple name, a dotted name, or a tuple of
those, but the language grammar permits arbitrary expressions at that point.
This is a good indication that Python’s user base can be trusted to
take responsibility for finding readable ways to use permissive language
features, by avoiding writing hard to read constructs even when they’re
permitted by the compiler.</p>
<p>This permissiveness comes with a real concrete benefit on the implementation
side: dozens of lines of match statement specific code in the compiler is
replaced by simple calls to the existing code for compiling expressions
(including in the AST validation pass, the AST optimization pass, the symbol
table analysis pass, and the code generation pass). This implementation
benefit would accrue not just to CPython, but to every other Python
implementation looking to add match statement support.</p>
</section>
<section id="requiring-the-use-of-constraint-prefix-markers-for-mapping-pattern-keys">
<h3><a class="toc-backref" href="#requiring-the-use-of-constraint-prefix-markers-for-mapping-pattern-keys" role="doc-backlink">Requiring the use of constraint prefix markers for mapping pattern keys</a></h3>
<p>The initial (unpublished) draft of this proposal suggested requiring mapping
pattern keys be value constraints, just as <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> requires that they be valid
literal or value patterns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">constants</span>

<span class="k">match</span> <span class="n">config</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">{</span><span class="o">==</span> <span class="s2">&quot;route&quot;</span><span class="p">:</span> <span class="n">route</span><span class="p">}:</span>
        <span class="n">process_route</span><span class="p">(</span><span class="n">route</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">{</span><span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_PORT</span><span class="p">:</span> <span class="n">sub_config</span><span class="p">,</span> <span class="o">**</span><span class="n">rest</span><span class="p">}:</span>
        <span class="n">process_config</span><span class="p">(</span><span class="n">sub_config</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</pre></div>
</div>
<p>However, the extra characters were syntactically noisy and unlike its use in
value constraints (where it distinguishes them from non-pattern expressions),
the prefix doesn’t provide any additional information here that isn’t already
conveyed by the expression’s position as a key within a mapping pattern.</p>
<p>Accordingly, the proposal was simplified to omit the marker prefix from mapping
pattern keys.</p>
<p>This omission also aligns with the fact that containers may incorporate both
identity and equality checks into their lookup process - they don’t purely
rely on equality checks, as would be incorrectly implied by the use of the
equality constraint prefix.</p>
</section>
<section id="allowing-the-key-value-separator-to-be-omitted-for-mapping-value-constraints">
<h3><a class="toc-backref" href="#allowing-the-key-value-separator-to-be-omitted-for-mapping-value-constraints" role="doc-backlink">Allowing the key/value separator to be omitted for mapping value constraints</a></h3>
<p>Instance attribute patterns allow the <code class="docutils literal notranslate"><span class="pre">:</span></code> separator to be omitted when
writing attribute value constraints like <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">object{.attr</span> <span class="pre">==</span> <span class="pre">expr}</span></code>.</p>
<p>Offering a similar shorthand for mapping value constraints was considered, but
permitting it allows thoroughly baffling constructs like <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{0</span> <span class="pre">==</span> <span class="pre">0}:</span></code>
where the compiler knows this is the key <code class="docutils literal notranslate"><span class="pre">0</span></code> with the value constraint
<code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">0</span></code>, but a human reader sees the tautological comparison operation
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">==</span> <span class="pre">0</span></code>. With the key/value separator included, the intent is more obvious to
a human reader as well: <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{0:</span> <span class="pre">==</span> <span class="pre">0}:</span></code></p>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A draft reference implementation for this PEP <a class="footnote-reference brackets" href="#id13" id="id9">[3]</a> has been derived from Brandt
Bucher’s reference implementation for <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> <a class="footnote-reference brackets" href="#id14" id="id10">[4]</a>.</p>
<p>Relative to the text of this PEP, the draft reference implementation has not
yet complemented the special casing of several builtin and standard library
types in <code class="docutils literal notranslate"><span class="pre">MATCH_CLASS</span></code> with the more general check for <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>
being set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Class defined patterns also currently still accept
classes that don’t define <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>.</p>
<p>All other modified patterns have been updated to follow this PEP rather than
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.</p>
<p>Unparsing for match patterns has not yet been migrated to the updated v3 AST.</p>
<p>The AST validator for match patterns has not yet been implemented.</p>
<p>The AST validator in general has not yet been reviewed to ensure that it is
checking that only expression nodes are being passed in where expression nodes
are expected.</p>
<p>The examples in this PEP have not yet been converted to test cases, so could
plausibly contain typos and other errors.</p>
<p>Several of the old <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> tests are still to be converted to new SyntaxError
tests.</p>
<p>The documentation has not yet been updated.</p>
</section>
<section id="acknowledgments">
<h2><a class="toc-backref" href="#acknowledgments" role="doc-backlink">Acknowledgments</a></h2>
<p>The <a class="pep reference internal" href="../pep-0622/" title="PEP 622 – Structural Pattern Matching">PEP 622</a> and <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>/<a class="pep reference internal" href="../pep-0635/" title="PEP 635 – Structural Pattern Matching: Motivation and Rationale">PEP 635</a>/<a class="pep reference internal" href="../pep-0636/" title="PEP 636 – Structural Pattern Matching: Tutorial">PEP 636</a> authors, as the proposal in
this PEP is merely
an attempt to improve the readability of an already well-constructed idea by
proposing that starting with a more explicit syntax and potentially introducing
syntactic shortcuts for particularly common operations later is a better option
than attempting to <em>only</em> define the shortcut version. For areas of the
specification where the two PEPs are the same (or at least very similar), the
text describing the intended behaviour in this PEP is often derived directly
from the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> text.</p>
<p>Steven D’Aprano, who made a compelling case that the key goals of this PEP could
be achieved by using existing comparison tokens to tell the ability to override
the compiler when our guesses as to “what most users will want most of the time”
are inevitably incorrect for at least some users some of the time, and retaining
some of <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s syntactic sugar (with a slightly different semantic definition)
to obtain the same level of brevity as <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> in most situations. (Paul
Sokolosvsky also independently suggested using <code class="docutils literal notranslate"><span class="pre">==</span></code> instead of <code class="docutils literal notranslate"><span class="pre">?</span></code> as a
more easily understood prefix for equality constraints).</p>
<p>Thomas Wouters, whose publication of <a class="pep reference internal" href="../pep-0640/" title="PEP 640 – Unused variable syntax">PEP 640</a> and public review of the structured
pattern matching proposals persuaded the author of this PEP to continue
advocating for a wildcard pattern syntax that a future PEP could plausibly turn
into a hard keyword that always skips binding a reference in any location a
simple name is expected, rather than continuing indefinitely as the match
pattern specific soft keyword that is proposed here.</p>
<p>Joao Bueno and Jim Jewett for nudging the PEP author to take a closer look at
the proposed syntax for subelement capturing within class patterns and mapping
patterns (particularly the problems with “capturing to the right”). This
review is what prompted the significant changes between v2 and v3 of the
proposal.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<dt class="label" id="id11">[<a href="#id2">1</a>]</dt>
<dd>Post explaining the syntactic novelties in PEP 622
<a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/2VRPDW4EE243QT3QNNCO7XFZYZGIY6N3/">https://mail.python.org/archives/list/python-dev&#64;python.org/message/2VRPDW4EE243QT3QNNCO7XFZYZGIY6N3/</a>&gt;</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<dt class="label" id="id12">[<a href="#id3">2</a>]</dt>
<dd>Declined pull request proposing to list this as a Rejected Idea in PEP 622
<a class="reference external" href="https://github.com/python/peps/pull/1564">https://github.com/python/peps/pull/1564</a></aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<dt class="label" id="id13">[<a href="#id9">3</a>]</dt>
<dd>In-progress reference implementation for this PEP
<a class="reference external" href="https://github.com/ncoghlan/cpython/tree/pep-642-constraint-patterns">https://github.com/ncoghlan/cpython/tree/pep-642-constraint-patterns</a></aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<dt class="label" id="id14">[<a href="#id10">4</a>]</dt>
<dd>PEP 634 reference implementation
<a class="reference external" href="https://github.com/python/cpython/pull/22917">https://github.com/python/cpython/pull/22917</a></aside>
<aside class="footnote brackets" id="id15" role="doc-footnote">
<dt class="label" id="id15">[<a href="#id5">5</a>]</dt>
<dd>Steven D’Aprano’s cogent criticism of the first published iteration of this PEP
<a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/BTHFWG6MWLHALOD6CHTUFPHAR65YN6BP/">https://mail.python.org/archives/list/python-dev&#64;python.org/message/BTHFWG6MWLHALOD6CHTUFPHAR65YN6BP/</a></aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<dt class="label" id="id16">[<a href="#id6">6</a>]</dt>
<dd>Thomas Wouter’s initial review of the structured pattern matching proposals
<a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/thread/4SBR3J5IQUYE752KR7C6432HNBSYKC5X/">https://mail.python.org/archives/list/python-dev&#64;python.org/thread/4SBR3J5IQUYE752KR7C6432HNBSYKC5X/</a></aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<dt class="label" id="id17">[<a href="#id7">7</a>]</dt>
<dd>Stack Overflow answer regarding the use cases for <code class="docutils literal notranslate"><span class="pre">_</span></code> as an identifier
<a class="reference external" href="https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python/5893946#5893946">https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python/5893946#5893946</a></aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<dt class="label" id="id18">[<a href="#id1">8</a>]</dt>
<dd>Pre-publication draft of “Precise Semantics for Pattern Matching”
<a class="reference external" href="https://github.com/markshannon/pattern-matching/blob/master/precise_semantics.rst">https://github.com/markshannon/pattern-matching/blob/master/precise_semantics.rst</a></aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<dt class="label" id="id19">[<a href="#id4">9</a>]</dt>
<dd>Kohn et al., Dynamic Pattern Matching with Python
<a class="reference external" href="https://gvanrossum.github.io/docs/PyPatternMatching.pdf">https://gvanrossum.github.io/docs/PyPatternMatching.pdf</a></aside>
</aside>
</section>
<section id="appendix-a-full-grammar">
<span id="appendix-a"></span><h2><a class="toc-backref" href="#appendix-a-full-grammar" role="doc-backlink">Appendix A – Full Grammar</a></h2>
<p>Here is the full modified grammar for <code class="docutils literal notranslate"><span class="pre">match_stmt</span></code>, replacing Appendix A
in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.</p>
<p>Notation used beyond standard EBNF is as per <a class="pep reference internal" href="../pep-0534/" title="PEP 534 – Improved Errors for Missing Standard Library Modules">PEP 534</a>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'KWD'</span></code> denotes a hard keyword</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;KWD&quot;</span></code> denotes a soft keyword</li>
<li><code class="docutils literal notranslate"><span class="pre">SEP.RULE+</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">RULE</span> <span class="pre">(SEP</span> <span class="pre">RULE)*</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">!RULE</span></code> is a negative lookahead assertion</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>match_stmt: &quot;match&quot; subject_expr &#39;:&#39; NEWLINE INDENT case_block+ DEDENT
subject_expr:
    | star_named_expression &#39;,&#39; [star_named_expressions]
    | named_expression
case_block: &quot;case&quot; (guarded_pattern | open_pattern) &#39;:&#39; block

guarded_pattern: closed_pattern &#39;if&#39; named_expression
open_pattern: # Pattern may use multiple tokens with no closing delimiter
    | as_pattern
    | or_pattern

as_pattern: [closed_pattern] pattern_as_clause
as_pattern_with_inferred_wildcard: pattern_as_clause
pattern_as_clause: &#39;as&#39; pattern_capture_target
pattern_capture_target: !&quot;__&quot; NAME !(&#39;.&#39; | &#39;(&#39; | &#39;=&#39;)

or_pattern: &#39;|&#39;.simple_pattern+

simple_pattern: # Subnode where &quot;as&quot; and &quot;or&quot; patterns must be parenthesised
    | closed_pattern
    | value_constraint

value_constraint:
    | eq_constraint
    | id_constraint

eq_constraint: &#39;==&#39; closed_expr
id_constraint: &#39;is&#39; closed_expr

closed_expr: # Require a single token or a closing delimiter in expression
    | primary
    | closed_factor

closed_factor: # &quot;factor&quot; is the main grammar node for these unary ops
    | &#39;+&#39; primary
    | &#39;-&#39; primary
    | &#39;~&#39; primary

closed_pattern: # Require a single token or a closing delimiter in pattern
    | wildcard_pattern
    | group_pattern
    | structural_constraint

wildcard_pattern: &quot;__&quot;

group_pattern: &#39;(&#39; open_pattern &#39;)&#39;

structural_constraint:
    | sequence_constraint
    | mapping_constraint
    | attrs_constraint
    | class_constraint

sequence_constraint: &#39;[&#39; [sequence_constraint_elements] &#39;]&#39;
sequence_constraint_elements: &#39;,&#39;.sequence_constraint_element+ &#39;,&#39;?
sequence_constraint_element:
    | star_pattern
    | simple_pattern
    | as_pattern_with_inferred_wildcard
star_pattern: &#39;*&#39; (pattern_as_clause | wildcard_pattern)

mapping_constraint: &#39;{&#39; [mapping_constraint_elements] &#39;}&#39;
mapping_constraint_elements: &#39;,&#39;.key_value_constraint+ &#39;,&#39;?
key_value_constraint:
    | closed_expr pattern_as_clause
    | closed_expr &#39;:&#39; simple_pattern
    | double_star_capture
double_star_capture: &#39;**&#39; pattern_as_clause

attrs_constraint:
    | name_or_attr &#39;{&#39; [attrs_constraint_elements] &#39;}&#39;
name_or_attr: attr | NAME
attr: name_or_attr &#39;.&#39; NAME
attrs_constraint_elements: &#39;,&#39;.attr_value_constraint+ &#39;,&#39;?
attr_value_constraint:
    | &#39;.&#39; NAME pattern_as_clause
    | &#39;.&#39; NAME value_constraint
    | &#39;.&#39; NAME &#39;:&#39; simple_pattern
    | &#39;.&#39; NAME

class_constraint:
    | name_or_attr &#39;(&#39; &#39;)&#39;
    | name_or_attr &#39;(&#39; positional_patterns &#39;,&#39;? &#39;)&#39;
    | name_or_attr &#39;(&#39; class_constraint_attrs &#39;)&#39;
    | name_or_attr &#39;(&#39; positional_patterns &#39;,&#39; class_constraint_attrs] &#39;)&#39;
positional_patterns: &#39;,&#39;.positional_pattern+
positional_pattern:
    | simple_pattern
    | as_pattern_with_inferred_wildcard
class_constraint_attrs:
    | &#39;**&#39; &#39;{&#39; [attrs_constraint_elements] &#39;}&#39;
</pre></div>
</div>
</section>
<section id="appendix-b-summary-of-abstract-syntax-tree-changes">
<span id="appendix-b"></span><h2><a class="toc-backref" href="#appendix-b-summary-of-abstract-syntax-tree-changes" role="doc-backlink">Appendix B: Summary of Abstract Syntax Tree changes</a></h2>
<p>The following new nodes are added to the AST by this PEP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>stmt = ...
      | ...
      | Match(expr subject, match_case* cases)
      | ...
      ...

match_case = (pattern pattern, expr? guard, stmt* body)

pattern = MatchAlways
     | MatchValue(matchop op, expr value)
     | MatchSequence(pattern* patterns)
     | MatchMapping(expr* keys, pattern* patterns)
     | MatchAttrs(expr cls, identifier* attrs, pattern* patterns)
     | MatchClass(expr cls, pattern* patterns, identifier* extra_attrs, pattern* extra_patterns)

     | MatchRestOfSequence(identifier? target)
     -- A NULL entry in the MatchMapping key list handles capturing extra mapping keys

     | MatchAs(pattern? pattern, identifier target)
     | MatchOr(pattern* patterns)

      attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

matchop = EqCheck | IdCheck
</pre></div>
</div>
</section>
<section id="appendix-c-summary-of-changes-relative-to-pep-634">
<span id="appendix-c"></span><h2><a class="toc-backref" href="#appendix-c-summary-of-changes-relative-to-pep-634" role="doc-backlink">Appendix C: Summary of changes relative to PEP 634</a></h2>
<p>The overall <code class="docutils literal notranslate"><span class="pre">match</span></code>/<code class="docutils literal notranslate"><span class="pre">case</span></code> statement syntax and the guard expression syntax
remain the same as they are in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>.</p>
<p>Relative to <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> this PEP makes the following key changes:</p>
<ul class="simple">
<li>a new <code class="docutils literal notranslate"><span class="pre">pattern</span></code> type is defined in the AST, rather than reusing the <code class="docutils literal notranslate"><span class="pre">expr</span></code>
type for patterns</li>
<li>the new <code class="docutils literal notranslate"><span class="pre">MatchAs</span></code> and <code class="docutils literal notranslate"><span class="pre">MatchOr</span></code> AST nodes are moved from the <code class="docutils literal notranslate"><span class="pre">expr</span></code>
type to the <code class="docutils literal notranslate"><span class="pre">pattern</span></code> type</li>
<li>the wildcard pattern changes from <code class="docutils literal notranslate"><span class="pre">_</span></code> (single underscore) to <code class="docutils literal notranslate"><span class="pre">__</span></code> (double
underscore), and gains a dedicated <code class="docutils literal notranslate"><span class="pre">MatchAlways</span></code> node in the AST</li>
<li>due to ambiguity of intent, value patterns and literal patterns are removed</li>
<li>a new expression category is introduced: “closed expressions”</li>
<li>closed expressions are either primary expressions, or a closed expression
preceded by one of the high precedence unary operators (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">~</span></code>)</li>
<li>a new pattern type is introduced: “value constraint patterns”</li>
<li>value constraints have a dedicated <code class="docutils literal notranslate"><span class="pre">MatchValue</span></code> AST node rather than
allowing a combination of <code class="docutils literal notranslate"><span class="pre">Constant</span></code> (literals), <code class="docutils literal notranslate"><span class="pre">UnaryOp</span></code>
(negative numbers), <code class="docutils literal notranslate"><span class="pre">BinOp</span></code> (complex numbers), and <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> (attribute
lookups)</li>
<li>value constraint patterns are either equality constraints or identity constraints</li>
<li>equality constraints use <code class="docutils literal notranslate"><span class="pre">==</span></code> as a prefix marker on an otherwise
arbitrary closed expression: <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">EXPR</span></code></li>
<li>identity constraints use <code class="docutils literal notranslate"><span class="pre">is</span></code> as a prefix marker on an otherwise
arbitrary closed expression: <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">EXPR</span></code></li>
<li>due to ambiguity of intent, capture patterns are removed. All capture operations
use the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword (even in sequence matching) and are represented in the
AST as either <code class="docutils literal notranslate"><span class="pre">MatchAs</span></code> or <code class="docutils literal notranslate"><span class="pre">MatchRestOfSequence</span></code> nodes.</li>
<li>to reduce verbosity in AS patterns, <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">NAME</span></code> is permitted, with the same
meaning as <code class="docutils literal notranslate"><span class="pre">__</span> <span class="pre">as</span> <span class="pre">NAME</span></code></li>
<li>sequence patterns change to <em>require</em> the use of square brackets, rather than
offering the same syntactic flexibility as assignment targets (assignment
statements allow iterable unpacking to be indicated by any use of a tuple
separated target, with or without surrounding parentheses or square brackets)</li>
<li>sequence patterns gain a dedicated <code class="docutils literal notranslate"><span class="pre">MatchSequence</span></code> AST node rather than
reusing <code class="docutils literal notranslate"><span class="pre">List</span></code></li>
<li>mapping patterns change to allow arbitrary closed expressions as keys</li>
<li>mapping patterns gain a dedicated <code class="docutils literal notranslate"><span class="pre">MatchMapping</span></code> AST node rather than
reusing <code class="docutils literal notranslate"><span class="pre">Dict</span></code></li>
<li>to reduce verbosity in mapping patterns, <code class="docutils literal notranslate"><span class="pre">KEY</span> <span class="pre">:</span> <span class="pre">__</span> <span class="pre">as</span> <span class="pre">NAME</span></code> may be shortened
to <code class="docutils literal notranslate"><span class="pre">KEY</span> <span class="pre">as</span> <span class="pre">NAME</span></code></li>
<li>class patterns no longer use individual keyword argument syntax for attribute
matching. Instead they use double-star syntax, along with a variant on mapping
pattern syntax with a dot prefix on the attribute names</li>
<li>class patterns gain a dedicated <code class="docutils literal notranslate"><span class="pre">MatchClass</span></code> AST node rather than
reusing <code class="docutils literal notranslate"><span class="pre">Call</span></code></li>
<li>to reduce verbosity, class attribute matching allows <code class="docutils literal notranslate"><span class="pre">:</span></code> to be omitted when
the pattern to be matched starts with <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">is</span></code>, or <code class="docutils literal notranslate"><span class="pre">as</span></code></li>
<li>class patterns treat any class that sets <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code> as
accepting a single positional pattern that is matched against the entire
object (avoiding the special casing required in <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>)</li>
<li>class patterns raise <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> when used with an object that does not
define <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code></li>
<li>dedicated syntax for ducktyping is added, such that <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">cls{...}:</span></code> is
roughly equivalent to <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">cls(**{...}):</span></code>, but skips the check for the
existence of <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>. This pattern also has a dedicated AST node,
<code class="docutils literal notranslate"><span class="pre">MatchAttrs</span></code></li>
</ul>
<p>Note that postponing literal patterns also makes it possible to postpone the
question of whether we need an “INUMBER” token in the tokeniser for imaginary
literals. Without it, the parser can’t distinguish complex literals from other
binary addition and subtraction operations on constants, so proposals like
<a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> have to do work in later compilation steps to check for correct usage.</p>
</section>
<section id="appendix-d-history-of-changes-to-this-proposal">
<span id="appendix-d"></span><h2><a class="toc-backref" href="#appendix-d-history-of-changes-to-this-proposal" role="doc-backlink">Appendix D: History of changes to this proposal</a></h2>
<p>The first published iteration of this proposal mostly followed <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>, but
suggested using <code class="docutils literal notranslate"><span class="pre">?EXPR</span></code> for equality constraints and <code class="docutils literal notranslate"><span class="pre">?is</span> <span class="pre">EXPR</span></code> for
identity constraints rather than <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a>’s value patterns and literal patterns.</p>
<p>The second published iteration mostly adopted a counter-proposal from Steven
D’Aprano that kept the <a class="pep reference internal" href="../pep-0634/" title="PEP 634 – Structural Pattern Matching: Specification">PEP 634</a> style inferred constraints in many situations,
but also allowed the use of <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">EXPR</span></code> for explicit equality constraints, and
<code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">EXPR</span></code> for explicit identity constraints.</p>
<p>The third published (and current) iteration dropped inferred patterns entirely,
in an attempt to resolve the concerns with the fact that the patterns
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{key:</span> <span class="pre">NAME}:</span></code> and <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">cls(attr=NAME):</span></code> would both bind <code class="docutils literal notranslate"><span class="pre">NAME</span></code>
despite it appearing to the right of another subexpression without using the
<code class="docutils literal notranslate"><span class="pre">as</span></code> keyword. The revised proposal also eliminates the possibility of writing
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">TARGET1</span> <span class="pre">as</span> <span class="pre">TARGET2:</span></code>, which would bind to both of the given names. Of
those changes, the most concerning was <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">cls(attr=TARGET_NAME):</span></code>, since it
involved the use of <code class="docutils literal notranslate"><span class="pre">=</span></code> with the binding target on the right, the exact
opposite of what happens in assignment statements, function calls, and
function signature declarations.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0642.rst">https://github.com/python/peps/blob/main/peps/pep-0642.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0642.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#the-match-statement">The Match Statement</a><ul>
<li><a class="reference internal" href="#match-semantics">Match Semantics</a></li>
<li><a class="reference internal" href="#guards">Guards</a></li>
<li><a class="reference internal" href="#irrefutable-case-blocks">Irrefutable case blocks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#patterns">Patterns</a><ul>
<li><a class="reference internal" href="#as-patterns">AS Patterns</a></li>
<li><a class="reference internal" href="#or-patterns">OR Patterns</a></li>
<li><a class="reference internal" href="#value-constraints">Value constraints</a></li>
<li><a class="reference internal" href="#wildcard-pattern">Wildcard Pattern</a></li>
<li><a class="reference internal" href="#group-patterns">Group Patterns</a></li>
<li><a class="reference internal" href="#structural-constraints">Structural constraints</a></li>
<li><a class="reference internal" href="#sequence-constraints">Sequence constraints</a></li>
<li><a class="reference internal" href="#mapping-constraints">Mapping constraints</a></li>
<li><a class="reference internal" href="#instance-attribute-constraints">Instance attribute constraints</a></li>
<li><a class="reference internal" href="#class-defined-constraints">Class defined constraints</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion">Design Discussion</a><ul>
<li><a class="reference internal" href="#requiring-explicit-qualification-of-simple-names-in-match-patterns">Requiring explicit qualification of simple names in match patterns</a></li>
<li><a class="reference internal" href="#resisting-the-temptation-to-guess">Resisting the temptation to guess</a></li>
<li><a class="reference internal" href="#interaction-with-caching-of-attribute-lookups-in-local-variables">Interaction with caching of attribute lookups in local variables</a></li>
<li><a class="reference internal" href="#using-existing-comparison-operators-as-the-value-constraint-prefix">Using existing comparison operators as the value constraint prefix</a></li>
<li><a class="reference internal" href="#using-as-the-wildcard-pattern-marker">Using <code class="docutils literal notranslate"><span class="pre">__</span></code> as the wildcard pattern marker</a></li>
<li><a class="reference internal" href="#representing-patterns-explicitly-in-the-abstract-syntax-tree">Representing patterns explicitly in the Abstract Syntax Tree</a></li>
<li><a class="reference internal" href="#changes-to-sequence-patterns">Changes to sequence patterns</a></li>
<li><a class="reference internal" href="#changes-to-mapping-patterns">Changes to mapping patterns</a></li>
<li><a class="reference internal" href="#changes-to-class-patterns">Changes to class patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-ideas">Deferred Ideas</a><ul>
<li><a class="reference internal" href="#inferred-value-constraints">Inferred value constraints</a></li>
<li><a class="reference internal" href="#making-some-required-parentheses-optional">Making some required parentheses optional</a></li>
<li><a class="reference internal" href="#accepting-complex-literals-as-closed-expressions">Accepting complex literals as closed expressions</a></li>
<li><a class="reference internal" href="#allowing-negated-constraints-in-match-patterns">Allowing negated constraints in match patterns</a></li>
<li><a class="reference internal" href="#allowing-membership-checks-in-match-patterns">Allowing membership checks in match patterns</a></li>
<li><a class="reference internal" href="#inferring-a-default-type-for-instance-attribute-constraints">Inferring a default type for instance attribute constraints</a></li>
<li><a class="reference internal" href="#avoiding-special-cases-in-sequence-patterns">Avoiding special cases in sequence patterns</a></li>
<li><a class="reference internal" href="#expression-syntax-to-retrieve-multiple-attributes-from-an-instance">Expression syntax to retrieve multiple attributes from an instance</a></li>
<li><a class="reference internal" href="#id8">Expression syntax to retrieve multiple attributes from an instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#restricting-permitted-expressions-in-value-constraints-and-mapping-pattern-keys">Restricting permitted expressions in value constraints and mapping pattern keys</a></li>
<li><a class="reference internal" href="#requiring-the-use-of-constraint-prefix-markers-for-mapping-pattern-keys">Requiring the use of constraint prefix markers for mapping pattern keys</a></li>
<li><a class="reference internal" href="#allowing-the-key-value-separator-to-be-omitted-for-mapping-value-constraints">Allowing the key/value separator to be omitted for mapping value constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#appendix-a-full-grammar">Appendix A – Full Grammar</a></li>
<li><a class="reference internal" href="#appendix-b-summary-of-abstract-syntax-tree-changes">Appendix B: Summary of Abstract Syntax Tree changes</a></li>
<li><a class="reference internal" href="#appendix-c-summary-of-changes-relative-to-pep-634">Appendix C: Summary of changes relative to PEP 634</a></li>
<li><a class="reference internal" href="#appendix-d-history-of-changes-to-this-proposal">Appendix D: History of changes to this proposal</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0642.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>