
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 3135 – New Super | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-3135/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 3135 – New Super | peps.python.org'>
    <meta property="og:description" content="This PEP proposes syntactic sugar for use of the super type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-3135/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes syntactic sugar for use of the super type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 3135</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 3135 – New Super</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Calvin Spealman &lt;ironfroggy&#32;&#97;t&#32;gmail.com&gt;,
Tim Delaney &lt;timothy.c.delaney&#32;&#97;t&#32;gmail.com&gt;,
Lie Ryan &lt;lie.1296&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">28-Apr-2007</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.0</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072807.html" title="Python-Dev message">28-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072835.html" title="Python-Dev message">29-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-April/072858.html" title="Python-Dev message">29-Apr-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-May/073127.html" title="Python-Dev message">14-May-2007</a>,
<a class="reference external" href="https://mail.python.org/pipermail/python-bugs-list/2009-March/072665.html" title="Python-Bugs-List message">12-Mar-2009</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#numbering-note">Numbering Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#closed-issues">Closed Issues</a><ul>
<li><a class="reference internal" href="#determining-the-class-object-to-use">Determining the class object to use</a></li>
<li><a class="reference internal" href="#should-super-actually-become-a-keyword">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></li>
<li><a class="reference internal" href="#super-used-with-call-attributes">super used with __call__ attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-proposals">Alternative Proposals</a><ul>
<li><a class="reference internal" href="#no-changes">No Changes</a></li>
<li><a class="reference internal" href="#dynamic-attribute-on-super-type">Dynamic attribute on super type</a></li>
<li><a class="reference internal" href="#self-super-foo-args">self.__super__.foo(*args)</a></li>
<li><a class="reference internal" href="#super-self-args-or-super-self-args">super(self, *args) or __super__(self, *args)</a></li>
<li><a class="reference internal" href="#super-foo-self-args">super.foo(self, *args)</a></li>
<li><a class="reference internal" href="#super-p-kw">super(*p, **kw)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#history">History</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="numbering-note">
<h2><a class="toc-backref" href="#numbering-note" role="doc-backlink">Numbering Note</a></h2>
<p>This PEP started its life as <a class="pep reference internal" href="../pep-0367/" title="PEP 367 – New Super">PEP 367</a>.  Since it is now targeted
for Python 3000, it has been moved into the 3xxx space.</p>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes syntactic sugar for use of the <code class="docutils literal notranslate"><span class="pre">super</span></code> type to automatically
construct instances of the super type binding to the class that a method was
defined in, and the instance (or class object for classmethods) that the method
is currently acting upon.</p>
<p>The premise of the new super usage suggested is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>to replace the old:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The current usage of super requires an explicit passing of both the class and
instance it must operate from, requiring a breaking of the DRY (Don’t Repeat
Yourself) rule. This hinders any change in class name, and is often considered
a wart by many.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Within the specification section, some special terminology will be used to
distinguish similar and closely related concepts. “super class” will refer to
the actual builtin class named “super”. A “super instance” is simply an
instance of the super class, which is associated with another class and
possibly with an instance of that class.</p>
<p>The new <code class="docutils literal notranslate"><span class="pre">super</span></code> semantics are only available in Python 3.0.</p>
<p>Replacing the old usage of super, calls to the next class in the MRO (method
resolution order) can be made without explicitly passing the class object
(although doing so will still be supported). Every function
will have a cell named <code class="docutils literal notranslate"><span class="pre">__class__</span></code> that contains the class object that the
function is defined in.</p>
<p>The new syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">()</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">(</span><span class="vm">__class__</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">firstarg</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">__class__</span></code> is the class that the method was defined in, and
<code class="docutils literal notranslate"><span class="pre">&lt;firstarg&gt;</span></code> is the first parameter of the method (normally <code class="docutils literal notranslate"><span class="pre">self</span></code>
for instance methods, and <code class="docutils literal notranslate"><span class="pre">cls</span></code> for class methods). For functions
defined outside a class body, <code class="docutils literal notranslate"><span class="pre">__class__</span></code> is not defined, and will
result in runtime <code class="docutils literal notranslate"><span class="pre">SystemError</span></code>.</p>
<p>While <code class="docutils literal notranslate"><span class="pre">super</span></code> is not a reserved word, the parser recognizes the use
of <code class="docutils literal notranslate"><span class="pre">super</span></code> in a method definition and only passes in the
<code class="docutils literal notranslate"><span class="pre">__class__</span></code> cell when this is found.  Thus, calling a global alias
of <code class="docutils literal notranslate"><span class="pre">super</span></code> without arguments will not necessarily work.</p>
</section>
<section id="closed-issues">
<h2><a class="toc-backref" href="#closed-issues" role="doc-backlink">Closed Issues</a></h2>
<section id="determining-the-class-object-to-use">
<h3><a class="toc-backref" href="#determining-the-class-object-to-use" role="doc-backlink">Determining the class object to use</a></h3>
<p>The class object is taken from a cell named <code class="docutils literal notranslate"><span class="pre">__class__</span></code>.</p>
</section>
<section id="should-super-actually-become-a-keyword">
<h3><a class="toc-backref" href="#should-super-actually-become-a-keyword" role="doc-backlink">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></h3>
<p>No. It is not necessary for super to become a keyword.</p>
</section>
<section id="super-used-with-call-attributes">
<h3><a class="toc-backref" href="#super-used-with-call-attributes" role="doc-backlink">super used with __call__ attributes</a></h3>
<p>It was considered that it might be a problem that instantiating super instances
the classic way, because calling it would lookup the __call__ attribute and
thus try to perform an automatic super lookup to the next class in the MRO.
However, this was found to be false, because calling an object only looks up
the __call__ method directly on the object’s type. The following example shows
this in action.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;__call__&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;__getattribute__&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">a</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="fm">__call__</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;__getattribute__&#39;</span>
</pre></div>
</div>
<p>In any case, this issue goes away entirely because classic calls to
<code class="docutils literal notranslate"><span class="pre">super(&lt;class&gt;,</span> <span class="pre">&lt;instance&gt;)</span></code> are still supported with the same meaning.</p>
</section>
</section>
<section id="alternative-proposals">
<h2><a class="toc-backref" href="#alternative-proposals" role="doc-backlink">Alternative Proposals</a></h2>
<section id="no-changes">
<h3><a class="toc-backref" href="#no-changes" role="doc-backlink">No Changes</a></h3>
<p>Although its always attractive to just keep things how they are, people have
sought a change in the usage of super calling for some time, and for good
reason, all mentioned previously.</p>
<ul class="simple">
<li>Decoupling from the class name (which might not even be bound to the
right class anymore!)</li>
<li>Simpler looking, cleaner super calls would be better</li>
</ul>
</section>
<section id="dynamic-attribute-on-super-type">
<h3><a class="toc-backref" href="#dynamic-attribute-on-super-type" role="doc-backlink">Dynamic attribute on super type</a></h3>
<p>The proposal adds a dynamic attribute lookup to the super type, which will
automatically determine the proper class and instance parameters. Each super
attribute lookup identifies these parameters and performs the super lookup on
the instance, as the current super implementation does with the explicit
invocation of a super instance upon a class and instance.</p>
<p>This proposal relies on sys._getframe(), which is not appropriate for anything
except a prototype implementation.</p>
</section>
<section id="self-super-foo-args">
<h3><a class="toc-backref" href="#self-super-foo-args" role="doc-backlink">self.__super__.foo(*args)</a></h3>
<p>The __super__ attribute is mentioned in this PEP in several places, and could
be a candidate for the complete solution, actually using it explicitly instead
of any super usage directly. However, double-underscore names are usually an
internal detail, and attempted to be kept out of everyday code.</p>
</section>
<section id="super-self-args-or-super-self-args">
<h3><a class="toc-backref" href="#super-self-args-or-super-self-args" role="doc-backlink">super(self, *args) or __super__(self, *args)</a></h3>
<p>This solution only solves the problem of the type indication, does not handle
differently named super methods, and is explicit about the name of the
instance. It is less flexible without being able to enacted on other method
names, in cases where that is needed. One use case this fails is where a
base-class has a factory classmethod and a subclass has two factory
classmethods,both of which needing to properly make super calls to the one
in the base-class.</p>
</section>
<section id="super-foo-self-args">
<h3><a class="toc-backref" href="#super-foo-self-args" role="doc-backlink">super.foo(self, *args)</a></h3>
<p>This variation actually eliminates the problems with locating the proper
instance, and if any of the alternatives were pushed into the spotlight, I
would want it to be this one.</p>
</section>
<section id="super-p-kw">
<h3><a class="toc-backref" href="#super-p-kw" role="doc-backlink">super(*p, **kw)</a></h3>
<p>There has been the proposal that directly calling <code class="docutils literal notranslate"><span class="pre">super(*p,</span> <span class="pre">**kw)</span></code> would
be equivalent to calling the method on the <code class="docutils literal notranslate"><span class="pre">super</span></code> object with the same name
as the method currently being executed i.e. the following two methods would be
equivalent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="nb">super</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>There is strong sentiment for and against this, but implementation and style
concerns are obvious. Guido has suggested that this should be excluded from
this PEP on the principle of KISS (Keep It Simple Stupid).</p>
</section>
</section>
<section id="history">
<h2><a class="toc-backref" href="#history" role="doc-backlink">History</a></h2>
<dl class="simple">
<dt>29-Apr-2007</dt><dd><ul class="simple">
<li>Changed title from “Super As A Keyword” to “New Super”</li>
<li>Updated much of the language and added a terminology section
for clarification in confusing places.</li>
<li>Added reference implementation and history sections.</li>
</ul>
</dd>
<dt>06-May-2007</dt><dd><ul class="simple">
<li>Updated by Tim Delaney to reflect discussions on the python-3000
and python-dev mailing lists.</li>
</ul>
</dd>
<dt>12-Mar-2009</dt><dd><ul class="simple">
<li>Updated to reflect the current state of implementation.</li>
</ul>
</dd>
</dl>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<p>[1] Fixing super anyone?
  (<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-April/006667.html">https://mail.python.org/pipermail/python-3000/2007-April/006667.html</a>)</p>
<p>[2] PEP 3130: Access to Module/Class/Function Currently Being Defined (this)
  (<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2007-April/000542.html">https://mail.python.org/pipermail/python-ideas/2007-April/000542.html</a>)</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-3135.rst">https://github.com/python/peps/blob/main/peps/pep-3135.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-3135.rst">2025-02-01 08:55:40 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#numbering-note">Numbering Note</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#closed-issues">Closed Issues</a><ul>
<li><a class="reference internal" href="#determining-the-class-object-to-use">Determining the class object to use</a></li>
<li><a class="reference internal" href="#should-super-actually-become-a-keyword">Should <code class="docutils literal notranslate"><span class="pre">super</span></code> actually become a keyword?</a></li>
<li><a class="reference internal" href="#super-used-with-call-attributes">super used with __call__ attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-proposals">Alternative Proposals</a><ul>
<li><a class="reference internal" href="#no-changes">No Changes</a></li>
<li><a class="reference internal" href="#dynamic-attribute-on-super-type">Dynamic attribute on super type</a></li>
<li><a class="reference internal" href="#self-super-foo-args">self.__super__.foo(*args)</a></li>
<li><a class="reference internal" href="#super-self-args-or-super-self-args">super(self, *args) or __super__(self, *args)</a></li>
<li><a class="reference internal" href="#super-foo-self-args">super.foo(self, *args)</a></li>
<li><a class="reference internal" href="#super-p-kw">super(*p, **kw)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#history">History</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-3135.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>