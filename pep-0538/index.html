
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 538 – Coercing the legacy C locale to a UTF-8 based locale | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0538/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 538 – Coercing the legacy C locale to a UTF-8 based locale | peps.python.org'>
    <meta property="og:description" content="An ongoing challenge with Python 3 on *nix systems is the conflict between needing to use the configured locale encoding by default for consistency with other locale-aware components in the same process or subprocesses, and the fact that the standard C ...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0538/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="An ongoing challenge with Python 3 on *nix systems is the conflict between needing to use the configured locale encoding by default for consistency with other locale-aware components in the same process or subprocesses, and the fact that the standard C ...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 538</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 538 – Coercing the legacy C locale to a UTF-8 based locale" data-pagefind-weight="10" class="visually-hidden">PEP 538 – Coercing the legacy C locale to a UTF-8 based locale</span>
            <section id="pep-content">
<h1 class="page-title">PEP 538 – Coercing the legacy C locale to a UTF-8 based locale</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">BDFL-Delegate<span class="colon">:</span></dt>
<dd class="field-even">INADA Naoki</dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">28-Dec-2016</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.7</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd">03-Jan-2017,
07-Jan-2017,
05-Mar-2017,
09-May-2017</dd>
<dt class="field-even">Resolution<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-May/148035.html">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#design-principles">Design Principles</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#legacy-c-locale-coercion-in-the-standalone-python-interpreter-binary">Legacy C locale coercion in the standalone Python interpreter binary</a></li>
<li><a class="reference internal" href="#legacy-c-locale-warning-during-runtime-initialization">Legacy C locale warning during runtime initialization</a></li>
<li><a class="reference internal" href="#new-build-time-configuration-options">New build-time configuration options</a></li>
<li><a class="reference internal" href="#changes-to-the-default-error-handling-on-the-standard-streams">Changes to the default error handling on the standard streams</a></li>
<li><a class="reference internal" href="#changes-to-locale-settings-on-android">Changes to locale settings on Android</a></li>
</ul>
</li>
<li><a class="reference internal" href="#platform-support-changes">Platform Support Changes</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#improving-the-handling-of-the-c-locale">Improving the handling of the C locale</a></li>
<li><a class="reference internal" href="#defaulting-to-surrogateescape-error-handling-on-the-standard-io-streams">Defaulting to “surrogateescape” error handling on the standard IO streams</a></li>
<li><a class="reference internal" href="#avoiding-setting-pythonioencoding-during-utf-8-locale-coercion">Avoiding setting PYTHONIOENCODING during UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#dropping-official-support-for-ascii-based-text-handling-in-the-legacy-c-locale">Dropping official support for ASCII based text handling in the legacy C locale</a></li>
<li><a class="reference internal" href="#providing-implicit-locale-coercion-only-when-running-standalone">Providing implicit locale coercion only when running standalone</a></li>
<li><a class="reference internal" href="#allowing-restoration-of-the-legacy-behaviour">Allowing restoration of the legacy behaviour</a></li>
<li><a class="reference internal" href="#querying-lc-ctype-for-c-locale-detection">Querying LC_CTYPE for C locale detection</a></li>
<li><a class="reference internal" href="#explicitly-setting-lc-ctype-for-utf-8-locale-coercion">Explicitly setting LC_CTYPE for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#avoiding-setting-lang-for-utf-8-locale-coercion">Avoiding setting LANG for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#avoiding-setting-lc-all-for-utf-8-locale-coercion">Avoiding setting LC_ALL for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#skipping-locale-coercion-if-lc-all-is-set-in-the-current-environment">Skipping locale coercion if LC_ALL is set in the current environment</a></li>
<li><a class="reference internal" href="#considering-locale-coercion-independently-of-utf-8-mode">Considering locale coercion independently of “UTF-8 mode”</a></li>
<li><a class="reference internal" href="#enabling-c-locale-coercion-and-warnings-on-mac-os-x-ios-and-android">Enabling C locale coercion and warnings on Mac OS X, iOS and Android</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#backporting-to-earlier-python-3-releases">Backporting to earlier Python 3 releases</a><ul>
<li><a class="reference internal" href="#backporting-to-python-3-6-x">Backporting to Python 3.6.x</a></li>
<li><a class="reference internal" href="#backporting-to-other-3-x-releases">Backporting to other 3.x releases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>An ongoing challenge with Python 3 on *nix systems is the conflict between
needing to use the configured locale encoding by default for consistency with
other locale-aware components in the same process or subprocesses,
and the fact that the standard C locale (as defined in POSIX:2001) typically
implies a default text encoding of ASCII, which is entirely inadequate for the
development of networked services and client applications in a multilingual
world.</p>
<p><a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> proposes a change to CPython’s handling of the legacy C locale such
that CPython will assume the use of UTF-8 in such environments, rather than
persisting with the demonstrably problematic assumption of ASCII as an
appropriate encoding for communicating with operating system interfaces.
This is a good approach for cases where network encoding interoperability
is a more important concern than local encoding interoperability.</p>
<p>However, it comes at the cost of making CPython’s encoding assumptions diverge
from those of other locale-aware components in the same process, as well as
those of components running in subprocesses that share the same environment.</p>
<p>This can cause interoperability problems with some extension modules (such as
GNU readline’s command line history editing), as well as with components
running in subprocesses (such as older Python runtimes).</p>
<p>It also requires non-trivial changes to the internals of how CPython itself
works, rather than relying primarily on existing configuration settings that
are supported by Python versions prior to Python 3.7.</p>
<p>Accordingly, this PEP proposes that independently of the UTF-8 mode proposed
in <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>, the way the CPython implementation handles the default C locale be
changed to be roughly equivalent to the following existing configuration
settings (supported since Python 3.1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LC_CTYPE</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="p">:</span><span class="n">surrogateescape</span>
</pre></div>
</div>
<p>The exact target locale for coercion will be chosen from a predefined list at
runtime based on the actually available locales.</p>
<p>The reinterpreted locale settings will be written back to the environment so
they’re visible to other components in the same process and in subprocesses,
but the changed <code class="docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code> default will be made implicit in order to
avoid causing compatibility problems with Python 2 subprocesses that don’t
provide the <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> error handler.</p>
<p>The new legacy locale coercion behavior can be disabled either by setting
<code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code> (which may still lead to a Unicode compatibility warning) or by
setting the new <code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE</span></code> environment variable to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>With this change, any *nix platform that does <em>not</em> offer at least one of the
<code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code>, <code class="docutils literal notranslate"><span class="pre">C.utf8</span></code> or <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> locales as part of its standard
configuration would only be considered a fully supported platform for CPython
3.7+ deployments when a suitable locale other than the default <code class="docutils literal notranslate"><span class="pre">C</span></code> locale is
configured explicitly (e.g. <code class="docutils literal notranslate"><span class="pre">en_AU.UTF-8</span></code>, <code class="docutils literal notranslate"><span class="pre">zh_CN.gb18030</span></code>). If <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> is
accepted in addition to this PEP, then pure Python modules would also be
supported when using the proposed <code class="docutils literal notranslate"><span class="pre">PYTHONUTF8</span></code> mode, but expectations for
full Unicode compatibility in extension modules would continue to be limited
to the platforms covered by this PEP.</p>
<p>As it only reflects a change in default settings rather than a fundamentally
new capability, redistributors (such as Linux distributions) with a narrower
target audience than the upstream CPython development team may also choose to
opt in to this locale coercion behaviour for the Python 3.6.x series by
applying the necessary changes as a downstream patch.</p>
</section>
<section id="implementation-notes">
<h2><a class="toc-backref" href="#implementation-notes" role="doc-backlink">Implementation Notes</a></h2>
<p>Attempting to implement the PEP as originally accepted showed that the
proposal to emit locale coercion and compatibility warnings by default
simply wasn’t practical (there were too many cases where previously working
code failed <em>because of the warnings</em>, rather than because of latent locale
handling defects in the affected code).</p>
<p>As a result, the <code class="docutils literal notranslate"><span class="pre">PY_WARN_ON_C_LOCALE</span></code> config flag was removed, and replaced
with a runtime <code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE=warn</span></code> environment variable setting
that allows developers and system integrators to opt-in to receiving locale
coercion and compatibility warnings, without emitting them by default.</p>
<p>The output examples in the PEP itself have also been updated to remove
the warnings and make them easier to read.</p>
</section>
<section id="background">
<h2><a class="toc-backref" href="#background" role="doc-backlink">Background</a></h2>
<p>While the CPython interpreter is starting up, it may need to convert from
the <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> format to the <code class="docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> format, or from one of those formats
to <code class="docutils literal notranslate"><span class="pre">PyUnicodeObject</span> <span class="pre">*</span></code>, in a way that’s consistent with the locale settings
of the overall system. It handles these cases by relying on the operating
system to do the conversion and then ensuring that the text encoding name
reported by <code class="docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code> matches the encoding used during
this early bootstrapping process.</p>
<p>On Windows, the limitations of the <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> format used by default in these
conversions proved sufficiently problematic that <a class="pep reference internal" href="../pep-0528/" title="PEP 528 – Change Windows console encoding to UTF-8">PEP 528</a> and <a class="pep reference internal" href="../pep-0529/" title="PEP 529 – Change Windows filesystem encoding to UTF-8">PEP 529</a> were
implemented to bypass the operating system supplied interfaces for binary data
handling and force the use of UTF-8 instead.</p>
<p>On Mac OS X, iOS, and Android, many components, including CPython, already
assume the use of UTF-8 as the system encoding, regardless of the locale
setting. However, this isn’t the case for all components, and the discrepancy
can cause problems in some situations (for example, when using the GNU readline
module [<a class="reference internal" href="#id38">16</a>]).</p>
<p>On non-Apple and non-Android *nix systems, these operations are handled using
the C locale system in glibc, which has the following characteristics <a class="footnote-reference brackets" href="#id26" id="id1">[4]</a>:</p>
<ul class="simple">
<li>by default, all processes start in the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale, which uses <code class="docutils literal notranslate"><span class="pre">ASCII</span></code>
for these conversions. This is almost never what anyone doing multilingual
text processing actually wants (including CPython and C/C++ GUI frameworks).</li>
<li>calling <code class="docutils literal notranslate"><span class="pre">setlocale(LC_ALL,</span> <span class="pre">&quot;&quot;)</span></code> reconfigures the active locale based on
the locale categories configured in the current process environment</li>
<li>if the locale requested by the current environment is unknown, or no specific
locale is configured, then the default <code class="docutils literal notranslate"><span class="pre">C</span></code> locale will remain active</li>
</ul>
<p>The specific locale category that covers the APIs that CPython depends on is
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>, which applies to “classification and conversion of characters,
and to multibyte and wide characters” <a class="footnote-reference brackets" href="#id27" id="id2">[5]</a>. Accordingly, CPython includes the
following key calls to <code class="docutils literal notranslate"><span class="pre">setlocale</span></code>:</p>
<ul class="simple">
<li>in the main <code class="docutils literal notranslate"><span class="pre">python</span></code> binary, CPython calls <code class="docutils literal notranslate"><span class="pre">setlocale(LC_ALL,</span> <span class="pre">&quot;&quot;)</span></code> to
configure the entire C locale subsystem according to the process environment.
It does this prior to making any calls into the shared CPython library</li>
<li>in <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code>, CPython calls <code class="docutils literal notranslate"><span class="pre">setlocale(LC_CTYPE,</span> <span class="pre">&quot;&quot;)</span></code>, such that
the configured locale settings for that category <em>always</em> match those set in
the environment. It does this unconditionally, and it <em>doesn’t</em> revert the
process state change in <code class="docutils literal notranslate"><span class="pre">Py_Finalize</span></code></li>
</ul>
<p>(This summary of the locale handling omits several technical details related
to exactly where and when the text encoding declared as part of the locale
settings is used - see <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> for further discussion, as these particular
details matter more when decoupling CPython from the declared C locale than
they do when overriding the locale with one based on UTF-8)</p>
<p>These calls are usually sufficient to provide sensible behaviour, but they can
still fail in the following cases:</p>
<ul class="simple">
<li>SSH environment forwarding means that SSH clients may sometimes forward
client locale settings to servers that don’t have that locale installed. This
leads to CPython running in the default ASCII-based C locale</li>
<li>some process environments (such as Linux containers) may not have any
explicit locale configured at all. As with unknown locales, this leads to
CPython running in the default ASCII-based C locale</li>
<li>on Android, rather than configuring the locale based on environment variables,
the empty locale <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> is treated as specifically requesting the <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>
locale</li>
</ul>
<p>The simplest way to deal with this problem for currently released versions of
CPython is to explicitly set a more sensible locale when launching the
application. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LC_CTYPE</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">python3</span> <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> locale is a full locale definition that uses <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> for the
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> category, and the same settings as the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale for all other
categories (including <code class="docutils literal notranslate"><span class="pre">LC_COLLATE</span></code>). It is offered by a number of Linux
distributions (including Debian, Ubuntu, Fedora, Alpine and Android) as an
alternative to the ASCII-based C locale. Some other platforms (such as
<code class="docutils literal notranslate"><span class="pre">HP-UX</span></code>) offer an equivalent locale definition under the name <code class="docutils literal notranslate"><span class="pre">C.utf8</span></code>.</p>
<p>Mac OS X and other *BSD systems have taken a different approach: instead of
offering a <code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> locale, they offer a partial <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> locale that only
defines the <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> category. On such systems, the preferred
environmental locale adjustment is to set <code class="docutils literal notranslate"><span class="pre">LC_CTYPE=UTF-8</span></code> rather than to set
<code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code> or <code class="docutils literal notranslate"><span class="pre">LANG</span></code>. <a class="footnote-reference brackets" href="#id39" id="id3">[17]</a></p>
<p>In the specific case of Docker containers and similar technologies, the
appropriate locale setting can be specified directly in the container image
definition.</p>
<p>Another common failure case is developers specifying <code class="docutils literal notranslate"><span class="pre">LANG=C</span></code> in order to
see otherwise translated user interface messages in English, rather than the
more narrowly scoped <code class="docutils literal notranslate"><span class="pre">LC_MESSAGES=C</span></code> or <code class="docutils literal notranslate"><span class="pre">LANGUAGE=en</span></code>.</p>
</section>
<section id="relationship-with-other-peps">
<h2><a class="toc-backref" href="#relationship-with-other-peps" role="doc-backlink">Relationship with other PEPs</a></h2>
<p>This PEP shares a common problem statement with <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> (improving Python 3’s
behaviour in the default C locale), but diverges markedly in the proposed
solution:</p>
<ul class="simple">
<li><a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> proposes to entirely decouple CPython’s default text encoding from
the C locale system in that case, allowing text handling inconsistencies to
arise between CPython and other locale-aware components running in the same
process and in subprocesses. This approach aims to make CPython behave less
like a locale-aware application, and more like locale-independent language
runtimes like those for Go, Node.js (V8), and Rust</li>
<li>this PEP proposes to override the legacy C locale with a more recently
defined locale that uses UTF-8 as its default text encoding. This means that
the text encoding override will apply not only to CPython, but also to any
locale-aware extension modules loaded into the current process, as well as to
locale-aware applications invoked in subprocesses that inherit their
environment from the parent process. This approach aims to retain CPython’s
traditional strong support for integration with other locale-aware components
while also actively helping to push forward the adoption and standardisation
of the C.UTF-8 locale as a Unicode-aware replacement for the legacy C locale
in the wider C/C++ ecosystem</li>
</ul>
<p>After reviewing both PEPs, it became clear that they didn’t actually conflict
at a technical level, and the proposal in <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> offered a superior option in
cases where no suitable locale was available, as well as offering a better
reference behaviour for platforms where the notion of a “locale encoding”
doesn’t make sense (for example, embedded systems running MicroPython rather
than the CPython reference interpreter).</p>
<p>Meanwhile, this PEP offered improved compatibility with other locale-aware
components, and an approach more amenable to being backported to Python 3.6
by downstream redistributors.</p>
<p>As a result, this PEP was amended to refer to <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> as a complementary
solution that offered improved behaviour when none of the standard UTF-8 based
locales were available, as well as extending the changes in the default
settings to APIs that aren’t currently independently configurable (such as
the default encoding and error handler for <code class="docutils literal notranslate"><span class="pre">open()</span></code>).</p>
<p>The availability of <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> also meant that the <code class="docutils literal notranslate"><span class="pre">LC_CTYPE=en_US.UTF-8</span></code> legacy
fallback was removed from the list of UTF-8 locales tried as a coercion target,
with the expectation being that CPython will instead rely solely on the
proposed PYTHONUTF8 mode in such cases.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>While Linux container technologies like Docker, Kubernetes, and OpenShift are
best known for their use in web service development, the related container
formats and execution models are also being adopted for Linux command line
application development. Technologies like Gnome Flatpak <a class="footnote-reference brackets" href="#id29" id="id4">[7]</a> and
Ubuntu Snappy <a class="footnote-reference brackets" href="#id30" id="id5">[8]</a> further aim to bring these same techniques to Linux GUI
application development.</p>
<p>When using Python 3 for application development in these contexts, it isn’t
uncommon to see text encoding related errors akin to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run --rm fedora:25 python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
Unable to decode the command from the command line:
UnicodeEncodeError: &#39;utf-8&#39; codec can&#39;t encode character &#39;\udce2&#39; in position 7: surrogates not allowed
$ docker run --rm ncoghlan/debian-python python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
Unable to decode the command from the command line:
UnicodeEncodeError: &#39;utf-8&#39; codec can&#39;t encode character &#39;\udce2&#39; in position 7: surrogates not allowed
</pre></div>
</div>
<p>Even though the same command is likely to work fine when run locally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
ℙƴ☂ℌøἤ
</pre></div>
</div>
<p>The source of the problem can be seen by instead running the <code class="docutils literal notranslate"><span class="pre">locale</span></code> command
in the three environments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=en_AU.UTF-8
LC_CTYPE=&quot;en_AU.UTF-8&quot;
LC_ALL=
$ docker run --rm fedora:25 locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=
LC_CTYPE=&quot;POSIX&quot;
LC_ALL=
$ docker run --rm ncoghlan/debian-python locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=
LANGUAGE=
LC_CTYPE=&quot;POSIX&quot;
LC_ALL=
</pre></div>
</div>
<p>In this particular example, we can see that the host system locale is set to
“en_AU.UTF-8”, so CPython uses UTF-8 as the default text encoding. By contrast,
the base Docker images for Fedora and Debian don’t have any specific locale
set, so they use the POSIX locale by default, which is an alias for the
ASCII-based default C locale.</p>
<p>The simplest way to get Python 3 (regardless of the exact version) to behave
sensibly in Fedora and Debian based containers is to run it in the <code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code>
locale that both distros provide:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -e LC_CTYPE=C.UTF-8 fedora:25 python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
ℙƴ☂ℌøἤ
$ docker run --rm -e LC_CTYPE=C.UTF-8 ncoghlan/debian-python python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
ℙƴ☂ℌøἤ

$ docker run --rm -e LC_CTYPE=C.UTF-8 fedora:25 locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=
LC_CTYPE=C.UTF-8
LC_ALL=
$ docker run --rm -e LC_CTYPE=C.UTF-8 ncoghlan/debian-python locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=
LANGUAGE=
LC_CTYPE=C.UTF-8
LC_ALL=
</pre></div>
</div>
<p>The Alpine Linux based Python images provided by Docker, Inc. already use the
C.UTF-8 locale by default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run --rm python:3 python3 -c &#39;print(&quot;ℙƴ☂ℌøἤ&quot;)&#39;
ℙƴ☂ℌøἤ
$ docker run --rm python:3 locale | grep -E &#39;LC_ALL|LC_CTYPE|LANG&#39;
LANG=C.UTF-8
LANGUAGE=
LC_CTYPE=&quot;C.UTF-8&quot;
LC_ALL=
</pre></div>
</div>
<p>Similarly, for custom container images (i.e. those adding additional content on
top of a base distro image), a more suitable locale can be set in the image
definition so everything just works by default. However, it would provide a much
nicer and more consistent user experience if CPython were able to just deal
with this problem automatically rather than relying on redistributors or end
users to handle it through system configuration changes.</p>
<p>While the glibc developers are working towards making the C.UTF-8 locale
universally available for use by glibc based applications like CPython <a class="footnote-reference brackets" href="#id28" id="id6">[6]</a>,
this unfortunately doesn’t help on platforms that ship older versions of glibc
without that feature, and also don’t provide C.UTF-8 (or an equivalent) as an
on-disk locale the way Debian and Fedora do. These platforms are considered
out of scope for this PEP - see <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> for further discussion of possible
options for improving CPython’s default behaviour in such environments.</p>
</section>
<section id="design-principles">
<h2><a class="toc-backref" href="#design-principles" role="doc-backlink">Design Principles</a></h2>
<p>The above motivation leads to the following core design principles for the
proposed solution:</p>
<ul class="simple">
<li>if a locale other than the default C locale is explicitly configured, we’ll
continue to respect it</li>
<li>as far as is feasible, any changes made will use <em>existing</em> configuration
options</li>
<li>Python’s runtime behaviour in potential coercion target locales should be
identical regardless of whether the locale was set explicitly in the
environment or implicitly as a locale coercion target</li>
<li>for Python 3.7, if we’re changing the locale setting without an explicit
config option, we’ll emit a warning on stderr that we’re doing so rather
than silently changing the process configuration. This will alert application
and system integrators to the change, even if they don’t closely follow the
PEP process or Python release announcements. However, to minimize the chance
of introducing new problems for end users, we’ll do this <em>without</em> using the
warnings system, so even running with <code class="docutils literal notranslate"><span class="pre">-Werror</span></code> won’t turn it into a runtime
exception. (Note: these warnings ended up being silenced by default. See the
Implementation Note above for more details)</li>
<li>for Python 3.7, any changed defaults will offer some form of explicit “off”
switch at build time, runtime, or both</li>
</ul>
<p>Minimizing the negative impact on systems currently correctly configured to
use GB-18030 or another partially ASCII compatible universal encoding leads to
the following design principle:</p>
<ul class="simple">
<li>if a UTF-8 based Linux container is run on a host that is explicitly
configured to use a non-UTF-8 encoding, and tries to exchange locally
encoded data with that host rather than exchanging explicitly UTF-8 encoded
data, CPython will endeavour to correctly round-trip host provided data that
is concatenated or split solely at common ASCII compatible code points, but
may otherwise emit nonsensical results.</li>
</ul>
<p>Minimizing the negative impact on systems and programs correctly configured to
use an explicit locale category like <code class="docutils literal notranslate"><span class="pre">LC_TIME</span></code>, <code class="docutils literal notranslate"><span class="pre">LC_MONETARY</span></code> or
<code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> while otherwise running in the legacy C locale gives the
following design principles:</p>
<ul class="simple">
<li>don’t make any environmental changes that would alter any existing settings
for locale categories other than <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> (most notably: don’t set
<code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code> or <code class="docutils literal notranslate"><span class="pre">LANG</span></code>)</li>
</ul>
<p>Finally, maintaining compatibility with running arbitrary subprocesses in
orchestration use cases leads to the following design principle:</p>
<ul class="simple">
<li>don’t make any Python-specific environmental changes that might be
incompatible with any still supported version of CPython (including
CPython 2.7)</li>
</ul>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>To better handle the cases where CPython would otherwise end up attempting
to operate in the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale, this PEP proposes that CPython automatically
attempt to coerce the legacy <code class="docutils literal notranslate"><span class="pre">C</span></code> locale to a UTF-8 based locale for the
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> category when it is run as a standalone command line application.</p>
<p>It further proposes to emit a warning on stderr if the legacy <code class="docutils literal notranslate"><span class="pre">C</span></code> locale
is in effect for the <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> category at the point where the language
runtime itself is initialized,
and the explicit environmental flag to disable locale coercion is not set, in
order to warn system and application integrators that they’re running CPython
in an unsupported configuration.</p>
<p>In addition to these general changes, some additional Android-specific changes
are proposed to handle the differences in the behaviour of <code class="docutils literal notranslate"><span class="pre">setlocale</span></code> on that
platform.</p>
<section id="legacy-c-locale-coercion-in-the-standalone-python-interpreter-binary">
<h3><a class="toc-backref" href="#legacy-c-locale-coercion-in-the-standalone-python-interpreter-binary" role="doc-backlink">Legacy C locale coercion in the standalone Python interpreter binary</a></h3>
<p>When run as a standalone application, CPython has the opportunity to
reconfigure the C locale before any locale dependent operations are executed
in the process.</p>
<p>This means that it can change the locale settings not only for the CPython
runtime, but also for any other locale-aware components running in the current
process (e.g. as part of extension modules), as well as in subprocesses that
inherit their environment from the current process.</p>
<p>After calling <code class="docutils literal notranslate"><span class="pre">setlocale(LC_ALL,</span> <span class="pre">&quot;&quot;)</span></code> to initialize the locale settings in
the current process, the main interpreter binary will be updated to include
the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">ctype_loc</span> <span class="o">=</span> <span class="n">setlocale</span><span class="p">(</span><span class="n">LC_CTYPE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>This cryptic invocation is the API that C provides to query the current locale
setting without changing it. Given that query, it is possible to check for
exactly the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale with <code class="docutils literal notranslate"><span class="pre">strcmp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ctype_loc</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">ctype_loc</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># true only in the C locale</span>
</pre></div>
</div>
<p>This call also returns <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code> when either no particular locale is set, or the
nominal locale is set to an alias for the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale (such as <code class="docutils literal notranslate"><span class="pre">POSIX</span></code>).</p>
<p>Given this information, CPython can then attempt to coerce the locale to one
that uses UTF-8 rather than ASCII as the default encoding.</p>
<p>Three such locales will be tried:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> (available at least in Debian, Ubuntu, Alpine, and Fedora 25+, and
expected to be available by default in a future version of glibc)</li>
<li><code class="docutils literal notranslate"><span class="pre">C.utf8</span></code> (available at least in HP-UX)</li>
<li><code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> (available in at least some *BSD variants, including Mac OS X)</li>
</ul>
<p>The coercion will be implemented by setting the <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> environment
variable to the candidate locale name, such that future calls to
<code class="docutils literal notranslate"><span class="pre">setlocale()</span></code> will see it, as will other components looking for those
settings (such as GUI development frameworks and Python’s own <code class="docutils literal notranslate"><span class="pre">locale</span></code>
module).</p>
<p>To allow for better cross-platform binary portability and to adjust
automatically to future changes in locale availability, these checks will be
implemented at runtime on all platforms other than Windows, rather than
attempting to determine which locales to try at compile time.</p>
<p>When this locale coercion is activated, the following warning will be
printed on stderr, with the warning containing whichever locale was
successfully configured:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">detected</span> <span class="n">LC_CTYPE</span><span class="o">=</span><span class="n">C</span><span class="p">:</span> <span class="n">LC_CTYPE</span> <span class="n">coerced</span> <span class="n">to</span> <span class="n">C</span><span class="o">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="p">(</span><span class="nb">set</span> <span class="n">another</span>
<span class="n">locale</span> <span class="ow">or</span> <span class="n">PYTHONCOERCECLOCALE</span><span class="o">=</span><span class="mi">0</span> <span class="n">to</span> <span class="n">disable</span> <span class="n">this</span> <span class="n">locale</span> <span class="n">coercion</span> <span class="n">behaviour</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>(Note: this warning ended up being silenced by default. See the
Implementation Note above for more details)</p>
<p>As long as the current platform provides at least one of the candidate UTF-8
based environments, this locale coercion will mean that the standard
Python binary <em>and</em> locale-aware extensions should once again “just work”
in the three main failure cases we’re aware of (missing locale
settings, SSH forwarding of unknown locales via <code class="docutils literal notranslate"><span class="pre">LANG</span></code> or <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>, and
developers explicitly requesting <code class="docutils literal notranslate"><span class="pre">LANG=C</span></code>).</p>
<p>The one case where failures may still occur is when <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is specifically
being checked for no output, which can be resolved either by configuring
a locale other than the C locale, or else by using a mechanism other than
“there was no output on stderr” to check for subprocess errors (e.g. checking
process return codes).</p>
<p>If none of the candidate locales are successfully configured, or the <code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code>,
locale override is defined in the current process environment, then
initialization will continue in the C locale and the Unicode compatibility
warning described in the next section will be emitted just as it would for
any other application.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE=0</span></code> is explicitly set, initialization will continue in
the C locale and the Unicode compatibility warning described in the next
section will be automatically suppressed.</p>
<p>The interpreter will always check for the <code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE</span></code> environment
variable at startup (even when running under the <code class="docutils literal notranslate"><span class="pre">-E</span></code> or <code class="docutils literal notranslate"><span class="pre">-I</span></code> switches),
as the locale coercion check necessarily takes place before any command line
argument processing. For consistency, the runtime check to determine whether
or not to suppress the locale compatibility warning will be similarly
independent of these settings.</p>
</section>
<section id="legacy-c-locale-warning-during-runtime-initialization">
<h3><a class="toc-backref" href="#legacy-c-locale-warning-during-runtime-initialization" role="doc-backlink">Legacy C locale warning during runtime initialization</a></h3>
<p>By the time that <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code> is called, arbitrary locale-dependent
operations may have taken place in the current process. This means that
by the time it is called, it is <em>too late</em> to reliably switch to a different
locale - doing so would introduce inconsistencies in decoded text, even in the
context of the standalone Python interpreter binary.</p>
<p>Accordingly, when <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code> is called and CPython detects that the
configured locale is still the default <code class="docutils literal notranslate"><span class="pre">C</span></code> locale and
<code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE=0</span></code> is not set, the following warning will be issued:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">runtime</span> <span class="n">initialized</span> <span class="k">with</span> <span class="n">LC_CTYPE</span><span class="o">=</span><span class="n">C</span> <span class="p">(</span><span class="n">a</span> <span class="n">locale</span> <span class="k">with</span> <span class="n">default</span> <span class="n">ASCII</span>
<span class="n">encoding</span><span class="p">),</span> <span class="n">which</span> <span class="n">may</span> <span class="n">cause</span> <span class="n">Unicode</span> <span class="n">compatibility</span> <span class="n">problems</span><span class="o">.</span> <span class="n">Using</span> <span class="n">C</span><span class="o">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span>
<span class="n">C</span><span class="o">.</span><span class="n">utf8</span><span class="p">,</span> <span class="ow">or</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="p">(</span><span class="k">if</span> <span class="n">available</span><span class="p">)</span> <span class="k">as</span> <span class="n">alternative</span> <span class="n">Unicode</span><span class="o">-</span><span class="n">compatible</span>
<span class="n">locales</span> <span class="ow">is</span> <span class="n">recommended</span><span class="o">.</span>
</pre></div>
</div>
<p>(Note: this warning ended up being silenced by default. See the
Implementation Note above for more details)</p>
<p>In this case, no actual change will be made to the locale settings.</p>
<p>Instead, the warning informs both system and application integrators that
they’re running Python 3 in a configuration that we don’t expect to work
properly.</p>
<p>The second sentence providing recommendations may eventually be conditionally
compiled based on the operating system (e.g. recommending <code class="docutils literal notranslate"><span class="pre">LC_CTYPE=UTF-8</span></code>
on *BSD systems), but the initial implementation will just use the common
generic message shown above.</p>
</section>
<section id="new-build-time-configuration-options">
<h3><a class="toc-backref" href="#new-build-time-configuration-options" role="doc-backlink">New build-time configuration options</a></h3>
<p>While both of the above behaviours would be enabled by default, they would
also have new associated configuration options and preprocessor definitions
for the benefit of redistributors that want to override those default settings.</p>
<p>The locale coercion behaviour would be controlled by the flag
<code class="docutils literal notranslate"><span class="pre">--with[out]-c-locale-coercion</span></code>, which would set the <code class="docutils literal notranslate"><span class="pre">PY_COERCE_C_LOCALE</span></code>
preprocessor definition.</p>
<p>The locale warning behaviour would be controlled by the flag
<code class="docutils literal notranslate"><span class="pre">--with[out]-c-locale-warning</span></code>, which would set the <code class="docutils literal notranslate"><span class="pre">PY_WARN_ON_C_LOCALE</span></code>
preprocessor definition.</p>
<p>(Note: this compile time warning option ended up being replaced by a runtime
<code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE=warn</span></code> option. See the Implementation Note above for
more details)</p>
<p>On platforms which don’t use the <code class="docutils literal notranslate"><span class="pre">autotools</span></code> based build system (i.e.
Windows) these preprocessor variables would always be undefined.</p>
</section>
<section id="changes-to-the-default-error-handling-on-the-standard-streams">
<h3><a class="toc-backref" href="#changes-to-the-default-error-handling-on-the-standard-streams" role="doc-backlink">Changes to the default error handling on the standard streams</a></h3>
<p>Since Python 3.5, CPython has defaulted to using <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> on the
standard streams (<code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>) when it detects that the
current locale is <code class="docutils literal notranslate"><span class="pre">C</span></code> and no specific error handled has been set using
either the <code class="docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code> environment variable or the
<code class="docutils literal notranslate"><span class="pre">Py_setStandardStreamEncoding</span></code> API. For other locales, the default error
handler for the standard streams is <code class="docutils literal notranslate"><span class="pre">strict</span></code>.</p>
<p>In order to preserve this behaviour without introducing any behavioural
discrepancies between locale coercion and explicitly configuring a locale, the
coercion target locales (<code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code>, <code class="docutils literal notranslate"><span class="pre">C.utf8</span></code>, and <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code>) will be added
to the list of locales that use <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> as their default error
handler for the standard streams.</p>
<p>No changes are proposed to the default error handler for <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>: that
will continue to be <code class="docutils literal notranslate"><span class="pre">backslashreplace</span></code>.</p>
</section>
<section id="changes-to-locale-settings-on-android">
<h3><a class="toc-backref" href="#changes-to-locale-settings-on-android" role="doc-backlink">Changes to locale settings on Android</a></h3>
<p>Independently of the other changes in this PEP, CPython on Android systems
will be updated to call <code class="docutils literal notranslate"><span class="pre">setlocale(LC_ALL,</span> <span class="pre">&quot;C.UTF-8&quot;)</span></code> where it currently
calls <code class="docutils literal notranslate"><span class="pre">setlocale(LC_ALL,</span> <span class="pre">&quot;&quot;)</span></code> and <code class="docutils literal notranslate"><span class="pre">setlocale(LC_CTYPE,</span> <span class="pre">&quot;C.UTF-8&quot;)</span></code> where
it currently calls <code class="docutils literal notranslate"><span class="pre">setlocale(LC_CTYPE,</span> <span class="pre">&quot;&quot;)</span></code>.</p>
<p>This Android-specific behaviour is being introduced due to the following
Android-specific details:</p>
<ul class="simple">
<li>on Android, passing <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">setlocale</span></code> is equivalent to passing <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code></li>
<li>the <code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> locale is always available</li>
</ul>
</section>
</section>
<section id="platform-support-changes">
<h2><a class="toc-backref" href="#platform-support-changes" role="doc-backlink">Platform Support Changes</a></h2>
<p>A new “Legacy C Locale” section will be added to <a class="pep reference internal" href="../pep-0011/" title="PEP 11 – CPython platform support">PEP 11</a> that states:</p>
<ul class="simple">
<li>as of CPython 3.7, *nix platforms are expected to provide at least one of
<code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> (full locale), <code class="docutils literal notranslate"><span class="pre">C.utf8</span></code> (full locale) or <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> (
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>-only locale) as an alternative to the legacy <code class="docutils literal notranslate"><span class="pre">C</span></code> locale.
Any Unicode related integration problems that occur only in the legacy <code class="docutils literal notranslate"><span class="pre">C</span></code>
locale and cannot be reproduced in an appropriately configured non-ASCII
locale will be closed as “won’t fix”.</li>
</ul>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<section id="improving-the-handling-of-the-c-locale">
<h3><a class="toc-backref" href="#improving-the-handling-of-the-c-locale" role="doc-backlink">Improving the handling of the C locale</a></h3>
<p>It has been clear for some time that the C locale’s default encoding of
<code class="docutils literal notranslate"><span class="pre">ASCII</span></code> is entirely the wrong choice for development of modern networked
services. Newer languages like Rust and Go have eschewed that default entirely,
and instead made it a deployment requirement that systems be configured to use
UTF-8 as the text encoding for operating system interfaces. Similarly, Node.js
assumes UTF-8 by default (a behaviour inherited from the V8 JavaScript engine)
and requires custom build settings to indicate it should use the system
locale settings for locale-aware operations. Both the JVM and the .NET CLR
use UTF-16-LE as their primary encoding for passing text between applications
and the application runtime (i.e. the JVM/CLR, not the host operating system).</p>
<p>The challenge for CPython has been the fact that in addition to being used for
network service development, it is also extensively used as an embedded
scripting language in larger applications, and as a desktop application
development language, where it is more important to be consistent with other
locale-aware components sharing the same process, as well as with the user’s
desktop locale settings, than it is with the emergent conventions of modern
network service development.</p>
<p>The core premise of this PEP is that for <em>all</em> of these use cases, the
assumption of ASCII implied by the default “C” locale is the wrong choice,
and furthermore that the following assumptions are valid:</p>
<ul class="simple">
<li>in desktop application use cases, the process locale will <em>already</em> be
configured appropriately, and if it isn’t, then that is an operating system
or embedding application level problem that needs to be reported to and
resolved by the operating system provider or application developer</li>
<li>in network service development use cases (especially those based on Linux
containers), the process locale may not be configured <em>at all</em>, and if it
isn’t, then the expectation is that components will impose their own default
encoding the way Rust, Go and Node.js do, rather than trusting the legacy C
default encoding of ASCII the way CPython currently does</li>
</ul>
</section>
<section id="defaulting-to-surrogateescape-error-handling-on-the-standard-io-streams">
<h3><a class="toc-backref" href="#defaulting-to-surrogateescape-error-handling-on-the-standard-io-streams" role="doc-backlink">Defaulting to “surrogateescape” error handling on the standard IO streams</a></h3>
<p>By coercing the locale away from the legacy C default and its assumption of
ASCII as the preferred text encoding, this PEP also disables the implicit use
of the “surrogateescape” error handler on the standard IO streams that was
introduced in Python 3.5 (<a class="footnote-reference brackets" href="#id37" id="id7">[15]</a>), as well as the automatic use of
<code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> when operating in <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>’s proposed UTF-8 mode.</p>
<p>Rather than introducing yet another configuration option to adjust that
behaviour, this PEP instead proposes to extend the “surrogateescape” default
for <code class="docutils literal notranslate"><span class="pre">stdin</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> error handling to also apply to the three
potential coercion target locales.</p>
<p>The aim of this behaviour is to attempt to ensure that operating system
provided text values are typically able to be transparently passed through a
Python 3 application even if it is incorrect in assuming that that text has
been encoded as UTF-8.</p>
<p>In particular, GB 18030 <a class="footnote-reference brackets" href="#id34" id="id8">[12]</a> is a Chinese national text encoding standard
that handles all Unicode code points, that is formally incompatible with both
ASCII and UTF-8, but will nevertheless often tolerate processing as surrogate
escaped data - the points where GB 18030 reuses ASCII byte values in an
incompatible way are likely to be invalid in UTF-8, and will therefore be
escaped and opaque to string processing operations that split on or search for
the relevant ASCII code points. Operations that don’t involve splitting on or
searching for particular ASCII or Unicode code point values are almost
certain to work correctly.</p>
<p>Similarly, Shift-JIS <a class="footnote-reference brackets" href="#id35" id="id9">[13]</a> and ISO-2022-JP <a class="footnote-reference brackets" href="#id36" id="id10">[14]</a> remain in widespread use in
Japan, and are incompatible with both ASCII and UTF-8, but will tolerate text
processing operations that don’t involve splitting on or searching for
particular ASCII or Unicode code point values.</p>
<p>As an example, consider two files, one encoded with UTF-8 (the default encoding
for <code class="docutils literal notranslate"><span class="pre">en_AU.UTF-8</span></code>), and one encoded with GB-18030 (the default encoding for
<code class="docutils literal notranslate"><span class="pre">zh_CN.gb18030</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -c &#39;open(&quot;utf8.txt&quot;, &quot;wb&quot;).write(&quot;ℙƴ☂ℌøἤ\n&quot;.encode(&quot;utf-8&quot;))&#39;
$ python3 -c &#39;open(&quot;gb18030.txt&quot;, &quot;wb&quot;).write(&quot;ℙƴ☂ℌøἤ\n&quot;.encode(&quot;gb18030&quot;))&#39;
</pre></div>
</div>
<p>On disk, we can see that these are two very different files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -c &#39;print(&quot;UTF-8:  &quot;, open(&quot;utf8.txt&quot;, &quot;rb&quot;).read().strip()); \
              print(&quot;GB18030:&quot;, open(&quot;gb18030.txt&quot;, &quot;rb&quot;).read().strip())&#39;
UTF-8:   b&#39;\xe2\x84\x99\xc6\xb4\xe2\x98\x82\xe2\x84\x8c\xc3\xb8\xe1\xbc\xa4\n&#39;
GB18030: b&#39;\x816\xbd6\x810\x9d0\x817\xa29\x816\xbc4\x810\x8b3\x816\x8d6\n&#39;
</pre></div>
</div>
<p>That nevertheless can both be rendered correctly to the terminal as long as
they’re decoded prior to printing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -c &#39;print(&quot;UTF-8:  &quot;, open(&quot;utf8.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;).read().strip()); \
              print(&quot;GB18030:&quot;, open(&quot;gb18030.txt&quot;, &quot;r&quot;, encoding=&quot;gb18030&quot;).read().strip())&#39;
UTF-8:   ℙƴ☂ℌøἤ
GB18030: ℙƴ☂ℌøἤ
</pre></div>
</div>
<p>By contrast, if we just pass along the raw bytes, as <code class="docutils literal notranslate"><span class="pre">cat</span></code> and similar C/C++
utilities will tend to do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=en_AU.UTF-8 cat utf8.txt gb18030.txt
ℙƴ☂ℌøἤ
�6�6�0�0�7�9�6�4�0�3�6�6
</pre></div>
</div>
<p>Even setting a specifically Chinese locale won’t help in getting the
GB-18030 encoded file rendered correctly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=zh_CN.gb18030 cat utf8.txt gb18030.txt
ℙƴ☂ℌøἤ
�6�6�0�0�7�9�6�4�0�3�6�6
</pre></div>
</div>
<p>The problem is that the <em>terminal</em> encoding setting remains UTF-8, regardless
of the nominal locale. A GB18030 terminal can be emulated using the <code class="docutils literal notranslate"><span class="pre">iconv</span></code>
utility:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat utf8.txt gb18030.txt | iconv -f GB18030 -t UTF-8
鈩櫰粹槀鈩屆羔激
ℙƴ☂ℌøἤ
</pre></div>
</div>
<p>This reverses the problem, such that the GB18030 file is rendered correctly,
but the UTF-8 file has been converted to unrelated hanzi characters, rather than
the expected rendering of “Python” as non-ASCII characters.</p>
<p>With the emulated GB18030 terminal encoding, assuming UTF-8 in Python results
in <em>both</em> files being displayed incorrectly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 -c &#39;print(&quot;UTF-8:  &quot;, open(&quot;utf8.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;).read().strip()); \
              print(&quot;GB18030:&quot;, open(&quot;gb18030.txt&quot;, &quot;r&quot;, encoding=&quot;gb18030&quot;).read().strip())&#39; \
  | iconv -f GB18030 -t UTF-8
UTF-8:   鈩櫰粹槀鈩屆羔激
GB18030: 鈩櫰粹槀鈩屆羔激
</pre></div>
</div>
<p>However, setting the locale correctly means that the emulated GB18030 terminal
now displays both files as originally intended:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=zh_CN.gb18030 \
  python3 -c &#39;print(&quot;UTF-8:  &quot;, open(&quot;utf8.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;).read().strip()); \
              print(&quot;GB18030:&quot;, open(&quot;gb18030.txt&quot;, &quot;r&quot;, encoding=&quot;gb18030&quot;).read().strip())&#39; \
  | iconv -f GB18030 -t UTF-8
UTF-8:   ℙƴ☂ℌøἤ
GB18030: ℙƴ☂ℌøἤ
</pre></div>
</div>
<p>The rationale for retaining <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> as the default IO encoding is
that it will preserve the following helpful behaviour in the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat gb18030.txt \
  | LANG=C python3 -c &quot;import sys; print(sys.stdin.read())&quot; \
  | iconv -f GB18030 -t UTF-8
ℙƴ☂ℌøἤ
</pre></div>
</div>
<p>Rather than reverting to the exception currently seen when a UTF-8 based locale is
explicitly configured:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat gb18030.txt \
  | python3 -c &quot;import sys; print(sys.stdin.read())&quot; \
  | iconv -f GB18030 -t UTF-8
Traceback (most recent call last):
File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
File &quot;/usr/lib64/python3.5/codecs.py&quot;, line 321, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0x81 in position 0: invalid start byte
</pre></div>
</div>
<p>As an added benefit, environments explicitly configured to use one of the
coercion target locales will implicitly gain the encoding transparency behaviour
currently enabled by default in the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale.</p>
</section>
<section id="avoiding-setting-pythonioencoding-during-utf-8-locale-coercion">
<h3><a class="toc-backref" href="#avoiding-setting-pythonioencoding-during-utf-8-locale-coercion" role="doc-backlink">Avoiding setting PYTHONIOENCODING during UTF-8 locale coercion</a></h3>
<p>Rather than changing the default handling of the standard streams during
interpreter initialization, earlier versions of this PEP proposed setting
<code class="docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code> to <code class="docutils literal notranslate"><span class="pre">utf-8:surrogateescape</span></code>. This turned out to create
a significant compatibility problem: since the <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> handler
only exists in Python 3.1+, running Python 2.7 processes in subprocesses could
potentially break in a confusing way with that configuration.</p>
<p>The current design means that earlier Python versions will instead retain their
default <code class="docutils literal notranslate"><span class="pre">strict</span></code> error handling on the standard streams, while Python 3.7+
will consistently use the more permissive <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> handler even
when these locales are explicitly configured (rather than being reached through
locale coercion).</p>
</section>
<section id="dropping-official-support-for-ascii-based-text-handling-in-the-legacy-c-locale">
<h3><a class="toc-backref" href="#dropping-official-support-for-ascii-based-text-handling-in-the-legacy-c-locale" role="doc-backlink">Dropping official support for ASCII based text handling in the legacy C locale</a></h3>
<p>We’ve been trying to get strict bytes/text separation to work reliably in the
legacy C locale for over a decade at this point. Not only haven’t we been able
to get it to work, neither has anyone else - the only viable alternatives
identified have been to pass the bytes along verbatim without eagerly decoding
them to text (C/C++, Python 2.x, Ruby, etc), or else to largely ignore the
nominal C/C++ locale encoding and assume the use of either UTF-8 (<a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>,
Rust, Go, Node.js, etc) or UTF-16-LE (JVM, .NET CLR).</p>
<p>While this PEP ensures that developers that genuinely need to do so can still
opt-in to running their Python code in the legacy C locale (by setting
<code class="docutils literal notranslate"><span class="pre">LC_ALL=C</span></code>, <code class="docutils literal notranslate"><span class="pre">PYTHONCOERCECLOCALE=0</span></code>, or running a custom build that sets
<code class="docutils literal notranslate"><span class="pre">--without-c-locale-coercion</span></code>), it also makes it clear that we <em>don’t</em>
expect Python 3’s Unicode handling to be completely reliable in that
configuration, and the recommended alternative is to use a more appropriate
locale setting (potentially in combination with <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>’s UTF-8 mode, if that
is available).</p>
</section>
<section id="providing-implicit-locale-coercion-only-when-running-standalone">
<h3><a class="toc-backref" href="#providing-implicit-locale-coercion-only-when-running-standalone" role="doc-backlink">Providing implicit locale coercion only when running standalone</a></h3>
<p>The major downside of the proposed design in this PEP is that it introduces a
potential discrepancy between the behaviour of the CPython runtime when it is
run as a standalone application and when it is run as an embedded component
inside a larger system (e.g. <code class="docutils literal notranslate"><span class="pre">mod_wsgi</span></code> running inside Apache <code class="docutils literal notranslate"><span class="pre">httpd</span></code>).</p>
<p>Over the course of Python 3.x development, multiple attempts have been made
to improve the handling of incorrect locale settings at the point where the
Python interpreter is initialised. The problem that emerged is that this is
ultimately <em>too late</em> in the interpreter startup process - data such as command
line arguments and the contents of environment variables may have already been
retrieved from the operating system and processed under the incorrect ASCII
text encoding assumption well before <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code> is called.</p>
<p>The problems created by those inconsistencies were then even harder to diagnose
and debug than those created by believing the operating system’s claim that
ASCII was a suitable encoding to use for operating system interfaces. This was
the case even for the default CPython binary, let alone larger C/C++
applications that embed CPython as a scripting engine.</p>
<p>The approach proposed in this PEP handles that problem by moving the locale
coercion as early as possible in the interpreter startup sequence when running
standalone: it takes place directly in the C-level <code class="docutils literal notranslate"><span class="pre">main()</span></code> function, even
before calling in to the <code class="docutils literal notranslate"><span class="pre">Py_Main()</span></code> library function that implements the
features of the CPython interpreter CLI.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code> API then only gains an explicit warning (emitted on
<code class="docutils literal notranslate"><span class="pre">stderr</span></code>) when it detects use of the <code class="docutils literal notranslate"><span class="pre">C</span></code> locale, and relies on the
embedding application to specify something more reasonable.</p>
<p>That said, the reference implementation for this PEP adds most of the
functionality to the shared library, with the CLI being updated to
unconditionally call two new private APIs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">_Py_LegacyLocaleDetected</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">_Py_CoerceLegacyLocale</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These are similar to other “pre-configuration” APIs intended for embedding
applications: they’re designed to be called <em>before</em> <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code>, and
hence change the way the interpreter gets initialized.</p>
<p>If these were made public (either as part of this PEP or in a subsequent RFE),
then it would be straightforward for other embedding applications to recreate
the same behaviour as is proposed for the CPython CLI.</p>
</section>
<section id="allowing-restoration-of-the-legacy-behaviour">
<h3><a class="toc-backref" href="#allowing-restoration-of-the-legacy-behaviour" role="doc-backlink">Allowing restoration of the legacy behaviour</a></h3>
<p>The CPython command line interpreter is often used to investigate faults that
occur in other applications that embed CPython, and those applications may still
be using the C locale even after this PEP is implemented.</p>
<p>Providing a simple on/off switch for the locale coercion behaviour makes it
much easier to reproduce the behaviour of such applications for debugging
purposes, as well as making it easier to reproduce the behaviour of older 3.x
runtimes even when running a version with this change applied.</p>
</section>
<section id="querying-lc-ctype-for-c-locale-detection">
<h3><a class="toc-backref" href="#querying-lc-ctype-for-c-locale-detection" role="doc-backlink">Querying LC_CTYPE for C locale detection</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> is the actual locale category that CPython relies on to drive the
implicit decoding of environment variables, command line arguments, and other
text values received from the operating system.</p>
<p>As such, it makes sense to check it specifically when attempting to determine
whether or not the current locale configuration is likely to cause Unicode
handling problems.</p>
</section>
<section id="explicitly-setting-lc-ctype-for-utf-8-locale-coercion">
<h3><a class="toc-backref" href="#explicitly-setting-lc-ctype-for-utf-8-locale-coercion" role="doc-backlink">Explicitly setting LC_CTYPE for UTF-8 locale coercion</a></h3>
<p>Python is often used as a glue language, integrating other C/C++ ABI compatible
components in the current process, and components written in arbitrary
languages in subprocesses.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> to <code class="docutils literal notranslate"><span class="pre">C.UTF-8</span></code> is important to handle cases where the
problem has arisen from a setting like <code class="docutils literal notranslate"><span class="pre">LC_CTYPE=UTF-8</span></code> being provided on a
system where no <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> locale is defined (e.g. when a Mac OS X ssh client is
configured to forward locale settings, and the user logs into a Linux server).</p>
<p>This should be sufficient to ensure that when the locale coercion is activated,
the switch to the UTF-8 based locale will be applied consistently across the
current process and any subprocesses that inherit the current environment.</p>
</section>
<section id="avoiding-setting-lang-for-utf-8-locale-coercion">
<h3><a class="toc-backref" href="#avoiding-setting-lang-for-utf-8-locale-coercion" role="doc-backlink">Avoiding setting LANG for UTF-8 locale coercion</a></h3>
<p>Earlier versions of this PEP proposed setting the <code class="docutils literal notranslate"><span class="pre">LANG</span></code> category independent
default locale, in addition to setting <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>.</p>
<p>This was later removed on the grounds that setting only <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> is
sufficient to handle all of the problematic scenarios that the PEP aimed
to resolve, while setting <code class="docutils literal notranslate"><span class="pre">LANG</span></code> as well would break cases where <code class="docutils literal notranslate"><span class="pre">LANG</span></code>
was set correctly, and the locale problems were solely due to an incorrect
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> setting (<a class="footnote-reference brackets" href="#id44" id="id11">[22]</a>).</p>
<p>For example, consider a Python application that called the Linux <code class="docutils literal notranslate"><span class="pre">date</span></code>
utility in a subprocess rather than doing its own date formatting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=ja_JP.UTF-8 LC_CTYPE=C date
2017年  5月 23日 火曜日 17:31:03 JST

$ LANG=ja_JP.UTF-8 LC_CTYPE=C.UTF-8 date  # Coercing only LC_CTYPE
2017年  5月 23日 火曜日 17:32:58 JST

$ LANG=C.UTF-8 LC_CTYPE=C.UTF-8 date  # Coercing both of LC_CTYPE and LANG
Tue May 23 17:31:10 JST 2017
</pre></div>
</div>
<p>With only <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> updated in the Python process, the subprocess would
continue to behave as expected. However, if <code class="docutils literal notranslate"><span class="pre">LANG</span></code> was updated as well,
that would effectively override the <code class="docutils literal notranslate"><span class="pre">LC_TIME</span></code> setting and use the wrong
date formatting conventions.</p>
</section>
<section id="avoiding-setting-lc-all-for-utf-8-locale-coercion">
<h3><a class="toc-backref" href="#avoiding-setting-lc-all-for-utf-8-locale-coercion" role="doc-backlink">Avoiding setting LC_ALL for UTF-8 locale coercion</a></h3>
<p>Earlier versions of this PEP proposed setting the <code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code> locale override,
in addition to setting <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>.</p>
<p>This was changed after it was determined that just setting <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> and
<code class="docutils literal notranslate"><span class="pre">LANG</span></code> should be sufficient to handle all the scenarios the PEP aims to
cover, as it avoids causing any problems in cases like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=C LC_MONETARY=ja_JP.utf8 ./python -c \
  &quot;from locale import setlocale, LC_ALL, currency; setlocale(LC_ALL, &#39;&#39;); print(currency(1e6))&quot;
￥1000000
</pre></div>
</div>
</section>
<section id="skipping-locale-coercion-if-lc-all-is-set-in-the-current-environment">
<h3><a class="toc-backref" href="#skipping-locale-coercion-if-lc-all-is-set-in-the-current-environment" role="doc-backlink">Skipping locale coercion if LC_ALL is set in the current environment</a></h3>
<p>With locale coercion now only setting <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">LANG</span></code>, it will have
no effect if <code class="docutils literal notranslate"><span class="pre">LC_ALL</span></code> is also set. To avoid emitting a spurious locale
coercion notice in that case, coercion is instead skipped entirely.</p>
</section>
<section id="considering-locale-coercion-independently-of-utf-8-mode">
<h3><a class="toc-backref" href="#considering-locale-coercion-independently-of-utf-8-mode" role="doc-backlink">Considering locale coercion independently of “UTF-8 mode”</a></h3>
<p>With both this PEP’s locale coercion and <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>’s UTF-8 mode under
consideration for Python 3.7, it makes sense to ask whether or not we can
limit ourselves to only doing one or the other, rather than making both
changes.</p>
<p>The UTF-8 mode proposed in <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> has two major limitations that make it a
potential complement to this PEP rather than a potential replacement.</p>
<p>First, unlike this PEP, <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>’s UTF-8 mode makes it possible to change default
behaviours that are not currently configurable at all. While that’s exactly
what makes the proposal interesting, it’s also what makes it an entirely
unproven approach. By contrast, the approach proposed in this PEP builds
directly atop existing configuration settings for the C locale system (
<code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>, <code class="docutils literal notranslate"><span class="pre">LANG</span></code>) and Python’s standard streams (<code class="docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code>)
that have already been in use for years to handle the kinds of compatibility
problems discussed in this PEP.</p>
<p>Secondly, one of the things we know based on that experience is that the
proposed locale coercion can resolve problems not only in CPython itself,
but also in extension modules that interact with the standard streams, like
GNU readline. As an example, consider the following interactive session
from a <a class="pep reference internal" href="../pep-0538/" title="PEP 538 – Coercing the legacy C locale to a UTF-8 based locale">PEP 538</a> enabled CPython build, where each line after the first is
executed by doing “up-arrow, left-arrow x4, delete, enter”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=C ./python
Python 3.7.0a0 (heads/pep538-coerce-c-locale:188e780, May  7 2017, 00:21:13)
[GCC 6.3.1 20161221 (Red Hat 6.3.1-1)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌøἤ&quot;)
ℙƴ☂ℌøἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌἤ&quot;)
ℙƴ☂ℌἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ἤ&quot;)
ℙƴ☂ἤ
&gt;&gt;&gt; print(&quot;ℙƴἤ&quot;)
ℙƴἤ
&gt;&gt;&gt; print(&quot;ℙἤ&quot;)
ℙἤ
&gt;&gt;&gt; print(&quot;ἤ&quot;)
ἤ
&gt;&gt;&gt;
</pre></div>
</div>
<p>This is exactly what we’d expect from a well-behaved command history editor.</p>
<p>By contrast, the following is what currently happens on an older release if
you only change the Python level stream encoding settings without updating the
locale settings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=C PYTHONIOENCODING=utf-8:surrogateescape python3
Python 3.5.3 (default, Apr 24 2017, 13:32:13)
[GCC 6.3.1 20161221 (Red Hat 6.3.1-1)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌøἤ&quot;)
ℙƴ☂ℌøἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌ�&quot;)
 File &quot;&lt;stdin&gt;&quot;, line 0

   ^
SyntaxError: &#39;utf-8&#39; codec can&#39;t decode bytes in position 20-21:
invalid continuation byte
</pre></div>
</div>
<p>That particular misbehaviour is coming from GNU readline, <em>not</em> CPython -
because the command history editing wasn’t UTF-8 aware, it corrupted the history
buffer and fed such nonsense to stdin that even the surrogateescape error
handler was bypassed. While <a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a>’s UTF-8 mode could technically be updated
to also reconfigure readline, that’s just <em>one</em> extension module that might
be interacting with the standard streams without going through the CPython
C API, and any change made by CPython would only apply when readline is running
directly as part of Python 3.7 rather than in a separate subprocess.</p>
<p>However, if we actually change the configured locale, GNU readline starts
behaving itself, without requiring any changes to the embedding application:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=C.UTF-8 python3
Python 3.5.3 (default, Apr 24 2017, 13:32:13)
[GCC 6.3.1 20161221 (Red Hat 6.3.1-1)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌøἤ&quot;)
ℙƴ☂ℌøἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌἤ&quot;)
ℙƴ☂ℌἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ἤ&quot;)
ℙƴ☂ἤ
&gt;&gt;&gt; print(&quot;ℙƴἤ&quot;)
ℙƴἤ
&gt;&gt;&gt; print(&quot;ℙἤ&quot;)
ℙἤ
&gt;&gt;&gt; print(&quot;ἤ&quot;)
ἤ
&gt;&gt;&gt;
$ LC_CTYPE=C.UTF-8 python3
Python 3.5.3 (default, Apr 24 2017, 13:32:13)
[GCC 6.3.1 20161221 (Red Hat 6.3.1-1)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌøἤ&quot;)
ℙƴ☂ℌøἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ℌἤ&quot;)
ℙƴ☂ℌἤ
&gt;&gt;&gt; print(&quot;ℙƴ☂ἤ&quot;)
ℙƴ☂ἤ
&gt;&gt;&gt; print(&quot;ℙƴἤ&quot;)
ℙƴἤ
&gt;&gt;&gt; print(&quot;ℙἤ&quot;)
ℙἤ
&gt;&gt;&gt; print(&quot;ἤ&quot;)
ἤ
&gt;&gt;&gt;
</pre></div>
</div>
</section>
<section id="enabling-c-locale-coercion-and-warnings-on-mac-os-x-ios-and-android">
<h3><a class="toc-backref" href="#enabling-c-locale-coercion-and-warnings-on-mac-os-x-ios-and-android" role="doc-backlink">Enabling C locale coercion and warnings on Mac OS X, iOS and Android</a></h3>
<p>On Mac OS X, iOS, and Android, CPython already assumes the use of UTF-8 for
system interfaces, and we expect most other locale-aware components to do the
same.</p>
<p>Accordingly, this PEP originally proposed to disable locale coercion and
warnings at build time for these platforms, on the assumption that it would
be entirely redundant.</p>
<p>However, that assumption turned out to be incorrect, as subsequent
investigations showed that if you explicitly configure <code class="docutils literal notranslate"><span class="pre">LANG=C</span></code> on
these platforms, extension modules like GNU readline will misbehave in much the
same way as they do on other *nix systems. <a class="footnote-reference brackets" href="#id43" id="id12">[21]</a></p>
<p>In addition, Mac OS X is also frequently used as a development and testing
platform for Python software intended for deployment to other *nix environments
(such as Linux or Android), and Linux is similarly often used as a development
and testing platform for mobile and Mac OS X applications.</p>
<p>Accordingly, this PEP enables the locale coercion and warning features by
default on all platforms that use CPython’s <code class="docutils literal notranslate"><span class="pre">autotools</span></code> based build toolchain
(i.e. everywhere other than Windows).</p>
</section>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>The reference implementation is being developed in the
<code class="docutils literal notranslate"><span class="pre">pep538-coerce-c-locale</span></code> feature branch <a class="footnote-reference brackets" href="#id40" id="id13">[18]</a> in Alyssa Coghlan’s fork of the
CPython repository on GitHub. A work-in-progress PR is available at <a class="footnote-reference brackets" href="#id42" id="id14">[20]</a>.</p>
<p>This reference implementation covers not only the enhancement request in
issue 28180 <a class="footnote-reference brackets" href="#id23" id="id15">[1]</a>, but also the Android compatibility fixes needed to resolve
issue 28997 <a class="footnote-reference brackets" href="#id38" id="id16">[16]</a>.</p>
</section>
<section id="backporting-to-earlier-python-3-releases">
<h2><a class="toc-backref" href="#backporting-to-earlier-python-3-releases" role="doc-backlink">Backporting to earlier Python 3 releases</a></h2>
<section id="backporting-to-python-3-6-x">
<h3><a class="toc-backref" href="#backporting-to-python-3-6-x" role="doc-backlink">Backporting to Python 3.6.x</a></h3>
<p>If this PEP is accepted for Python 3.7, redistributors backporting the change
specifically to their initial Python 3.6.x release will be both allowed and
encouraged. However, such backports should only be undertaken either in
conjunction with the changes needed to also provide a suitable locale by
default, or else specifically for platforms where such a locale is already
consistently available.</p>
<p>At least the Fedora project is planning to pursue this approach for the
upcoming Fedora 26 release <a class="footnote-reference brackets" href="#id41" id="id17">[19]</a>.</p>
</section>
<section id="backporting-to-other-3-x-releases">
<h3><a class="toc-backref" href="#backporting-to-other-3-x-releases" role="doc-backlink">Backporting to other 3.x releases</a></h3>
<p>While the proposed behavioural change is seen primarily as a bug fix addressing
Python 3’s current misbehaviour in the default ASCII-based C locale, it still
represents a reasonably significant change in the way CPython interacts with
the C locale system. As such, while some redistributors may still choose to
backport it to even earlier Python 3.x releases based on the needs and
interests of their particular user base, this wouldn’t be encouraged as a
general practice.</p>
<p>However, configuring Python 3 <em>environments</em> (such as base container
images) to use these configuration settings by default is both allowed
and recommended.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>The locale coercion approach proposed in this PEP is inspired directly by
Armin Ronacher’s handling of this problem in the <code class="docutils literal notranslate"><span class="pre">click</span></code> command line
utility development framework <a class="footnote-reference brackets" href="#id24" id="id18">[2]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ LANG=C python3 -c &#39;import click; cli = click.command()(lambda:None); cli()&#39;
Traceback (most recent call last):
  ...
RuntimeError: Click will abort further execution because Python 3 was
configured to use ASCII as encoding for the environment.  Either run this
under Python 2 or consult http://click.pocoo.org/python3/ for mitigation
steps.

This system supports the C.UTF-8 locale which is recommended.
You might be able to resolve your issue by exporting the
following environment variables:

    export LC_ALL=C.UTF-8
    export LANG=C.UTF-8
</pre></div>
</div>
<p>The change was originally proposed as a downstream patch for Fedora’s
system Python 3.6 package <a class="footnote-reference brackets" href="#id25" id="id19">[3]</a>, and then reformulated as a PEP for Python 3.7
with a section allowing for backports to earlier versions by redistributors.
In parallel with the development of the upstream patch, Charalampos Stratakis
has been working on the Fedora 26 backport and providing feedback on the
practical viability of the proposed changes.</p>
<p>The initial draft was posted to the Python Linux SIG for discussion <a class="footnote-reference brackets" href="#id32" id="id20">[10]</a> and
then amended based on both that discussion and Victor Stinner’s work in
<a class="pep reference internal" href="../pep-0540/" title="PEP 540 – Add a new UTF-8 Mode">PEP 540</a> <a class="footnote-reference brackets" href="#id33" id="id21">[11]</a>.</p>
<p>The “ℙƴ☂ℌøἤ” string used in the Unicode handling examples throughout this PEP
is taken from Ned Batchelder’s excellent “Pragmatic Unicode” presentation <a class="footnote-reference brackets" href="#id31" id="id22">[9]</a>.</p>
<p>Stephen Turnbull has long provided valuable insight into the text encoding
handling challenges he regularly encounters at the University of Tsukuba
(筑波大学).</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<dt class="label" id="id23">[<a href="#id15">1</a>]</dt>
<dd>CPython: sys.getfilesystemencoding() should default to utf-8
(<a class="reference external" href="https://bugs.python.org/issue28180">https://bugs.python.org/issue28180</a>)</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<dt class="label" id="id24">[<a href="#id18">2</a>]</dt>
<dd>Locale configuration required for click applications under Python 3
(<a class="reference external" href="https://click.palletsprojects.com/en/5.x/python3/#python-3-surrogate-handling">https://click.palletsprojects.com/en/5.x/python3/#python-3-surrogate-handling</a>)</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<dt class="label" id="id25">[<a href="#id19">3</a>]</dt>
<dd>Fedora: force C.UTF-8 when Python 3 is run under the C locale
(<a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1404918">https://bugzilla.redhat.com/show_bug.cgi?id=1404918</a>)</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<dt class="label" id="id26">[<a href="#id1">4</a>]</dt>
<dd>GNU C: How Programs Set the Locale
(<a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Setting-the-Locale.html">https://www.gnu.org/software/libc/manual/html_node/Setting-the-Locale.html</a>)</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<dt class="label" id="id27">[<a href="#id2">5</a>]</dt>
<dd>GNU C: Locale Categories
(<a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html">https://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html</a>)</aside>
<aside class="footnote brackets" id="id28" role="doc-footnote">
<dt class="label" id="id28">[<a href="#id6">6</a>]</dt>
<dd>glibc C.UTF-8 locale proposal
(<a class="reference external" href="https://sourceware.org/glibc/wiki/Proposals/C.UTF-8">https://sourceware.org/glibc/wiki/Proposals/C.UTF-8</a>)</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<dt class="label" id="id29">[<a href="#id4">7</a>]</dt>
<dd>GNOME Flatpak
(<a class="reference external" href="https://flatpak.org/">https://flatpak.org/</a>)</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<dt class="label" id="id30">[<a href="#id5">8</a>]</dt>
<dd>Ubuntu Snappy
(<a class="reference external" href="https://www.ubuntu.com/desktop/snappy">https://www.ubuntu.com/desktop/snappy</a>)</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<dt class="label" id="id31">[<a href="#id22">9</a>]</dt>
<dd>Pragmatic Unicode
(<a class="reference external" href="https://nedbatchelder.com/text/unipain.html">https://nedbatchelder.com/text/unipain.html</a>)</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<dt class="label" id="id32">[<a href="#id20">10</a>]</dt>
<dd>linux-sig discussion of initial PEP draft
(<a class="reference external" href="https://mail.python.org/pipermail/linux-sig/2017-January/000014.html">https://mail.python.org/pipermail/linux-sig/2017-January/000014.html</a>)</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<dt class="label" id="id33">[<a href="#id21">11</a>]</dt>
<dd>Feedback notes from linux-sig discussion and PEP 540
(<a class="reference external" href="https://github.com/python/peps/issues/171">https://github.com/python/peps/issues/171</a>)</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<dt class="label" id="id34">[<a href="#id8">12</a>]</dt>
<dd>GB 18030
(<a class="reference external" href="https://en.wikipedia.org/wiki/GB_18030">https://en.wikipedia.org/wiki/GB_18030</a>)</aside>
<aside class="footnote brackets" id="id35" role="doc-footnote">
<dt class="label" id="id35">[<a href="#id9">13</a>]</dt>
<dd>Shift-JIS
(<a class="reference external" href="https://en.wikipedia.org/wiki/Shift_JIS">https://en.wikipedia.org/wiki/Shift_JIS</a>)</aside>
<aside class="footnote brackets" id="id36" role="doc-footnote">
<dt class="label" id="id36">[<a href="#id10">14</a>]</dt>
<dd>ISO-2022
(<a class="reference external" href="https://en.wikipedia.org/wiki/ISO/IEC_2022">https://en.wikipedia.org/wiki/ISO/IEC_2022</a>)</aside>
<aside class="footnote brackets" id="id37" role="doc-footnote">
<dt class="label" id="id37">[<a href="#id7">15</a>]</dt>
<dd>Use “surrogateescape” error handler for sys.stdin and sys.stdout on UNIX for the C locale
(<a class="reference external" href="https://bugs.python.org/issue19977">https://bugs.python.org/issue19977</a>)</aside>
<aside class="footnote brackets" id="id38" role="doc-footnote">
<dt class="label" id="id38">[<a href="#id16">16</a>]</dt>
<dd>test_readline.test_nonascii fails on Android
(<a class="reference external" href="https://bugs.python.org/issue28997">https://bugs.python.org/issue28997</a>)</aside>
<aside class="footnote brackets" id="id39" role="doc-footnote">
<dt class="label" id="id39">[<a href="#id3">17</a>]</dt>
<dd>UTF-8 locale discussion on “locale.getdefaultlocale() fails on Mac OS X with default language set to English”
(<a class="reference external" href="https://bugs.python.org/issue18378#msg215215">https://bugs.python.org/issue18378#msg215215</a>)</aside>
<aside class="footnote brackets" id="id40" role="doc-footnote">
<dt class="label" id="id40">[<a href="#id13">18</a>]</dt>
<dd>GitHub branch diff for <code class="docutils literal notranslate"><span class="pre">ncoghlan:pep538-coerce-c-locale</span></code>
(<a class="reference external" href="https://github.com/python/cpython/compare/master...ncoghlan:pep538-coerce-c-locale">https://github.com/python/cpython/compare/master…ncoghlan:pep538-coerce-c-locale</a>)</aside>
<aside class="footnote brackets" id="id41" role="doc-footnote">
<dt class="label" id="id41">[<a href="#id17">19</a>]</dt>
<dd>Fedora 26 change proposal for locale coercion backport
(<a class="reference external" href="https://fedoraproject.org/wiki/Changes/python3_c.utf-8_locale">https://fedoraproject.org/wiki/Changes/python3_c.utf-8_locale</a>)</aside>
<aside class="footnote brackets" id="id42" role="doc-footnote">
<dt class="label" id="id42">[<a href="#id14">20</a>]</dt>
<dd>GitHub pull request for the reference implementation
(<a class="reference external" href="https://github.com/python/cpython/pull/659">https://github.com/python/cpython/pull/659</a>)</aside>
<aside class="footnote brackets" id="id43" role="doc-footnote">
<dt class="label" id="id43">[<a href="#id12">21</a>]</dt>
<dd>GNU readline misbehaviour on Mac OS X with <code class="docutils literal notranslate"><span class="pre">LANG=C</span></code>
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-May/147897.html">https://mail.python.org/pipermail/python-dev/2017-May/147897.html</a>)</aside>
<aside class="footnote brackets" id="id44" role="doc-footnote">
<dt class="label" id="id44">[<a href="#id11">22</a>]</dt>
<dd>Potential problems when setting LANG in addition to setting LC_CTYPE
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-May/147968.html">https://mail.python.org/pipermail/python-dev/2017-May/147968.html</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain under the terms of the
CC0 1.0 license: <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0538.rst">https://github.com/python/peps/blob/main/peps/pep-0538.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0538.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#design-principles">Design Principles</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#legacy-c-locale-coercion-in-the-standalone-python-interpreter-binary">Legacy C locale coercion in the standalone Python interpreter binary</a></li>
<li><a class="reference internal" href="#legacy-c-locale-warning-during-runtime-initialization">Legacy C locale warning during runtime initialization</a></li>
<li><a class="reference internal" href="#new-build-time-configuration-options">New build-time configuration options</a></li>
<li><a class="reference internal" href="#changes-to-the-default-error-handling-on-the-standard-streams">Changes to the default error handling on the standard streams</a></li>
<li><a class="reference internal" href="#changes-to-locale-settings-on-android">Changes to locale settings on Android</a></li>
</ul>
</li>
<li><a class="reference internal" href="#platform-support-changes">Platform Support Changes</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#improving-the-handling-of-the-c-locale">Improving the handling of the C locale</a></li>
<li><a class="reference internal" href="#defaulting-to-surrogateescape-error-handling-on-the-standard-io-streams">Defaulting to “surrogateescape” error handling on the standard IO streams</a></li>
<li><a class="reference internal" href="#avoiding-setting-pythonioencoding-during-utf-8-locale-coercion">Avoiding setting PYTHONIOENCODING during UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#dropping-official-support-for-ascii-based-text-handling-in-the-legacy-c-locale">Dropping official support for ASCII based text handling in the legacy C locale</a></li>
<li><a class="reference internal" href="#providing-implicit-locale-coercion-only-when-running-standalone">Providing implicit locale coercion only when running standalone</a></li>
<li><a class="reference internal" href="#allowing-restoration-of-the-legacy-behaviour">Allowing restoration of the legacy behaviour</a></li>
<li><a class="reference internal" href="#querying-lc-ctype-for-c-locale-detection">Querying LC_CTYPE for C locale detection</a></li>
<li><a class="reference internal" href="#explicitly-setting-lc-ctype-for-utf-8-locale-coercion">Explicitly setting LC_CTYPE for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#avoiding-setting-lang-for-utf-8-locale-coercion">Avoiding setting LANG for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#avoiding-setting-lc-all-for-utf-8-locale-coercion">Avoiding setting LC_ALL for UTF-8 locale coercion</a></li>
<li><a class="reference internal" href="#skipping-locale-coercion-if-lc-all-is-set-in-the-current-environment">Skipping locale coercion if LC_ALL is set in the current environment</a></li>
<li><a class="reference internal" href="#considering-locale-coercion-independently-of-utf-8-mode">Considering locale coercion independently of “UTF-8 mode”</a></li>
<li><a class="reference internal" href="#enabling-c-locale-coercion-and-warnings-on-mac-os-x-ios-and-android">Enabling C locale coercion and warnings on Mac OS X, iOS and Android</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#backporting-to-earlier-python-3-releases">Backporting to earlier Python 3 releases</a><ul>
<li><a class="reference internal" href="#backporting-to-python-3-6-x">Backporting to Python 3.6.x</a></li>
<li><a class="reference internal" href="#backporting-to-other-3-x-releases">Backporting to other 3.x releases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0538.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>