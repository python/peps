
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 788 – Protecting the C API from Interpreter Finalization | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0788/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 788 – Protecting the C API from Interpreter Finalization | peps.python.org'>
    <meta property="og:description" content="This PEP introduces a suite of functions in the C API to safely attach to an interpreter by preventing finalization. For example:">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0788/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP introduces a suite of functions in the C API to safely attach to an interpreter by preventing finalization. For example:">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 788</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 788 – Protecting the C API from Interpreter Finalization</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Peter Bierma &lt;zintensitydev&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Victor Stinner &lt;vstinner&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/104150">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">23-Apr-2025</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/83959" title="Discourse thread">10-Mar-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/89863" title="Discourse thread">27-Apr-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/93653" title="Discourse thread">28-May-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/104150" title="Discourse thread">03-Oct-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#non-python-threads-always-hang-during-finalization">Non-Python Threads Always Hang During Finalization</a><ul>
<li><a class="reference internal" href="#py-isfinalizing-is-not-atomic"><code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> Is Not Atomic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locks-in-native-extensions-can-be-unusable-during-finalization">Locks in Native Extensions Can Be Unusable During Finalization</a></li>
<li><a class="reference internal" href="#finalization-behavior-for-pygilstate-ensure-cannot-change">Finalization Behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Cannot Change</a></li>
<li><a class="reference internal" href="#the-term-gil-is-tricky-for-free-threading">The Term “GIL” Is Tricky for Free-threading</a></li>
<li><a class="reference internal" href="#pygilstate-ensure-doesn-t-guess-the-correct-interpreter"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Doesn’t Guess the Correct Interpreter</a></li>
<li><a class="reference internal" href="#subinterpreters-can-concurrently-deallocate">Subinterpreters Can Concurrently Deallocate</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#preventing-interpreter-shutdown">Preventing Interpreter Shutdown</a></li>
<li><a class="reference internal" href="#compatibility-shim-for-pygilstate-ensure">Compatibility Shim for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#interpreter-guards">Interpreter Guards</a></li>
<li><a class="reference internal" href="#interpreter-views">Interpreter Views</a></li>
<li><a class="reference internal" href="#ensuring-and-releasing-thread-states">Ensuring and Releasing Thread States</a></li>
<li><a class="reference internal" href="#deprecation-of-pygilstate-apis">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a><ul>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#example-a-library-interface">Example: A Library Interface</a></li>
<li><a class="reference internal" href="#example-a-single-threaded-ensure">Example: A Single-threaded Ensure</a></li>
<li><a class="reference internal" href="#example-transitioning-from-the-legacy-functions">Example: Transitioning From the Legacy Functions</a></li>
<li><a class="reference internal" href="#example-a-daemon-thread">Example: A Daemon Thread</a></li>
<li><a class="reference internal" href="#example-an-asynchronous-callback">Example: An Asynchronous Callback</a></li>
<li><a class="reference internal" href="#example-calling-python-without-a-callback-parameter">Example: Calling Python Without a Callback Parameter</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#how-should-the-apis-fail">How Should the APIs Fail?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#interpreter-reference-counting">Interpreter Reference Counting</a></li>
<li><a class="reference internal" href="#non-daemon-thread-states">Non-daemon Thread States</a></li>
<li><a class="reference internal" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API Instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></li>
<li><a class="reference internal" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the Return Value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces a suite of functions in the C API to safely attach to an
interpreter by preventing finalization. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_function</span><span class="p">(</span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Prevent the interpreter from finalizing</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromView</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Analogous to PyGILState_Ensure(), but this is thread-safe.</span>
<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Now we can call Python code, without worrying about the thread</span>
<span class="w">    </span><span class="c1">// hanging due to finalization.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(&#39;My hovercraft is full of eels&#39;) &lt; 0) {</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Destroy the thread state and allow the interpreter to finalize.</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition, the APIs in the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> family are deprecated by this
proposal.</p>
</section>
<section id="background">
<h2><a class="toc-backref" href="#background" role="doc-backlink">Background</a></h2>
<p>In the C API, threads can interact with an interpreter by holding an
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> for the current thread. This can get complicated
when it comes to creating and attaching <a class="reference external" href="https://docs.python.org/3/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread states</span></a>
in a safe manner, because any non-Python thread (one not created via the
<a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module) is considered to be “daemon”, meaning that the interpreter
won’t wait on that thread before shutting down. Instead, the interpreter will hang the
thread when it attempts to attach a thread state, making the thread unusable
thereafter.</p>
<p>Attaching a thread state can happen at any point when invoking Python, such
as in-between bytecode instructions (to yield the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-GIL" title="(in Python v3.14)"><span class="xref std std-term">GIL</span></a> to a different thread),
or when a C function exits a <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.14)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> block, so simply
guarding against whether the interpreter is finalizing isn’t enough to safely
call Python code. (Note that hanging the thread is a relatively new behavior;
in older versions, the thread would exit, but the issue is the same.)</p>
<p>Currently, the C API doesn’t provide any way to ensure that an interpreter is
in a state that won’t cause a thread to hang when trying to attach. This can
be a frustrating issue in large applications that need to execute Python code
alongside other native code.</p>
<p>In addition, a typical pattern among users creating non-Python threads is to
use <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>, which was introduced in <a class="pep reference internal" href="../pep-0311/" title="PEP 311 – Simplified Global Interpreter Lock Acquisition for Extensions">PEP 311</a>. This has
been very unfortunate for subinterpreters, because <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>
tends to create a thread state for the main interpreter rather than the
current interpreter. This leads to thread-safety issues when extensions create
threads that interact with the Python interpreter, because assumptions about
the GIL are incorrect.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<section id="non-python-threads-always-hang-during-finalization">
<h3><a class="toc-backref" href="#non-python-threads-always-hang-during-finalization" role="doc-backlink">Non-Python Threads Always Hang During Finalization</a></h3>
<p>Many large libraries might need to call Python code in highly asynchronous
situations where the desired interpreter could be finalizing or deleted, but
want to continue running code after invoking the interpreter. This desire has been
<a class="reference external" href="https://discuss.python.org/t/78850/">brought up by users</a>.
For example, a callback that wants to call Python code might be invoked when:</p>
<ul class="simple">
<li>A kernel has finished running on a GPU.</li>
<li>A network packet was received.</li>
<li>A thread has quit, and a native library is executing static finalizers for
thread-local storage.</li>
</ul>
<p>Generally, this pattern would look something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">some_callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Do some work */</span>
<span class="w">    </span><span class="cm">/* ... */</span>

<span class="w">    </span><span class="n">PyGILState_STATE</span><span class="w"> </span><span class="n">gstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyGILState_Ensure</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* Invoke the C API to do some computation */</span>
<span class="w">    </span><span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This means that any non-Python thread may be terminated at any point, which
severely limits users who want to do more than just execute Python
code in their stream of calls.</p>
<section id="py-isfinalizing-is-not-atomic">
<h4><a class="toc-backref" href="#py-isfinalizing-is-not-atomic" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> Is Not Atomic</a></h4>
<p>Due to the problem mentioned previously, the <a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.14)"><span class="xref std std-ref">docs</span></a>
currently recommend <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_IsFinalizing" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code></a> to guard against termination of
the thread:</p>
<blockquote>
<div>Calling this function from a thread when the runtime is finalizing will
terminate the thread, even if the thread was not created by Python. You
can use <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code> or <code class="docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code> to check if the
interpreter is in process of being finalized before calling this function
to avoid unwanted termination.</div></blockquote>
<p>Unfortunately, this doesn’t work reliably, because of time-of-call to time-of-use
issues; the interpreter might not be finalizing during the call to
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_IsFinalizing" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code></a>, but it might start finalizing immediately
afterward, which would cause the attachment of a thread state to hang the
thread.</p>
<p>Users have <a class="reference external" href="https://discuss.python.org/t/48034">expressed a desire</a> for an
atomic way to call <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> in the past.</p>
</section>
</section>
<section id="locks-in-native-extensions-can-be-unusable-during-finalization">
<h3><a class="toc-backref" href="#locks-in-native-extensions-can-be-unusable-during-finalization" role="doc-backlink">Locks in Native Extensions Can Be Unusable During Finalization</a></h3>
<p>When acquiring locks in a native API, it’s common to release the GIL (or
critical sections on the free-threaded build) to avoid lock-ordering deadlocks.
This can be problematic during finalization, because threads holding locks might
be hung. For example:</p>
<ol class="arabic simple">
<li>A thread goes to acquire a lock, first detaching its thread state to avoid
deadlocks.</li>
<li>The main thread begins finalization and tells all thread states to hang
upon attachment.</li>
<li>The thread acquires the lock it was waiting on, but then hangs while attempting
to reattach its thread state via <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS" title="(in Python v3.14)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>.</li>
<li>The main thread can no longer acquire the lock, because the thread holding it
has hung.</li>
</ol>
<p>This affects CPython itself, and there’s not much that can be done
to fix it with the current API. For example,
<a class="reference external" href="https://github.com/python/cpython/issues/129536">python/cpython#129536</a>
remarks that the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module can emit a fatal error when used at
finalization, because a daemon thread got hung while holding the lock
for <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.stderr" title="(in Python v3.14)"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>, and then a finalizer tried to write to it.
Ideally, a thread should be able to temporarily prevent the interpreter
from hanging it while it holds the lock.</p>
</section>
<section id="finalization-behavior-for-pygilstate-ensure-cannot-change">
<span id="pep-788-hanging-compat"></span><h3><a class="toc-backref" href="#finalization-behavior-for-pygilstate-ensure-cannot-change" role="doc-backlink">Finalization Behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Cannot Change</a></h3>
<p>There will always have to be a point in a Python program where
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> can no longer attach a thread state.
If the interpreter is long dead, then Python obviously can’t give a
thread a way to invoke it. <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> doesn’t have any
meaningful way to return a failure, so it has no choice but to terminate
the thread or emit a fatal error, as noted in
<a class="reference external" href="https://github.com/python/cpython/issues/124622">python/cpython#124622</a>:</p>
<blockquote>
<div>I think a new GIL acquisition and release C API would be needed. The way
the existing ones get used in existing C code is not amenible to suddenly
bolting an error state onto; none of the existing C code is written that
way. After the call they always just assume they have the GIL and can
proceed. The API was designed as “it’ll block and only return once it has
the GIL” without any other option.</div></blockquote>
<p>As a result, CPython can’t make any real changes to how <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>
works during finalization, because it would break existing code.</p>
</section>
<section id="the-term-gil-is-tricky-for-free-threading">
<h3><a class="toc-backref" href="#the-term-gil-is-tricky-for-free-threading" role="doc-backlink">The Term “GIL” Is Tricky for Free-threading</a></h3>
<p>A significant issue with the term “GIL” in the C API is that it is semantically
misleading. This was noted in <a class="reference external" href="https://github.com/python/cpython/issues/127989">python/cpython#127989</a>,
created by the author of this PEP:</p>
<blockquote>
<div>The biggest issue is that for free-threading, there is no GIL, so users
erroneously call the C API inside <code class="docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code> blocks or
omit <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> in fresh threads.</div></blockquote>
<p>Again, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> gets an attached thread state for the
thread on both with-GIL and free-threaded builds. An attached thread state is
always needed to call the C API, so <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> still needs
to be called on free-threaded builds, but with a name like “ensure GIL”, it’s
not immediately clear that that’s true.</p>
</section>
<section id="pygilstate-ensure-doesn-t-guess-the-correct-interpreter">
<span id="pep-788-subinterpreters-gilstate"></span><h3><a class="toc-backref" href="#pygilstate-ensure-doesn-t-guess-the-correct-interpreter" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Doesn’t Guess the Correct Interpreter</a></h3>
<p>As noted in the <a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.14)"><span class="xref std std-ref">documentation</span></a>,
the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> functions aren’t officially supported in subinterpreters:</p>
<blockquote>
<div>Note that the <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> functions assume there is only one global
interpreter (created automatically by <code class="docutils literal notranslate"><span class="pre">Py_Initialize()</span></code>). Python
supports the creation of additional interpreters (using
<code class="docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code>), but mixing multiple interpreters and the
<code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API is unsupported.</div></blockquote>
<p>This is because <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> doesn’t have any way
to know which interpreter created the thread, and as such, it has to assume
that it was the main interpreter. There isn’t any way to detect this at
runtime, so spurious races are bound to come up in threads created by
subinterpreters, because synchronization for the wrong interpreter will be
used on objects shared between the threads.</p>
<p>For example, if the thread had access to object A, which belongs to a
subinterpreter, but then called <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>, the thread would
have an attached thread state pointing to the main interpreter,
not the subinterpreter. This means that any GIL assumptions about the
object are wrong, because there is no synchronization between the two GILs.</p>
<p>There’s no great way to solve this, other than introducing a new API that
explicitly takes an interpreter from the caller.</p>
</section>
<section id="subinterpreters-can-concurrently-deallocate">
<h3><a class="toc-backref" href="#subinterpreters-can-concurrently-deallocate" role="doc-backlink">Subinterpreters Can Concurrently Deallocate</a></h3>
<p>The other way of creating a non-Python thread, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a> and
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Swap" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a>, is a lot better for supporting subinterpreters
(because <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a> takes an explicit interpreter, rather than
assuming that the main interpreter was requested), but is still limited by the
current hanging problems in the C API, and is subject to crashes when the
subinterpreter finalizes before the thread has a chance to start. This is because
in subinterpreters, the <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></code> structure is allocated on the
heap, whereas the main interpreter is statically allocated on the Python runtime
state.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<section id="preventing-interpreter-shutdown">
<h3><a class="toc-backref" href="#preventing-interpreter-shutdown" role="doc-backlink">Preventing Interpreter Shutdown</a></h3>
<p>This PEP takes an approach in which an interpreter includes a guarding API
that prevents it from shutting down. Holding an interpreter guard ensures it is
safe to call the C API without worrying about the thread being hung by finalization.</p>
<p>This means that interfacing with Python (for example, in a C++ library) will need
a guard to the interpreter in order to safely call the object, which is more
inconvenient than assuming the main interpreter is the right choice, but
there’s not really another option.</p>
<p>This proposal also comes with “views” to an interpreter that can be used to
safely poke at an interpreter that may be dead or alive. Using a view, users
can create an interpreter guard at any point during its lifecycle, and it
will safely fail if the interpreter can no longer support calling Python code.</p>
</section>
<section id="compatibility-shim-for-pygilstate-ensure">
<h3><a class="toc-backref" href="#compatibility-shim-for-pygilstate-ensure" role="doc-backlink">Compatibility Shim for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></h3>
<p>This proposal comes with <a class="reference internal" href="#c.PyUnstable_InterpreterView_FromDefault" title="PyUnstable_InterpreterView_FromDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnstable_InterpreterView_FromDefault()</span></code></a> as a
compatibility hack for some users of <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>. It is a
thread-safe way to create a guard for the main (or “default”)
interpreter.</p>
<p>The main drawback to porting new code to <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> is that
it isn’t a drop-in replacement for <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code>, as it needs
an interpreter guard argument. In some large applications, refactoring to
use a <a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterGuard</span></code></a> everywhere might be tricky, so this function
serves as a last resort for users who explicitly want to disallow support for
subinterpreters.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="interpreter-guards">
<h3><a class="toc-backref" href="#interpreter-guards" role="doc-backlink">Interpreter Guards</a></h3>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterGuard">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard</span></span></span><br /></dt>
<dd>An opaque interpreter guard.<p>By holding an interpreter guard, the caller can ensure that the interpreter
will not finalize until the guard is destroyed.</p>
<p>This is similar to a “readers-writers” lock; threads may hold an
interpreter’s guard concurrently, and the interpreter will have to wait
until all threads have destroyed their guards before it can enter finalization.</p>
<p>This type is guaranteed to be pointer-sized.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterGuard_FromCurrent">
<a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard_FromCurrent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Create a finalization guard for the current interpreter.<p>On success, this function guards the interpreter and returns an opaque
reference to the guard; on failure, it returns <code class="docutils literal notranslate"><span class="pre">0</span></code> with an exception set.</p>
<p>The caller must hold an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterGuard_FromView">
<a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard_FromView</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="n"><span class="pre">view</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Create a finalization guard for an interpreter through a view.<p>On success, this function returns a guard to the interpreter
represented by <em>view</em>. The view is still valid after calling this
function.</p>
<p>If the interpreter no longer exists or cannot safely run Python code,
this function returns <code class="docutils literal notranslate"><span class="pre">0</span></code> without setting an exception.</p>
<p>The caller does not need to hold an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterGuard_GetInterpreter">
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.14)"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard_GetInterpreter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="n"><span class="pre">guard</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Return the <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.14)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> pointer protected by <em>guard</em>.<p>This function cannot fail, and the caller doesn’t need to hold an
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterGuard_Copy">
<a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard_Copy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="n"><span class="pre">guard</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Duplicate an interpreter guard.<p>On success, this function returns a copy of <em>guard</em>; on failure, it returns
<code class="docutils literal notranslate"><span class="pre">0</span></code> without an exception set.</p>
<p>The caller does not need to hold an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterGuard_Close">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterGuard_Close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="n"><span class="pre">guard</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Destroy an interpreter guard, allowing the interpreter to enter
finalization if no other guards remain.<p>This function cannot fail, and the caller doesn’t need to hold an
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

</section>
<section id="interpreter-views">
<h3><a class="toc-backref" href="#interpreter-views" role="doc-backlink">Interpreter Views</a></h3>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterView">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterView</span></span></span><br /></dt>
<dd>An opaque view of an interpreter.<p>This is a thread-safe way to access an interpreter that may be finalized
in another thread.</p>
<p>This type is guaranteed to be pointer-sized.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterView_FromCurrent">
<a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterView_FromCurrent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Create a view to the current interpreter.<p>This function is generally meant to be used in tandem with
<a class="reference internal" href="#c.PyInterpreterGuard_FromView" title="PyInterpreterGuard_FromView"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterGuard_FromView()</span></code></a>.</p>
<p>On success, this function returns a view to the current interpreter; on
failure, it returns <code class="docutils literal notranslate"><span class="pre">0</span></code> with an exception set.</p>
<p>The caller must hold an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterView_Copy">
<a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterView_Copy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="n"><span class="pre">view</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Duplicate a view to an interpreter.<p>On success, this function returns a non-zero copy of <em>view</em>; on failure,
it returns <code class="docutils literal notranslate"><span class="pre">0</span></code> without an exception set.</p>
<p>This function cannot fail, and the caller doesn’t need to hold an
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterView_Close">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterView_Close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="n"><span class="pre">view</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Delete an interpreter view.<p>This function cannot fail, and the caller doesn’t need to hold an
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyUnstable_InterpreterView_FromDefault">
<a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><span class="n"><span class="pre">PyInterpreterView</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyUnstable_InterpreterView_FromDefault</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd>Create a view for an arbitrary “main” interpreter.<p>This function only exists for exceptional cases where a specific interpreter
can’t be saved.</p>
<p>On success, this function returns a view to the main
interpreter; on failure, it returns <code class="docutils literal notranslate"><span class="pre">0</span></code> without an exception set.</p>
<p>The caller does not need to hold an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

</section>
<section id="ensuring-and-releasing-thread-states">
<h3><a class="toc-backref" href="#ensuring-and-releasing-thread-states" role="doc-backlink">Ensuring and Releasing Thread States</a></h3>
<p>This proposal includes two new high-level threading APIs that intend to
replace <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyThreadView">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadView</span></span></span><br /></dt>
<dd>An opaque view of a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread state</span></a>.<p>In this PEP, a thread view provides no additional properties beyond a
<span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState" title="(in Python v3.14)"><span class="n">PyThreadState</span></a><span class="p">*</span></span> pointer. However, APIs for <code class="docutils literal notranslate"><span class="pre">PyThreadView</span></code> may
be added in the future.</p>
<p>This type is guaranteed to be pointer-sized.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Ensure">
<a class="reference internal" href="#c.PyThreadView" title="PyThreadView"><span class="n"><span class="pre">PyThreadView</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Ensure</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><span class="n"><span class="pre">PyInterpreterGuard</span></span></a><span class="w"> </span><span class="n"><span class="pre">guard</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Ensure that the thread has an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> for the
interpreter protected by <em>guard</em>, and thus can safely invoke that
interpreter. It is OK to call this function if the thread already has an
attached thread state, as long as there is a subsequent call to
<a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> that matches this one.<p>Nested calls to this function will only sometimes create a new
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread state</span></a>. If there is no attached thread state,
then this function will check for the most recent attached thread
state used by this thread. If none exists or it doesn’t match <em>guard</em>,
a new thread state is created. If it does match <em>guard</em>, it is reattached.
If there is an attached thread state, then a similar check occurs;
if the interpreter matches <em>guard</em>, it is attached, and otherwise a new
thread state is created.</p>
<p>Return a non-zero thread view of the old thread state on success, and
<code class="docutils literal notranslate"><span class="pre">0</span></code> on failure.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Release</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadView" title="PyThreadView"><span class="n"><span class="pre">PyThreadView</span></span></a><span class="w"> </span><span class="n"><span class="pre">view</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Release a <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> call.<p>The <a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> before the corresponding
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> call is guaranteed to be restored upon
returning. The cached thread state as used (the “GIL-state”), by
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>, will also
be restored.</p>
<p>This function cannot fail.</p>
</dd></dl>

</section>
<section id="deprecation-of-pygilstate-apis">
<h3><a class="toc-backref" href="#deprecation-of-pygilstate-apis" role="doc-backlink">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></h3>
<p>This PEP deprecates all of the existing <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs in favor of the
existing and new <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> APIs. Namely:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>: use <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>: use <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_GetThisThreadState" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_GetThisThreadState()</span></code></a>: use <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Get" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a> or
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_GetUnchecked" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Check" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Check()</span></code></a>: use <code class="docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span> <span class="pre">!=</span> <span class="pre">NULL</span></code>
instead.</li>
</ul>
<p>All of the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs are to be removed from the non-limited C API in
Python 3.20. They will remain available in the stable ABI for
compatibility.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>This PEP specifies a breaking change with the removal of all the
<code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs from the public headers of the non-limited C API in
Python 3.20.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>This PEP has no known security implications.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>As with all C API functions, all the new APIs in this PEP will be documented
in the C API documentation, ideally under the “<a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.14)"><span>Non-Python created threads</span></a>” section.
The existing <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> documentation should be updated accordingly to point
to the new APIs.</p>
<section id="examples">
<h3><a class="toc-backref" href="#examples" role="doc-backlink">Examples</a></h3>
<p>These examples are here to help understand the APIs described in this PEP.
They could be reused in the documentation.</p>
<section id="example-a-library-interface">
<h4><a class="toc-backref" href="#example-a-library-interface" role="doc-backlink">Example: A Library Interface</a></h4>
<p>Imagine that you’re developing a C library for logging.
You might want to provide an API that allows users to log to a Python file
object.</p>
<p>With this PEP, you would implement it like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">LogToPyFile</span><span class="p">(</span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="p">,</span>
<span class="w">            </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span>
<span class="w">            </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">text</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromView</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Python interpreter has shut down */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Cannot call Python.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">to_write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyUnicode_AsUTF8</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">to_write</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Since the exception may be destroyed upon calling PyThreadState_Release(),</span>
<span class="w">        </span><span class="c1">// print out the exception ourselves.</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">        </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyFile_WriteString</span><span class="p">(</span><span class="n">to_write</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">to_write</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-a-single-threaded-ensure">
<h4><a class="toc-backref" href="#example-a-single-threaded-ensure" role="doc-backlink">Example: A Single-threaded Ensure</a></h4>
<p>This example shows how to acquire a C lock in a Python method defined from C.</p>
<p>If this were called from a daemon thread, the interpreter could hang the
thread while reattaching its thread state, leaving us with the lock held. Any
future finalizer that attempts to acquire the lock would be deadlocked.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_critical_operation</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">Py_UNUSED</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">PyThreadState_GetUnchecked</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromCurrent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Python interpreter has shut down */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">acquire_some_lock</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* Do something while holding the lock.</span>
<span class="cm">       The interpreter won&#39;t finalize during this period. */</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">release_some_lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-transitioning-from-the-legacy-functions">
<h4><a class="toc-backref" href="#example-transitioning-from-the-legacy-functions" role="doc-backlink">Example: Transitioning From the Legacy Functions</a></h4>
<p>The following code uses the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyGILState_STATE</span><span class="w"> </span><span class="n">gstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyGILState_Ensure</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* It&#39;s not an issue in this example, but we just attached</span>
<span class="cm">       a thread state for the main interpreter. If my_method() was</span>
<span class="cm">       originally called in a subinterpreter, then we would be unable</span>
<span class="cm">       to safely interact with any objects from it. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThread_join_thread</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is the same code, rewritten to use the new functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyInterpreterGuard</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromCurrent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="w">    </span><span class="n">PyThread_join_thread</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-a-daemon-thread">
<h4><a class="toc-backref" href="#example-a-daemon-thread" role="doc-backlink">Example: A Daemon Thread</a></h4>
<p>With this PEP, daemon threads are very similar to how non-Python threads work
in the C API today. After calling <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>, simply
close the interpreter guard to allow the interpreter to shut down (and
hang the current thread forever).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyInterpreterGuard</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Close the interpreter guard, allowing it to</span>
<span class="cm">       finalize. This means that print(42) can hang this thread. */</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromCurrent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-an-asynchronous-callback">
<h4><a class="toc-backref" href="#example-an-asynchronous-callback" role="doc-backlink">Example: An Asynchronous Callback</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">async_callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ThreadData</span><span class="w"> </span><span class="o">*</span><span class="n">tdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ThreadData</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tdata</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromView</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Python has shut down!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterView_Close</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyMem_RawFree</span><span class="p">(</span><span class="n">tdata</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">setup_callback</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// View to the interpreter. It won&#39;t wait on the callback</span>
<span class="w">    </span><span class="c1">// to finalize.</span>
<span class="w">    </span><span class="n">ThreadData</span><span class="w"> </span><span class="o">*</span><span class="n">tdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_RawMalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ThreadData</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tdata</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterView_FromCurrent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyMem_RawFree</span><span class="p">(</span><span class="n">tdata</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">tdata</span><span class="o">-&gt;</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="w">    </span><span class="n">register_callback</span><span class="p">(</span><span class="n">async_callback</span><span class="p">,</span><span class="w"> </span><span class="n">tdata</span><span class="p">);</span>

<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-calling-python-without-a-callback-parameter">
<h4><a class="toc-backref" href="#example-calling-python-without-a-callback-parameter" role="doc-backlink">Example: Calling Python Without a Callback Parameter</a></h4>
<p>There are a few cases where callback functions don’t take a callback parameter
(<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code>), so it’s difficult to create a guard for any specific
interpreter. The solution to this problem is to create a guard for the main
interpreter through <a class="reference internal" href="#c.PyUnstable_InterpreterView_FromDefault" title="PyUnstable_InterpreterView_FromDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnstable_InterpreterView_FromDefault()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">call_python</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterView</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyUnstable_InterpreterView_FromDefault</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Python has shut down.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PyInterpreterGuard</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterGuard_FromView</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guard</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Python has shut down.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PyThreadView</span><span class="w"> </span><span class="n">thread_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_view</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">        </span><span class="n">PyInterpreterView_Close</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">(</span><span class="n">thread_view</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterGuard_Close</span><span class="p">(</span><span class="n">guard</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterView_Close</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementation of this PEP can be found
at <a class="reference external" href="https://github.com/python/cpython/pull/133110">python/cpython#133110</a>.</p>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h2>
<section id="how-should-the-apis-fail">
<h3><a class="toc-backref" href="#how-should-the-apis-fail" role="doc-backlink">How Should the APIs Fail?</a></h3>
<p>There is some disagreement over how the <code class="docutils literal notranslate"><span class="pre">PyInterpreter[Guard|View]</span></code> APIs
should indicate a failure to the caller. There are two competing ideas:</p>
<ol class="arabic simple">
<li>Return -1 to indicate failure, and 0 to indicate success. On success,
functions will assign to a <code class="docutils literal notranslate"><span class="pre">PyInterpreter[Guard|View]</span></code> pointer passed as an
argument.</li>
<li>Directly return a <code class="docutils literal notranslate"><span class="pre">PyInterpreter[Guard|View]</span></code>, with a value of 0 being
equivalent to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, indicating failure.</li>
</ol>
<p>Currently, the PEP spells the latter.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="interpreter-reference-counting">
<h3><a class="toc-backref" href="#interpreter-reference-counting" role="doc-backlink">Interpreter Reference Counting</a></h3>
<p>There were two iterations of this proposal that both specified that an
interpreter maintain a reference count and would wait for that count to reach
zero before shutting down.</p>
<p>The first iteration of this idea did this by adding implicit reference counting
to <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></code> pointers. A function known as <code class="docutils literal notranslate"><span class="pre">PyInterpreterState_Hold</span></code>
would increment the reference count (making it a “strong reference”), and
<code class="docutils literal notranslate"><span class="pre">PyInterpreterState_Release</span></code> would decrement it. An interpreter’s ID (a
standalone <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>) was used as a form of weak reference, which could be
used to look up an interpreter state and atomically increment its reference
count. These ideas were ultimately rejected because they seemed to make things
very confusing. All existing uses of <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></code> would be
borrowed, making it difficult for developers to understand which
parts of their code require or use a strong reference.</p>
<p>In response to that pushback, this PEP specified <code class="docutils literal notranslate"><span class="pre">PyInterpreterRef</span></code> APIs
that would also mimic reference counting, but in a more explicit manner that
made it easier for developers. <code class="docutils literal notranslate"><span class="pre">PyInterpreterRef</span></code> was analogous to
<a class="reference internal" href="#c.PyInterpreterGuard" title="PyInterpreterGuard"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterGuard</span></code></a> in this PEP. Similarly, the older revision included
<code class="docutils literal notranslate"><span class="pre">PyInterpreterWeakRef</span></code>, which was analogous to <a class="reference internal" href="#c.PyInterpreterView" title="PyInterpreterView"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterView</span></code></a>.</p>
<p>Eventually, the notion of reference counting was completely abandoned from
this proposal for a few reasons:</p>
<ol class="arabic simple">
<li>There was contention over overcomplication in the API design; the
reference-counting design looked very similar to HPy’s, which had no
precedent in CPython. There was fear that this proposal was being
overcomplicated to look more like HPy.</li>
<li>Unlike traditional reference-counting APIs, acquiring a strong reference to
an interpreter could fail at any time, and an interpreter would not
be deallocated immediately when its reference count reached zero.</li>
<li>There was prior discussion about adding “true” reference counting to
interpreters (which would deallocate upon reaching zero), which would have
been very confusing if there was an existing API in CPython titled
<code class="docutils literal notranslate"><span class="pre">PyInterpreterRef</span></code> that did something different.</li>
</ol>
</section>
<section id="non-daemon-thread-states">
<h3><a class="toc-backref" href="#non-daemon-thread-states" role="doc-backlink">Non-daemon Thread States</a></h3>
<p>In earlier revisions of this PEP, interpreter guards were a property of
a thread state rather than a property of an interpreter. This meant that
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> kept an interpreter guard held, and
it was closed upon calling <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a>. A thread state
that had a guard to an interpreter was known as a “non-daemon thread
state.” At first, this seemed like an improvement because it shifted the
management of a guard’s lifetime to the thread rather than the user, which
eliminated some boilerplate.</p>
<p>However, this ended up making the proposal significantly more complex and
hurt the proposal’s goals:</p>
<ul class="simple">
<li>Most importantly, non-daemon thread states place too much emphasis on daemon
threads as the problem, which made the PEP confusing. Additionally,
the phrase “non-daemon” added extra confusion, because non-daemon Python
threads are explicitly joined. In contrast, a non-daemon C thread is only
waited on until it destroys its guard.</li>
<li>In many cases, an interpreter guard should outlive a singular thread
state. Stealing the interpreter guard in <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>
was particularly troublesome for these cases. If <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>
didn’t steal a guard with non-daemon thread states, it would muddy the
ownership story of the interpreter guard, leading to a more confusing API.</li>
</ul>
</section>
<section id="exposing-an-activate-deactivate-api-instead-of-ensure-clear">
<span id="pep-788-activate-deactivate-instead"></span><h3><a class="toc-backref" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear" role="doc-backlink">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API Instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></h3>
<p>In prior discussions of this API, it was
<a class="reference external" href="https://discuss.python.org/t/83959/2">suggested</a> to provide actual
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState" title="(in Python v3.14)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> pointers in the API in an attempt to
make the ownership and lifetime of the thread state more straightforward:</p>
<blockquote>
<div>More importantly though, I think this makes it clearer who owns the thread
state - a manually created one is controlled by the code that created it,
and once it’s deleted it can’t be activated again.</div></blockquote>
<p>This was ultimately rejected for two reasons:</p>
<ul class="simple">
<li>The proposed API has closer usage to
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> &amp; <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>, which helps
ease the transition for old codebases.</li>
<li>It’s <a class="reference external" href="https://discuss.python.org/t/83959/15">significantly easier</a>
for code-generators like Cython to use, as there isn’t any additional
complexity with tracking <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState" title="(in Python v3.14)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> pointers around.</li>
</ul>
</section>
<section id="using-pystatus-for-the-return-value-of-pythreadstate-ensure">
<h3><a class="toc-backref" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure" role="doc-backlink">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the Return Value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></h3>
<p>In prior iterations of this API, <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> returned a
<a class="reference external" href="https://docs.python.org/3/c-api/init_config.html#c.PyStatus" title="(in Python v3.14)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyStatus</span></code></a> instead of an integer to denote failures, which had the
benefit of providing an error message.</p>
<p>This was rejected because it’s <a class="reference external" href="https://discuss.python.org/t/83959/7">not clear</a>
that an error message would be all that useful; all the conceived use-cases
for this API wouldn’t really care about a message indicating why Python
can’t be invoked. As such, the API would only be needlessly more complex to
use, which in turn would hurt the transition from <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.14)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>.</p>
<p>In addition, <a class="reference external" href="https://docs.python.org/3/c-api/init_config.html#c.PyStatus" title="(in Python v3.14)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyStatus</span></code></a> isn’t commonly used in the C API. A few
functions related to interpreter initialization use it (simply because they
can’t raise exceptions), and <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> does not fall
under that category.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>This PEP is based on prior work, feedback, and discussions from many people,
including Victor Stinner, Antoine Pitrou, David Woods, Sam Gross, Matt Page,
Ronald Oussoren, Matt Wozniski, Eric Snow, Steve Dower, Petr Viktorin,
Gregory P. Smith, and Alyssa Coghlan.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0788.rst">https://github.com/python/peps/blob/main/peps/pep-0788.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0788.rst">2025-10-14 11:22:45 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#non-python-threads-always-hang-during-finalization">Non-Python Threads Always Hang During Finalization</a><ul>
<li><a class="reference internal" href="#py-isfinalizing-is-not-atomic"><code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> Is Not Atomic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locks-in-native-extensions-can-be-unusable-during-finalization">Locks in Native Extensions Can Be Unusable During Finalization</a></li>
<li><a class="reference internal" href="#finalization-behavior-for-pygilstate-ensure-cannot-change">Finalization Behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Cannot Change</a></li>
<li><a class="reference internal" href="#the-term-gil-is-tricky-for-free-threading">The Term “GIL” Is Tricky for Free-threading</a></li>
<li><a class="reference internal" href="#pygilstate-ensure-doesn-t-guess-the-correct-interpreter"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> Doesn’t Guess the Correct Interpreter</a></li>
<li><a class="reference internal" href="#subinterpreters-can-concurrently-deallocate">Subinterpreters Can Concurrently Deallocate</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#preventing-interpreter-shutdown">Preventing Interpreter Shutdown</a></li>
<li><a class="reference internal" href="#compatibility-shim-for-pygilstate-ensure">Compatibility Shim for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#interpreter-guards">Interpreter Guards</a></li>
<li><a class="reference internal" href="#interpreter-views">Interpreter Views</a></li>
<li><a class="reference internal" href="#ensuring-and-releasing-thread-states">Ensuring and Releasing Thread States</a></li>
<li><a class="reference internal" href="#deprecation-of-pygilstate-apis">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a><ul>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#example-a-library-interface">Example: A Library Interface</a></li>
<li><a class="reference internal" href="#example-a-single-threaded-ensure">Example: A Single-threaded Ensure</a></li>
<li><a class="reference internal" href="#example-transitioning-from-the-legacy-functions">Example: Transitioning From the Legacy Functions</a></li>
<li><a class="reference internal" href="#example-a-daemon-thread">Example: A Daemon Thread</a></li>
<li><a class="reference internal" href="#example-an-asynchronous-callback">Example: An Asynchronous Callback</a></li>
<li><a class="reference internal" href="#example-calling-python-without-a-callback-parameter">Example: Calling Python Without a Callback Parameter</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#how-should-the-apis-fail">How Should the APIs Fail?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#interpreter-reference-counting">Interpreter Reference Counting</a></li>
<li><a class="reference internal" href="#non-daemon-thread-states">Non-daemon Thread States</a></li>
<li><a class="reference internal" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API Instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></li>
<li><a class="reference internal" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the Return Value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0788.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>