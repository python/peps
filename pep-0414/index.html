
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 414 – Explicit Unicode Literal for Python 3.3 | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0414/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 414 – Explicit Unicode Literal for Python 3.3 | peps.python.org'>
    <meta property="og:description" content="This document proposes the reintegration of an explicit unicode literal from Python 2.x to the Python 3.x language specification, in order to reduce the volume of changes needed when porting Unicode-aware Python 2 applications to Python 3.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0414/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This document proposes the reintegration of an explicit unicode literal from Python 2.x to the Python 3.x language specification, in order to reduce the volume of changes needed when porting Unicode-aware Python 2 applications to Python 3.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 414</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 414 – Explicit Unicode Literal for Python 3.3</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Armin Ronacher &lt;armin.ronacher&#32;&#97;t&#32;active-4.com&gt;,
Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">15-Feb-2012</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.3</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even">28-Feb-2012, 04-Mar-2012</dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-February/116995.html">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a></li>
<li><a class="reference internal" href="#exclusion-of-raw-unicode-literals">Exclusion of “Raw” Unicode Literals</a></li>
<li><a class="reference internal" href="#author-s-note">Author’s Note</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#common-objections">Common Objections</a><ul>
<li><a class="reference internal" href="#complaint-this-pep-may-harm-adoption-of-python-3-2">Complaint: This PEP may harm adoption of Python 3.2</a></li>
<li><a class="reference internal" href="#complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2">Complaint: Python 3 shouldn’t be made worse just to support porting from Python 2</a></li>
<li><a class="reference internal" href="#complaint-the-wsgi-native-strings-concept-is-an-ugly-hack">Complaint: The WSGI “native strings” concept is an ugly hack</a></li>
<li><a class="reference internal" href="#complaint-the-existing-tools-should-be-good-enough-for-everyone">Complaint: The existing tools should be good enough for everyone</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This document proposes the reintegration of an explicit unicode literal
from Python 2.x to the Python 3.x language specification, in order to
reduce the volume of changes needed when porting Unicode-aware
Python 2 applications to Python 3.</p>
</section>
<section id="bdfl-pronouncement">
<h2><a class="toc-backref" href="#bdfl-pronouncement" role="doc-backlink">BDFL Pronouncement</a></h2>
<p>This PEP has been formally accepted for Python 3.3:</p>
<blockquote>
<div>I’m accepting the PEP. It’s about as harmless as they come. Make it so.</div></blockquote>
</section>
<section id="proposal">
<h2><a class="toc-backref" href="#proposal" role="doc-backlink">Proposal</a></h2>
<p>This PEP proposes that Python 3.3 restore support for Python 2’s Unicode
literal syntax, substantially increasing the number of lines of existing
Python 2 code in Unicode aware applications that will run without modification
on Python 3.</p>
<p>Specifically, the Python 3 definition for string literal prefixes will be
expanded to allow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;u&quot;</span> <span class="o">|</span> <span class="s2">&quot;U&quot;</span>
</pre></div>
</div>
<p>in addition to the currently supported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;r&quot;</span> <span class="o">|</span> <span class="s2">&quot;R&quot;</span>
</pre></div>
</div>
<p>The following will all denote ordinary Python 3 strings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;text&#39;</span>
<span class="s2">&quot;text&quot;</span>
<span class="sd">&#39;&#39;&#39;text&#39;&#39;&#39;</span>
<span class="sd">&quot;&quot;&quot;text&quot;&quot;&quot;</span>
<span class="sa">u</span><span class="s1">&#39;text&#39;</span>
<span class="sa">u</span><span class="s2">&quot;text&quot;</span>
<span class="sa">u</span><span class="sd">&#39;&#39;&#39;text&#39;&#39;&#39;</span>
<span class="sa">u</span><span class="sd">&quot;&quot;&quot;text&quot;&quot;&quot;</span>
<span class="sa">U</span><span class="s1">&#39;text&#39;</span>
<span class="sa">U</span><span class="s2">&quot;text&quot;</span>
<span class="sa">U</span><span class="sd">&#39;&#39;&#39;text&#39;&#39;&#39;</span>
<span class="sa">U</span><span class="sd">&quot;&quot;&quot;text&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>No changes are proposed to Python 3’s actual Unicode handling, only to the
acceptable forms for string literals.</p>
</section>
<section id="exclusion-of-raw-unicode-literals">
<h2><a class="toc-backref" href="#exclusion-of-raw-unicode-literals" role="doc-backlink">Exclusion of “Raw” Unicode Literals</a></h2>
<p>Python 2 supports a concept of “raw” Unicode literals that don’t meet the
conventional definition of a raw string: <code class="docutils literal notranslate"><span class="pre">\uXXXX</span></code> and <code class="docutils literal notranslate"><span class="pre">\UXXXXXXXX</span></code> escape
sequences are still processed by the compiler and converted to the
appropriate Unicode code points when creating the associated Unicode objects.</p>
<p>Python 3 has no corresponding concept - the compiler performs <em>no</em>
preprocessing of the contents of raw string literals. This matches the
behaviour of 8-bit raw string literals in Python 2.</p>
<p>Since such strings are rarely used and would be interpreted differently in
Python 3 if permitted, it was decided that leaving them out entirely was
a better choice. Code which uses them will thus still fail immediately on
Python 3 (with a Syntax Error), rather than potentially producing different
output.</p>
<p>To get equivalent behaviour that will run on both Python 2 and Python 3,
either an ordinary Unicode literal can be used (with appropriate additional
escaping within the string), or else string concatenation or string
formatting can be combine the raw portions of the string with those that
require the use of Unicode escape sequences.</p>
<p>Note that when using <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">unicode_literals</span></code> in Python 2,
the nominally “raw” Unicode string literals will process <code class="docutils literal notranslate"><span class="pre">\uXXXX</span></code> and
<code class="docutils literal notranslate"><span class="pre">\UXXXXXXXX</span></code> escape sequences, just like Python 2 strings explicitly marked
with the “raw Unicode” prefix.</p>
</section>
<section id="author-s-note">
<h2><a class="toc-backref" href="#author-s-note" role="doc-backlink">Author’s Note</a></h2>
<p>This PEP was originally written by Armin Ronacher, and Guido’s approval was
given based on that version.</p>
<p>The currently published version has been rewritten by Alyssa Coghlan to
include additional historical details and rationale that were taken into
account when Guido made his decision, but were not explicitly documented in
Armin’s version of the PEP.</p>
<p>Readers should be aware that many of the arguments in this PEP are <em>not</em>
technical ones. Instead, they relate heavily to the <em>social</em> and <em>personal</em>
aspects of software development.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>With the release of a Python 3 compatible version of the Web Services Gateway
Interface (WSGI) specification (<a class="pep reference internal" href="../pep-3333/" title="PEP 3333 – Python Web Server Gateway Interface v1.0.1">PEP 3333</a>) for Python 3.2, many parts of the
Python web ecosystem have been making a concerted effort to support Python 3
without adversely affecting their existing developer and user communities.</p>
<p>One major item of feedback from key developers in those communities, including
Chris McDonough (WebOb, Pyramid), Armin Ronacher (Flask, Werkzeug), Jacob
Kaplan-Moss (Django) and Kenneth Reitz (<code class="docutils literal notranslate"><span class="pre">requests</span></code>) is that the requirement
to change the spelling of <em>every</em> Unicode literal in an application
(regardless of how that is accomplished) is a key stumbling block for porting
efforts.</p>
<p>In particular, unlike many of the other Python 3 changes, it isn’t one that
framework and library authors can easily handle on behalf of their users. Most
of those users couldn’t care less about the “purity” of the Python language
specification, they just want their websites and applications to work as well
as possible.</p>
<p>While it is the Python web community that has been most vocal in highlighting
this concern, it is expected that other highly Unicode aware domains (such as
GUI development) may run into similar issues as they (and their communities)
start making concerted efforts to support Python 3.</p>
</section>
<section id="common-objections">
<h2><a class="toc-backref" href="#common-objections" role="doc-backlink">Common Objections</a></h2>
<section id="complaint-this-pep-may-harm-adoption-of-python-3-2">
<h3><a class="toc-backref" href="#complaint-this-pep-may-harm-adoption-of-python-3-2" role="doc-backlink">Complaint: This PEP may harm adoption of Python 3.2</a></h3>
<p>This complaint is interesting, as it carries within it a tacit admission that
this PEP <em>will</em> make it easier to port Unicode aware Python 2 applications to
Python 3.</p>
<p>There are many existing Python communities that are prepared to put up with
the constraints imposed by the existing suite of porting tools, or to update
their Python 2 code bases sufficiently that the problems are minimised.</p>
<p>This PEP is not for those communities. Instead, it is designed specifically to
help people that <em>don’t</em> want to put up with those difficulties.</p>
<p>However, since the proposal is for a comparatively small tweak to the language
syntax with no semantic changes, it is feasible to support it as a third
party import hook. While such an import hook imposes some import time
overhead, and requires additional steps from each application that needs it
to get the hook in place, it allows applications that target Python 3.2
to use libraries and frameworks that would otherwise only run on Python 3.3+
due to their use of unicode literal prefixes.</p>
<p>One such import hook project is Vinay Sajip’s <code class="docutils literal notranslate"><span class="pre">uprefix</span></code> <a class="footnote-reference brackets" href="#id9" id="id1">[4]</a>.</p>
<p>For those that prefer to translate their code in advance rather than
converting on the fly at import time, Armin Ronacher is working on a hook
that runs at install time rather than during import <a class="footnote-reference brackets" href="#id10" id="id2">[5]</a>.</p>
<p>Combining the two approaches is of course also possible. For example, the
import hook could be used for rapid edit-test cycles during local
development, but the install hook for continuous integration tasks and
deployment on Python 3.2.</p>
<p>The approaches described in this section may prove useful, for example, for
applications that wish to target Python 3 on the Ubuntu 12.04 LTS release,
which will ship with Python 2.7 and 3.2 as officially supported Python
versions.</p>
</section>
<section id="complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2">
<h3><a class="toc-backref" href="#complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2" role="doc-backlink">Complaint: Python 3 shouldn’t be made worse just to support porting from Python 2</a></h3>
<p>This is indeed one of the key design principles of Python 3. However, one of
the key design principles of Python as a whole is that “practicality beats
purity”. If we’re going to impose a significant burden on third party
developers, we should have a solid rationale for doing so.</p>
<p>In most cases, the rationale for backwards incompatible Python 3 changes are
either to improve code correctness (for example, stricter default separation
of binary and text data and integer division upgrading to floats when
necessary), reduce typical memory usage (for example, increased usage of
iterators and views over concrete lists), or to remove distracting nuisances
that make Python code harder to read without increasing its expressiveness
(for example, the comma based syntax for naming caught exceptions). Changes
backed by such reasoning are <em>not</em> going to be reverted, regardless of
objections from Python 2 developers attempting to make the transition to
Python 3.</p>
<p>In many cases, Python 2 offered two ways of doing things for historical reasons.
For example, inequality could be tested with both <code class="docutils literal notranslate"><span class="pre">!=</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> and integer
literals could be specified with an optional <code class="docutils literal notranslate"><span class="pre">L</span></code> suffix. Such redundancies
have been eliminated in Python 3, which reduces the overall size of the
language and improves consistency across developers.</p>
<p>In the original Python 3 design (up to and including Python 3.2), the explicit
prefix syntax for unicode literals was deemed to fall into this category, as it
is completely unnecessary in Python 3. However, the difference between those
other cases and unicode literals is that the unicode literal prefix is <em>not</em>
redundant in Python 2 code: it is a programmatically significant distinction
that needs to be preserved in some fashion to avoid losing information.</p>
<p>While porting tools were created to help with the transition (see next section)
it still creates an additional burden on heavy users of unicode strings in
Python 2, solely so that future developers learning Python 3 don’t need to be
told “For historical reasons, string literals may have an optional <code class="docutils literal notranslate"><span class="pre">u</span></code> or
<code class="docutils literal notranslate"><span class="pre">U</span></code> prefix. Never use this yourselves, it’s just there to help with porting
from an earlier version of the language.”</p>
<p>Plenty of students learning Python 2 received similar warnings regarding string
exceptions without being confused or irreparably stunted in their growth as
Python developers. It will be the same with this feature.</p>
<p>This point is further reinforced by the fact that Python 3 <em>still</em> allows the
uppercase variants of the <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> prefixes for bytes literals and raw
bytes and string literals. If the potential for confusion due to string prefix
variants is that significant, where was the outcry asking that these
redundant prefixes be removed along with all the other redundancies that were
eliminated in Python 3?</p>
<p>Just as support for string exceptions was eliminated from Python 2 using the
normal deprecation process, support for redundant string prefix characters
(specifically, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code>, <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">U</span></code>) may eventually be eliminated
from Python 3, regardless of the current acceptance of this PEP. However,
such a change will likely only occur once third party libraries supporting
Python 2.7 is about as common as libraries supporting Python 2.2 or 2.3 is
today.</p>
</section>
<section id="complaint-the-wsgi-native-strings-concept-is-an-ugly-hack">
<h3><a class="toc-backref" href="#complaint-the-wsgi-native-strings-concept-is-an-ugly-hack" role="doc-backlink">Complaint: The WSGI “native strings” concept is an ugly hack</a></h3>
<p>One reason the removal of unicode literals has provoked such concern amongst
the web development community is that the updated WSGI specification had to
make a few compromises to minimise the disruption for existing web servers
that provide a WSGI-compatible interface (this was deemed necessary in order
to make the updated standard a viable target for web application authors and
web framework developers).</p>
<p>One of those compromises is the concept of a “native string”. WSGI defines
three different kinds of string:</p>
<ul class="simple">
<li>text strings: handled as <code class="docutils literal notranslate"><span class="pre">unicode</span></code> in Python 2 and <code class="docutils literal notranslate"><span class="pre">str</span></code> in Python 3</li>
<li>native strings: handled as <code class="docutils literal notranslate"><span class="pre">str</span></code> in both Python 2 and Python 3</li>
<li>binary data: handled as <code class="docutils literal notranslate"><span class="pre">str</span></code> in Python 2 and <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 3</li>
</ul>
<p>Some developers consider WSGI’s “native strings” to be an ugly hack, as they
are <em>explicitly</em> documented as being used solely for <code class="docutils literal notranslate"><span class="pre">latin-1</span></code> decoded
“text”, regardless of the actual encoding of the underlying data. Using this
approach bypasses many of the updates to Python 3’s data model that are
designed to encourage correct handling of text encodings. However, it
generally works due to the specific details of the problem domain - web server
and web framework developers are some of the individuals <em>most</em> aware of how
blurry the line can get between binary data and text when working with HTTP
and related protocols, and how important it is to understand the implications
of the encodings in use when manipulating encoded text data. At the
<em>application</em> level most of these details are hidden from the developer by
the web frameworks and support libraries (both in Python 2 <em>and</em> in Python 3).</p>
<p>In practice, native strings are a useful concept because there are some APIs
(both in the standard library and in third party frameworks and packages) and
some internal interpreter details that are designed primarily to work with
<code class="docutils literal notranslate"><span class="pre">str</span></code>. These components often don’t support <code class="docutils literal notranslate"><span class="pre">unicode</span></code> in Python 2
or <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 3, or, if they do, require additional encoding details
and/or impose constraints that don’t apply to the <code class="docutils literal notranslate"><span class="pre">str</span></code> variants.</p>
<p>Some example of interfaces that are best handled by using actual <code class="docutils literal notranslate"><span class="pre">str</span></code>
instances are:</p>
<ul class="simple">
<li>Python identifiers (as attributes, dict keys, class names, module names,
import references, etc)</li>
<li>URLs for the most part as well as HTTP headers in urllib/http servers</li>
<li>WSGI environment keys and CGI-inherited values</li>
<li>Python source code for dynamic compilation and AST hacks</li>
<li>Exception messages</li>
<li><code class="docutils literal notranslate"><span class="pre">__repr__</span></code> return value</li>
<li>preferred filesystem paths</li>
<li>preferred OS environment</li>
</ul>
<p>In Python 2.6 and 2.7, these distinctions are most naturally expressed as
follows:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">u&quot;&quot;</span></code>: text string (<code class="docutils literal notranslate"><span class="pre">unicode</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>: native string (<code class="docutils literal notranslate"><span class="pre">str</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>: binary data (<code class="docutils literal notranslate"><span class="pre">str</span></code>, also aliased as <code class="docutils literal notranslate"><span class="pre">bytes</span></code>)</li>
</ul>
<p>In Python 3, the <code class="docutils literal notranslate"><span class="pre">latin-1</span></code> decoded native strings are not distinguished
from any other text strings:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>: text string (<code class="docutils literal notranslate"><span class="pre">str</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>: native string (<code class="docutils literal notranslate"><span class="pre">str</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>: binary data (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>)</li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">unicode_literals</span></code> is used to modify the behaviour
of Python 2, then, along with an appropriate definition of <code class="docutils literal notranslate"><span class="pre">n()</span></code>, the
distinction can be expressed as:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>: text string</li>
<li><code class="docutils literal notranslate"><span class="pre">n(&quot;&quot;)</span></code>: native string</li>
<li><code class="docutils literal notranslate"><span class="pre">b&quot;&quot;</span></code>: binary data</li>
</ul>
<p>(While <code class="docutils literal notranslate"><span class="pre">n=str</span></code> works for simple cases, it can sometimes have problems
due to non-ASCII source encodings)</p>
<p>In the common subset of Python 2 and Python 3 (with appropriate
specification of a source encoding and definitions of the <code class="docutils literal notranslate"><span class="pre">u()</span></code> and <code class="docutils literal notranslate"><span class="pre">b()</span></code>
helper functions), they can be expressed as:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">u(&quot;&quot;)</span></code>: text string</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>: native string</li>
<li><code class="docutils literal notranslate"><span class="pre">b(&quot;&quot;)</span></code>: binary data</li>
</ul>
<p>That last approach is the only variant that supports Python 2.5 and earlier.</p>
<p>Of all the alternatives, the format currently supported in Python 2.6 and 2.7
is by far the cleanest approach that clearly distinguishes the three desired
kinds of behaviour. With this PEP, that format will also be supported in
Python 3.3+. It will also be supported in Python 3.1 and 3.2 through the use
of import and install hooks. While it is significantly less likely, it is
also conceivable that the hooks could be adapted to allow the use of the
<code class="docutils literal notranslate"><span class="pre">b</span></code> prefix on Python 2.5.</p>
</section>
<section id="complaint-the-existing-tools-should-be-good-enough-for-everyone">
<h3><a class="toc-backref" href="#complaint-the-existing-tools-should-be-good-enough-for-everyone" role="doc-backlink">Complaint: The existing tools should be good enough for everyone</a></h3>
<p>A commonly expressed sentiment from developers that have already successfully
ported applications to Python 3 is along the lines of “if you think it’s hard,
you’re doing it wrong” or “it’s not that hard, just try it!”. While it is no
doubt unintentional, these responses all have the effect of telling the
people that are pointing out inadequacies in the current porting toolset
“there’s nothing wrong with the porting tools, you just suck and don’t know
how to use them properly”.</p>
<p>These responses are a case of completely missing the point of what people are
complaining about. The feedback that resulted in this PEP isn’t due to people
complaining that ports aren’t possible. Instead, the feedback is coming from
people that have successfully <em>completed</em> ports and are objecting that they
found the experience thoroughly <em>unpleasant</em> for the class of application that
they needed to port (specifically, Unicode aware web frameworks and support
libraries).</p>
<p>This is a subjective appraisal, and it’s the reason why the Python 3
porting tools ecosystem is a case where the “one obvious way to do it”
philosophy emphatically does <em>not</em> apply. While it was originally intended that
“develop in Python 2, convert with <code class="docutils literal notranslate"><span class="pre">2to3</span></code>, test both” would be the standard
way to develop for both versions in parallel, in practice, the needs of
different projects and developer communities have proven to be sufficiently
diverse that a variety of approaches have been devised, allowing each group
to select an approach that best fits their needs.</p>
<p>Lennart Regebro has produced an excellent overview of the available migration
strategies <a class="footnote-reference brackets" href="#id7" id="id3">[2]</a>, and a similar review is provided in the official porting
guide <a class="footnote-reference brackets" href="#id8" id="id4">[3]</a>. (Note that the official guidance has softened to “it depends on
your specific situation” since Lennart wrote his overview).</p>
<p>However, both of those guides are written from the founding assumption that
all of the developers involved are <em>already</em> committed to the idea of
supporting Python 3. They make no allowance for the <em>social</em> aspects of such a
change when you’re interacting with a user base that may not be especially
tolerant of disruptions without a clear benefit, or are trying to persuade
Python 2 focused upstream developers to accept patches that are solely about
improving Python 3 forward compatibility.</p>
<p>With the current porting toolset, <em>every</em> migration strategy will result in
changes to <em>every</em> Unicode literal in a project. No exceptions. They will
be converted to either an unprefixed string literal (if the project decides to
adopt the <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code> import) or else to a converter call like
<code class="docutils literal notranslate"><span class="pre">u(&quot;text&quot;)</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code> import approach is employed, but is not adopted
across the entire project at the same time, then the meaning of a bare string
literal may become annoyingly ambiguous. This problem can be particularly
pernicious for <em>aggregated</em> software, like a Django site - in such a situation,
some files may end up using the <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code> import and others may not,
creating definite potential for confusion.</p>
<p>While these problems are clearly solvable at a technical level, they’re a
completely unnecessary distraction at the social level. Developer energy should
be reserved for addressing <em>real</em> technical difficulties associated with the
Python 3 transition (like distinguishing their 8-bit text strings from their
binary data). They shouldn’t be punished with additional code changes (even
automated ones) solely due to the fact that they have <em>already</em> explicitly
identified their Unicode strings in Python 2.</p>
<p>Armin Ronacher has created an experimental extension to 2to3 which only
modernizes Python code to the extent that it runs on Python 2.7 or later with
support from the cross-version compatibility <code class="docutils literal notranslate"><span class="pre">six</span></code> library. This tool is
available as <code class="docutils literal notranslate"><span class="pre">python-modernize</span></code> <a class="footnote-reference brackets" href="#id6" id="id5">[1]</a>. Currently, the deltas generated by
this tool will affect every Unicode literal in the converted source. This
will create legitimate concerns amongst upstream developers asked to accept
such changes, and amongst framework <em>users</em> being asked to change their
applications.</p>
<p>However, by eliminating the noise from changes to the Unicode literal syntax,
many projects could be cleanly and (comparatively) non-controversially made
forward compatible with Python 3.3+ just by running <code class="docutils literal notranslate"><span class="pre">python-modernize</span></code> and
applying the recommended changes.</p>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<dt class="label" id="id6">[<a href="#id5">1</a>]</dt>
<dd>Python-Modernize
(<a class="reference external" href="http://github.com/mitsuhiko/python-modernize">http://github.com/mitsuhiko/python-modernize</a>)</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<dt class="label" id="id7">[<a href="#id3">2</a>]</dt>
<dd>Porting to Python 3: Migration Strategies
(<a class="reference external" href="http://python3porting.com/strategies.html">http://python3porting.com/strategies.html</a>)</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<dt class="label" id="id8">[<a href="#id4">3</a>]</dt>
<dd>Porting Python 2 Code to Python 3
(<a class="reference external" href="http://docs.python.org/howto/pyporting.html">http://docs.python.org/howto/pyporting.html</a>)</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<dt class="label" id="id9">[<a href="#id1">4</a>]</dt>
<dd>uprefix import hook project
(<a class="reference external" href="https://bitbucket.org/vinay.sajip/uprefix">https://bitbucket.org/vinay.sajip/uprefix</a>)</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<dt class="label" id="id10">[<a href="#id2">5</a>]</dt>
<dd>install hook to remove unicode string prefix characters
(<a class="reference external" href="https://github.com/mitsuhiko/unicode-literals-pep/tree/master/install-hook">https://github.com/mitsuhiko/unicode-literals-pep/tree/master/install-hook</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0414.rst">https://github.com/python/peps/blob/main/peps/pep-0414.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0414.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a></li>
<li><a class="reference internal" href="#exclusion-of-raw-unicode-literals">Exclusion of “Raw” Unicode Literals</a></li>
<li><a class="reference internal" href="#author-s-note">Author’s Note</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#common-objections">Common Objections</a><ul>
<li><a class="reference internal" href="#complaint-this-pep-may-harm-adoption-of-python-3-2">Complaint: This PEP may harm adoption of Python 3.2</a></li>
<li><a class="reference internal" href="#complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2">Complaint: Python 3 shouldn’t be made worse just to support porting from Python 2</a></li>
<li><a class="reference internal" href="#complaint-the-wsgi-native-strings-concept-is-an-ugly-hack">Complaint: The WSGI “native strings” concept is an ugly hack</a></li>
<li><a class="reference internal" href="#complaint-the-existing-tools-should-be-good-enough-for-everyone">Complaint: The existing tools should be good enough for everyone</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0414.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>