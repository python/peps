
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 817 – Wheel Variants: Beyond Platform Tags | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0817/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 817 – Wheel Variants: Beyond Platform Tags | peps.python.org'>
    <meta property="og:description" content="Python’s existing wheel packaging format uses packaging:specifications/platform-compatibility-tags to specify a given wheel’s supported environments. These tags are unable to express modern hardware configurations and their features, such as the availab...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0817/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="Python’s existing wheel packaging format uses packaging:specifications/platform-compatibility-tags to specify a given wheel’s supported environments. These tags are unable to express modern hardware configurations and their features, such as the availab...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 817</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 817 – Wheel Variants: Beyond Platform Tags" data-pagefind-weight="10" class="visually-hidden">PEP 817 – Wheel Variants: Beyond Platform Tags</span>
            <section id="pep-content">
<h1 class="page-title">PEP 817 – Wheel Variants: Beyond Platform Tags</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Jonathan Dekhtiar &lt;jonathan&#32;&#97;t&#32;dekhtiar.com&gt;,
Michał Górny &lt;mgorny&#32;&#97;t&#32;quansight.com&gt;,
Konstantin Schütze &lt;konstin&#32;&#97;t&#32;mailbox.org&gt;,
Ralf Gommers &lt;ralf.gommers&#32;&#97;t&#32;gmail.com&gt;,
Andrey Talman &lt;atalman&#32;&#97;t&#32;meta.com&gt;,
Charlie Marsh &lt;charlie&#32;&#97;t&#32;astral.sh&gt;,
Michael Sarahan &lt;msarahan&#32;&#97;t&#32;gmail.com&gt;,
Eli Uriegas &lt;eliuriegas&#32;&#97;t&#32;meta.com&gt;,
Barry Warsaw &lt;barry&#32;&#97;t&#32;python.org&gt;,
Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;,
Andy R. Terrel &lt;andy.terrel&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/pep-817-wheel-variants-beyond-platform-tags/105860">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Topic<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">10-Dec-2025</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-817-wheel-variants-beyond-platform-tags/105860" title="Discourse thread">24-Jan-2026</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#the-limitations-of-platform-compatibility-tags">The limitations of platform compatibility tags</a></li>
<li><a class="reference internal" href="#current-workarounds-and-their-drawbacks">Current workarounds and their drawbacks</a><ul>
<li><a class="reference internal" href="#runtime-cpu-dispatching">Runtime CPU dispatching</a></li>
<li><a class="reference internal" href="#separate-package-indexes-as-variants">Separate package indexes as variants</a></li>
<li><a class="reference internal" href="#package-names-as-variants">Package names as variants</a></li>
<li><a class="reference internal" href="#package-extras-as-variants">Package extras as variants</a></li>
<li><a class="reference internal" href="#bundled-universal-packages-monolithic-builds">Bundled universal packages - monolithic builds</a></li>
<li><a class="reference internal" href="#wheel-variant-selection-via-source-distribution">Wheel variant selection via source distribution</a></li>
<li><a class="reference internal" href="#ecosystem-fragmentation">Ecosystem fragmentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact-on-scientific-computing-and-ai-ml-workflows">Impact on scientific computing and AI/ML workflows</a><ul>
<li><a class="reference internal" href="#heterogeneous-computing-environments">Heterogeneous computing environments</a></li>
<li><a class="reference internal" href="#artificial-intelligence-machine-learning-and-deep-learning">Artificial intelligence, machine learning, and deep learning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#out-of-scope-features">Out-of-scope features</a></li>
<li><a class="reference internal" href="#prior-art">Prior art</a><ul>
<li><a class="reference internal" href="#conda-conda-forge">Conda - conda-forge</a></li>
<li><a class="reference internal" href="#spack-archspec">Spack / Archspec</a></li>
<li><a class="reference internal" href="#gentoo-linux">Gentoo Linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#wheel-variant-glossary">Wheel variant glossary</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#modified-wheel-filename">Modified wheel filename</a></li>
<li><a class="reference internal" href="#variant-property-system">Variant property system</a></li>
<li><a class="reference internal" href="#null-variant">Null variant</a></li>
<li><a class="reference internal" href="#install-time-and-ahead-of-time-providers">Install-time and Ahead-of-Time providers</a></li>
<li><a class="reference internal" href="#plugin-stability-and-versioning">Plugin stability and versioning</a></li>
<li><a class="reference internal" href="#metadata-in-source-tree-and-wheels">Metadata in source tree and wheels</a></li>
<li><a class="reference internal" href="#abi-dependency-variant-provider">ABI dependency variant provider</a></li>
<li><a class="reference internal" href="#example-use-cases">Example use cases</a><ul>
<li><a class="reference internal" href="#pytorch-cpu-gpu-variants">PyTorch CPU/GPU variants</a></li>
<li><a class="reference internal" href="#optimized-cpu-variants">Optimized CPU variants</a></li>
<li><a class="reference internal" href="#blas-lapack-variants">BLAS / LAPACK variants</a></li>
<li><a class="reference internal" href="#debug-package-variants">Debug package variants</a></li>
<li><a class="reference internal" href="#package-abi-matching">Package ABI matching</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security implications</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#definitions">Definitions</a></li>
<li><a class="reference internal" href="#extended-wheel-filename">Extended wheel filename</a></li>
<li><a class="reference internal" href="#variant-properties">Variant properties</a></li>
<li><a class="reference internal" href="#providers">Providers</a></li>
<li><a class="reference internal" href="#variant-metadata">Variant metadata</a><ul>
<li><a class="reference internal" href="#provider-information">Provider information</a></li>
<li><a class="reference internal" href="#default-priorities">Default priorities</a></li>
<li><a class="reference internal" href="#static-properties">Static properties</a></li>
<li><a class="reference internal" href="#variants">Variants</a></li>
<li><a class="reference internal" href="#pyproject-toml-variant-project-level-data-table"><code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>: variant project-level data table</a></li>
<li><a class="reference internal" href="#dist-info-variant-json-the-packaged-variant-metadata-file"><code class="docutils literal notranslate"><span class="pre">*.dist-info/variant.json</span></code>: the packaged variant metadata file</a></li>
<li><a class="reference internal" href="#name-version-variants-json-the-index-level-variant-metadata-file"><code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code>: the index level variant metadata file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-ordering">Variant ordering</a></li>
<li><a class="reference internal" href="#integration-with-pylock-toml">Integration with <code class="docutils literal notranslate"><span class="pre">pylock.toml</span></code></a></li>
<li><a class="reference internal" href="#provider-plugin-api">Provider plugin API</a><ul>
<li><a class="reference internal" href="#high-level-design">High level design</a></li>
<li><a class="reference internal" href="#api-endpoint">API endpoint</a></li>
<li><a class="reference internal" href="#variant-feature-config-class">Variant feature config class</a></li>
<li><a class="reference internal" href="#plugin-interface">Plugin interface</a></li>
<li><a class="reference internal" href="#example-implementation">Example implementation</a></li>
<li><a class="reference internal" href="#future-extensions">Future extensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-backends">Build backends</a></li>
<li><a class="reference internal" href="#variant-environment-markers">Variant environment markers</a></li>
<li><a class="reference internal" href="#abi-dependency-variant-namespace-optional">ABI Dependency Variant Namespace (Optional)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to teach this</a><ul>
<li><a class="reference internal" href="#python-package-users">Python package users</a></li>
<li><a class="reference internal" href="#python-package-maintainers">Python package maintainers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected ideas</a><ul>
<li><a class="reference internal" href="#an-approach-without-provider-plugins">An approach without provider plugins</a></li>
<li><a class="reference internal" href="#resolving-variants-to-separate-packages">Resolving variants to separate packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendices">Appendices</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>Python’s existing wheel packaging format uses
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/" title="(in Python Packaging User Guide)"><span>Platform compatibility tags</span></a> to specify
a given wheel’s supported environments. These tags are unable to express
modern hardware configurations and their features, such as the availability of
GPU acceleration. The tags fail to provide custom package variants, such as builds
against different dependency ABIs. These inabilities are particularly challenging for
scientific computing, artificial intelligence (AI), machine learning
(ML), and high-performance computing (HPC) communities.</p>
<p>This PEP proposes “Wheel Variants”, an extension to the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/" title="(in Python Packaging User Guide)"><span>Binary distribution format</span></a>. This
extension introduces a mechanism for package maintainers to declare
multiple build variants for the same package version, while allowing
installers to automatically select the most appropriate variant based on
system hardware and software characteristics. More specifically, it
proposes:</p>
<ul class="simple">
<li>An evolution of the wheel format called <strong>Wheel Variant</strong> that allows
wheels to be distinguished by hardware or software attributes.</li>
<li>A <strong>variant provider plugin</strong> interface that allows installers to
dynamically detect platform attributes and select the most suitable
wheel.</li>
</ul>
<p>The goal is for the obvious installation commands (<code class="docutils literal notranslate"><span class="pre">{tool}</span> <span class="pre">install</span> <span class="pre">&lt;package&gt;</span></code>)
to select the most appropriate wheel, and provide the best user experience.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The <a class="reference external" href="https://lp.jetbrains.com/python-developers-survey-2024/#purposes-for-using-python">2024 Python Developers Survey</a> shows that a significant
proportion of Python’s users have scientific computing use-cases. This
includes data analysis (40% of respondents), machine learning (30%), and
data engineering (30%). Many of the software packages developed for
these areas rely on diverse hardware features that cannot be adequately
expressed in the current wheel format, as highlighted in <a class="reference internal" href="#the-limitations-of-platform-compatibility-tags">the
limitations of platform compatibility tags</a>.</p>
<p>For example, packages such as <a class="reference external" href="https://pytorch.org/">PyTorch</a> need to
be built for specific CUDA or ROCm versions, and that information cannot
currently be included in the wheel tag. Having to build multiple wheels
targeting very different hardware configurations forces maintainers into
various distribution strategies that are suboptimal, and create friction
for users and authors of other software who wish to depend on the
package in question.</p>
<p>A few existing approaches are explored in <a class="reference internal" href="#current-workarounds-and-their-drawbacks">Current workarounds and their
drawbacks</a>. They include maintaining separate package indexes for
different hardware configurations, bundling all potential variants into
a single wheel of considerable size, or using separate package names
(<code class="docutils literal notranslate"><span class="pre">mypackage-gpu</span></code>, <code class="docutils literal notranslate"><span class="pre">mypackage-cpu</span></code>, etc.). Each of these approaches
has significant drawbacks and potential security implications.</p>
<section id="the-limitations-of-platform-compatibility-tags">
<h3><a class="toc-backref" href="#the-limitations-of-platform-compatibility-tags" role="doc-backlink">The limitations of platform compatibility tags</a></h3>
<p>The current wheel format encodes compatibility through three platform
tags:</p>
<ol class="arabic simple">
<li><strong>Python tag</strong>: encoding the minimum Python version and optionally
restricting Python distributions (e.g., <code class="docutils literal notranslate"><span class="pre">py3</span></code> for any Python 3,
<code class="docutils literal notranslate"><span class="pre">py313</span></code> for Python 3.13 or newer, <code class="docutils literal notranslate"><span class="pre">cp313</span></code> for specifically
CPython, 3.13 or newer).</li>
<li><strong>ABI tag</strong>: encoding the Python ABI required by any extension
modules (e.g., <code class="docutils literal notranslate"><span class="pre">none</span></code> for no requirement, <code class="docutils literal notranslate"><span class="pre">abi3</span></code> for the CPython
stable ABI, <code class="docutils literal notranslate"><span class="pre">cp313</span></code> for extensions requiring CPython 3.13 ABI).</li>
<li><strong>Platform tag</strong>: currently encoding the operating system,
architecture and core system libraries (e.g., <code class="docutils literal notranslate"><span class="pre">any</span></code> for any
platform, <code class="docutils literal notranslate"><span class="pre">manylinux_2_34_x86_64</span></code> for x86-64 Linux system with
glibc 2.34 or newer, <code class="docutils literal notranslate"><span class="pre">macosx_14_0_arm64</span></code> for arm64 macOS 14.0
or newer system.</li>
</ol>
<p>These tags are limited to expressing the most fundamental properties
of the Python interpreter, operating system and the broad CPU
architectures. They cannot express anything more detailed, including
non-CPU hardware requirements or library ABI constraints.</p>
<p>This lack of flexibility has led many projects to find sub-optimal - yet
necessary - workarounds, such as the manual installation command
selector provided by the PyTorch team. This complexity represents a
fundamental scalability issue with the current tag system that is not
extensible enough to handle the combinatorial complexity of build
options.</p>
</section>
<section id="current-workarounds-and-their-drawbacks">
<h3><a class="toc-backref" href="#current-workarounds-and-their-drawbacks" role="doc-backlink">Current workarounds and their drawbacks</a></h3>
<section id="runtime-cpu-dispatching">
<h4><a class="toc-backref" href="#runtime-cpu-dispatching" role="doc-backlink">Runtime CPU dispatching</a></h4>
<p>Projects such as <a class="reference external" href="https://numpy.org/">NumPy</a> currently resort to building wheels for a
baseline CPU target, and using runtime dispatching for
performance-critical routines. Such a solution requires additional
effort from package maintainers, and usually doesn’t let the code
benefit from compiler optimizations outside the few select functions.</p>
<p>For comparison, building <a class="reference external" href="https://www.gromacs.org/">GROMACS</a> for
higher CPU baselines proved to provide significant speedups:</p>
<blockquote>
<div><figure class="align-default" id="id2">
<img alt="A bar graph comparing GROMACS performance (in ns/day) with various targets. The first two bars are labeled &quot;yum (2018.8)&quot; and &quot;generic (SSE2)&quot;, reach about 1.0 ns/day and are both marked as &quot;SSE2&quot;. The next bar is labeled &quot;ivybridge&quot; (&quot;AVX&quot;) and reaches almost 1.5 ns/day. Two following bars are labeled &quot;haswell&quot; and &quot;broadwell&quot; (both &quot;AVX2&quot;) and exceed 1.5 ns/day slightly. The last two bars are labeled &quot;skylake_avx512&quot; and &quot;cascadelake&quot; (both &quot;AVX512&quot;) and reach almost 2.0 ns/day." src="../_images/avx512_gromacs_benchmark.svg" />
<figcaption>
<p><span class="caption-text">Performance of GROMACS 2020.1 built for different generations of
CPUs. Vertical axis shows performance expressed in ns/day, a
GROMACS-specific measure of simulation speed (higher is better).</span></p>
</figcaption>
</figure>
<p>Compiling <a class="reference external" href="https://www.gromacs.org/">GROMACS</a> for architectures that can exploit the AVX-512
instructions supported by the Intel Cascade Lake microarchitecture
gives an additional 18% performance improvement relative to using
AVX2 instructions, with a speedup of about 70% compared to a generic
GROMACS installation with only SSE2.</p>
<p class="attribution">—<a class="reference external" href="https://tgamblin.github.io/pubs/archspec-canopie-hpc-2020.pdf">archspec: A library for detecting, labeling, and reasoning about
microarchitectures</a></p>
</div></blockquote>
</section>
<section id="separate-package-indexes-as-variants">
<h4><a class="toc-backref" href="#separate-package-indexes-as-variants" role="doc-backlink">Separate package indexes as variants</a></h4>
<p>Projects such as <a class="reference external" href="https://pytorch.org/get-started/locally/">PyTorch</a>
and <a class="reference external" href="https://docs.rapids.ai/install/#selector">RAPIDS</a>
currently distribute packages that approximate “variants” through
separate package indexes with custom URLs. We will use the
example of PyTorch, while the problem, the workarounds, and the impact
on users also apply to other packages.</p>
<figure class="align-default" id="id3">
<img alt="A grid-based selector for PyTorch versions. Individual rows provide the choice of PyTorch Build (stable or nightly), operating system (Linux, Mac, Windows), package (Pip, LibTorch, Source), language (Python, C++ / Java), and Compute Platform (CUDA 12.6, CUDA 12.8, CUDA 13.0, ROCM 6.4, CPU). Below these rows, the pip install command for the selected variant is provided, utilizing the --index-url parameter." src="../_images/pytorch_variant_selector.png" />
<figcaption>
<p><span class="caption-text">The PyTorch install selector
(<a class="reference external" href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a>, captured 22-Aug-2025)</span></p>
</figcaption>
</figure>
<p>PyTorch uses a combination of index URLs per accelerator type and local
version segments as accelerator tag (such as <code class="docutils literal notranslate"><span class="pre">+cu130</span></code>, <code class="docutils literal notranslate"><span class="pre">+rocm6.4</span></code> or
<code class="docutils literal notranslate"><span class="pre">+cpu</span></code>) . Users need to first determine the correct index URL for
their system, and add an index specifically for PyTorch.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>torch<span class="w"> </span>--index-url<span class="w"> </span>https://download.pytorch.org/whl/cu129
</pre></div>
</div>
<p>Tools need to implement special handling for the way PyTorch uses local
version segments. These requirements break the pattern that packages
are usually installed with. Problems with installing PyTorch
are a very common point of user confusion. To quantify this, on
2025-12-05, 552 out of 8136 (6.8%), of issues on <a class="reference external" href="https://github.com/astral-sh/uv/issues/">uv’s issue tracker</a> contained the term “torch”.</p>
<p><strong>Security Risk:</strong> This approach has unfortunately led to supply
chain attacks - more details on the <a class="reference external" href="https://pytorch.org/blog/compromised-nightly-dependency/">PyTorch Blog</a>. It’s a
non-trivial problem to address which has forced the PyTorch team to
create a complete mirror of all their dependencies, and is one of the
core motivations behind <a class="pep reference internal" href="../pep-0766/" title="PEP 766 – Explicit Priority Choices Among Multiple Indexes">PEP 766</a>.</p>
<p>The complexity of configuration often leads to projects providing ad-hoc
installation instructions that do not provide for seamless package
upgrades.</p>
</section>
<section id="package-names-as-variants">
<h4><a class="toc-backref" href="#package-names-as-variants" role="doc-backlink">Package names as variants</a></h4>
<p>Packages such as <a class="reference external" href="https://xgboost.readthedocs.io/en/stable/install.html">XGBoost</a> use different
package names to approximate variants:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>xgboost<span class="w">      </span><span class="c1"># NVIDIA GPU variant</span>
pip<span class="w"> </span>install<span class="w"> </span>xgboost-cpu<span class="w">  </span><span class="c1"># CPU-only variant</span>
</pre></div>
</div>
<p>Maintainers of other software cannot express that they depend on either
of the available variants being selected. They need to
either depend on a specific variant, provide multiple alternative
dependency sets using extras, or even publish their own software using
multiple package names matching upstream variants.</p>
<p>Commonly, these packages install overlapping files. Since Python
packaging does not support expressing that two packages are mutually
exclusive, installers can install both of them to the same environment,
with the package installed second overwriting files from the one
installed first. This leads to runtime errors, and
the possibility of incidentally switching between variants depending on
the way package upgrades are ordered.</p>
<p>An additional limitation of this approach is that publishing a new
release synchronously across multiple package names is not currently
possible. <a class="pep reference internal" href="../pep-0694/" title="PEP 694 – Upload 2.0 API for Python Package Indexes">PEP 694</a> proposes adding such a mechanism for multiple
wheels within a single package, but extending it to multiple packages is
not a goal.</p>
<p><strong>Security Risk:</strong> proliferation of suffixed variant packages
leads users to expect these suffixes in other packages, making name
squatting much easier. For example, one could create a malicious
<code class="docutils literal notranslate"><span class="pre">numpy-cuda</span></code> package that users will be lead to believe it’s a CUDA
variant of NumPy.</p>
<p>As of the time of writing, <a class="reference external" href="https://cupy.dev/">CuPy</a> has already registered a total of 55
<code class="docutils literal notranslate"><span class="pre">cupy*</span></code> packages with different names, most of them never actually
used (they are only visible through the use of Simple API), and a large
part of the remaining ones no longer updated. This clearly highlights
the magnitude of the problem, and the effort put into countering the
risk of name squatting.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cupy
cupy-cuda70 cupy-cuda75 cupy-cuda80 cupy-cuda90 cupy-cuda91
cupy-cuda92 cupy-cuda100 cupy-cuda101 cupy-cuda102
cupy-cuda110 cupy-cuda111 cupy-cuda112 cupy-cuda113 cupy-cuda114
cupy-cuda115 cupy-cuda116 cupy-cuda117 cupy-cuda118 cupy-cuda119
cupy-cuda11x
cupy-cuda120 cupy-cuda121 cupy-cuda122 cupy-cuda123 cupy-cuda124
cupy-cuda125 cupy-cuda126 cupy-cuda127 cupy-cuda128 cupy-cuda129
cupy-cuda12x
cupy-cuda13x
cupy-rocm-4-0 cupy-rocm-4-1 cupy-rocm-4-2 cupy-rocm-4-3
cupy-rocm-4-4 cupy-rocm-4-5 cupy-rocm-5-0 cupy-rocm-5-1
cupy-rocm-5-2 cupy-rocm-5-3 cupy-rocm-5-4 cupy-rocm-5-5
cupy-rocm-5-6 cupy-rocm-5-7 cupy-rocm-5-8 cupy-rocm-5-9
cupy-rocm-6-0 cupy-rocm-6-1 cupy-rocm-6-2 cupy-rocm-6-3
cupy-rocm-7-0 cupy-rocm-7-1
</pre></div>
</div>
</section>
<section id="package-extras-as-variants">
<h4><a class="toc-backref" href="#package-extras-as-variants" role="doc-backlink">Package extras as variants</a></h4>
<p><a class="reference external" href="https://docs.jax.dev/en/latest/installation.html">JAX</a> uses a
plugin-based approach. The central <code class="docutils literal notranslate"><span class="pre">jax</span></code> package provides a number of
extras that can be used to install additional plugins,
e.g. <code class="docutils literal notranslate"><span class="pre">jax[cuda12]</span></code> or <code class="docutils literal notranslate"><span class="pre">jax[tpu]</span></code>. This is far from ideal as
<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">jax</span></code> (with no extra) leads to a nonfunctional
installation, and consequently dependency chains, a fundamental expected
behavior in the Python ecosystem, are dysfunctional.</p>
<p>JAX includes 12 extras to cover all use cases - many of which
overlap and could be misleading to users if they don’t read the
documentation in detail. Most of them are technically mutually
exclusive, though it is currently impossible to correctly express this
within the package metadata.</p>
<div class="highlight-email notranslate"><div class="highlight"><pre><span></span><span class="nt">Provides-Extra:</span><span class="w"> </span>minimum-jaxlib
<span class="nt">Provides-Extra:</span><span class="w"> </span>cpu
<span class="nt">Provides-Extra:</span><span class="w"> </span>ci
<span class="nt">Provides-Extra:</span><span class="w"> </span>tpu
<span class="nt">Provides-Extra:</span><span class="w"> </span>cuda
<span class="nt">Provides-Extra:</span><span class="w"> </span>cuda12
<span class="nt">Provides-Extra:</span><span class="w"> </span>cuda13
<span class="nt">Provides-Extra:</span><span class="w"> </span>cuda12-local
<span class="nt">Provides-Extra:</span><span class="w"> </span>cuda13-local
<span class="nt">Provides-Extra:</span><span class="w"> </span>rocm
<span class="nt">Provides-Extra:</span><span class="w"> </span>k8s
<span class="nt">Provides-Extra:</span><span class="w"> </span>xprof
</pre></div>
</div>
</section>
<section id="bundled-universal-packages-monolithic-builds">
<h4><a class="toc-backref" href="#bundled-universal-packages-monolithic-builds" role="doc-backlink">Bundled universal packages - monolithic builds</a></h4>
<p>Including all possible variants in a single wheel is another option, but
this leads to excessively large artifacts, wasting bandwidth and leading
to slower installation times for users who only need one specific
variant. In some cases, such artifacts cannot be hosted on PyPI because
they exceed its size limits.</p>
</section>
<section id="wheel-variant-selection-via-source-distribution">
<h4><a class="toc-backref" href="#wheel-variant-selection-via-source-distribution" role="doc-backlink">Wheel variant selection via source distribution</a></h4>
<p><a class="reference external" href="https://github.com/Dao-AILab/flash-attention">FlashAttention</a> does
not publish wheels on PyPI at all, but instead publishes a customized
source distribution that performs platform detection, downloads the
appropriate wheel from an upstream server, and then provides it to the
installer. This approach can select the optimal variant automatically,
but it prevents binary-only installs from working, requires a slow and
error-prone build via a source distribution, and breaks common caching
assumptions tied to the wheel filename. It also requires a specially
prepared build environment that contains the <code class="docutils literal notranslate"><span class="pre">torch</span></code> package matching
the version that the software will run against, which requires building
without build isolation. On the project side, it requires hosting wheels
separately.</p>
<p><strong>Security Risk:</strong> Similar to regular source builds, this
model requires running arbitrary code at install time. The wheels
are downloaded entirely outside the package manager’s control, extending
the attack surface to two separate wheel download implementations and
preventing proper provenance tracking.</p>
</section>
<section id="ecosystem-fragmentation">
<h4><a class="toc-backref" href="#ecosystem-fragmentation" role="doc-backlink">Ecosystem fragmentation</a></h4>
<p>The lack of standardized support for solving against hardware
and ABI requirements has led to ecosystem fragmentation:</p>
<ul class="simple">
<li><strong>Inconsistent User Experience</strong>: Each project uses different
installation methods, creating confusion and reducing discoverability.</li>
<li><strong>Development Tool Complications</strong>: Installers, IDEs, and CI/CD
systems struggle to handle non-standard installation requirements.</li>
<li><strong>Fragility</strong>: The established workarounds are often error-prone,
and in the past they have lead to issues such as downloading incorrect
artifacts.</li>
</ul>
</section>
</section>
<section id="impact-on-scientific-computing-and-ai-ml-workflows">
<h3><a class="toc-backref" href="#impact-on-scientific-computing-and-ai-ml-workflows" role="doc-backlink">Impact on scientific computing and AI/ML workflows</a></h3>
<p>The packaging limitations particularly affect scientific computing and
AI/ML applications where performance optimization is critical:</p>
<blockquote>
<div>The current wheel format’s lack of hardware awareness creates a
suboptimal experience for hardware-dependent packages. While plugins
help with smaller and well scoped packages, users must currently
manually identify the correct variant (e.g., <code class="docutils literal notranslate"><span class="pre">jax[cuda13]</span></code>) to
avoid generic defaults or incompatible combinations. We need a
system where <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">jax</span></code> automatically selects packages
matching the user’s hardware, unless explicitly overridden.<p>Wheel variants are a clear step in the right direction in this
regard.</p>
<p class="attribution">—Michael Hudgins, <a class="reference external" href="https://docs.jax.dev/en/latest/">JAX</a> Developer Infrastructure Lead</p>
</div></blockquote>
<p>They affect everyone from package authors to end users of all skill
levels, including students, scientists and engineers:</p>
<blockquote>
<div>Accessing compute to run models and process large datasets has been
a pain point in scientific computing for over a decade. Today,
researchers and data scientists still spend hours to days installing
core tools like PyTorch before they can begin their work. This
complexity is a significant barrier to entry for users who want to
use Python in their daily work. The WheelNext Wheel Variants
proposal offers a pathway to address persistent installation and
compute-access problems within the broader packaging ecosystem
without creating another, new and separate solution. Let’s focus on
the big picture of enhancing user experience - it will make a real
difference.<p class="attribution">—Leah Wasser, Executive Director and Founder of <a class="reference external" href="https://www.pyopensci.org/">pyOpenSci</a></p>
</div></blockquote>
<section id="heterogeneous-computing-environments">
<h4><a class="toc-backref" href="#heterogeneous-computing-environments" role="doc-backlink">Heterogeneous computing environments</a></h4>
<p>Research institutions and cloud providers manage heterogeneous
computing clusters with different architectures (CPU, Hardware
accelerators, ASICS, etc.). The current system requires
environment-specific installation procedures, making reproducible
deployment difficult. This situation also contributes to making
“scientific papers” difficult to reproduce. Application authors focused
on improving that are hindered by the packaging hurdles too:</p>
<blockquote>
<div>We’ve been developing a package manager for Spyder, a Python IDE for
scientists, engineers and data analysts, with three main aims.
First, to make our users’ life easier by allowing them to create
environments and install packages using a GUI instead of introducing
arcane commands in a terminal. Second, to make their research code
reproducible, so they can share it and its dependencies with their
peers. And third, to allow users to transfer their code to machines
in HPC clusters or the cloud with no hassle, so they can leverage
the vast compute resources available there. With the improvements
proposed by this PEP, we’d be able to make that a reality for all
PyPI users because installing widely used scientific libraries (like
PyTorch and CuPy) for the right GPU and instruction set and would be
straightforward and transparent for tools built on top of uv/pip.<p class="attribution">—Carlos Córdoba, lead developer of the <a class="reference external" href="https://www.spyder-ide.org/">Spyder IDE</a></p>
</div></blockquote>
</section>
<section id="artificial-intelligence-machine-learning-and-deep-learning">
<h4><a class="toc-backref" href="#artificial-intelligence-machine-learning-and-deep-learning" role="doc-backlink">Artificial intelligence, machine learning, and deep learning</a></h4>
<p>The recent advances in modern AI workflows increasingly rely on GPU
acceleration, but the current packaging system makes deployment complex
and adds a significant burden on open source developers of the entire
tool stack (from build backends to installers, not forgetting the
package maintainers).</p>
<blockquote>
<div>PyTorch’s extensive wheel support was always state of the art and
provided hardware accelerator support from day zero via our <a class="reference external" href="https://pytorch.org/get-started/locally/">package
selector</a>. We believe
this was always a superpower of PyTorch to get things working out of
the box for our users. Unfortunately, the infrastructure supporting
these is very complex, hard to maintain and inefficient (for us, our
users and package repositories).<p>With the number of hardware we support growing rapidly again, we are
very supportive of the wheel variants efforts that will allow us to
get PyTorch install instructions to be what our users have been
expecting since PyTorch was first released: <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">torch</span></code></p>
<p class="attribution">—The <a class="reference external" href="https://pytorch.org/">PyTorch</a> Core Maintainers</p>
</div></blockquote>
<p>The lead maintainer of <a class="reference external" href="https://xgboost.ai/">XGBoost</a> enumerates a
number of problems XGBoost has that he expects will be addressed by
wheel variants:</p>
<blockquote>
<div><ul class="simple">
<li>Large download size, due to the use of “fat binaries” for multiple
SMs [GPU targets]. Currently, XGBoost builds for 11 different SMs.</li>
<li>The need for a separate packaging name for CPU-only package.
Currently we ship a separate package named <code class="docutils literal notranslate"><span class="pre">xgboost-cpu</span></code>,
requiring users to maintain separate <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> files.
See <a class="reference external" href="https://github.com/dmlc/xgboost/issues/11632">xgboost#11632</a> for an example.</li>
<li>Complex dispatching logic for multiple CUDA versions. Some
features of XGBoost require new CUDA versions (12.5 or 12.8),
while the XGBoost wheel targets 12.0. As a result, we maintain a
fairly complex dispatching logic to detect CUDA and driver
versions at runtime. Such dispatching logic should be best
implemented in a dedicated piece of software like the NVIDIA
provider plugin, so that the XGBoost project can focus on its core
mission.</li>
<li>Undefined behavior due to presence of multiple OpenMP runtimes.
XGBoost is installed in a variety of systems with different OpenMP
runtimes (or none at all). So far, XGBoost has been vendoring a
copy of OpenMP runtime, but this is increasingly untenable. Users
get undefined behavior such as crashes or hangs when multiple
incompatible versions of OpenMP runtimes are present in the
system. (This problem was particularly bad on MacOS, so much so
that the MacOS wheel for XGBoost no longer bundles OpenMP.)</li>
</ul>
<p class="attribution">—Philip Hyunsu Cho, a lead maintainer of <a class="reference external" href="https://xgboost.ai/">XGBoost</a></p>
</div></blockquote>
<p>The complexity of packaging is distracting developers from focusing on
the actual goals for their software:</p>
<blockquote>
<div>We maintain a scientific software tool that uses deep learning for
analyzing biological motion in image sequences that has gotten
traction (&gt;35k users, &gt;80 countries) due to its user friendliness as
a frontend for training custom models on specialized scientific
data. Our userbase are scientists who spend all day doing brain
surgeries and molecular genetics to discover cures to diseases. It
is entirely unreasonable to expect that they should have to learn
about hardware accelerator driver compatibility matrices,
environment managers, and keep up with the ever changing Python
packaging ecosystem just to be able to analyze their data.<p>In recognition of this, my team has spent an inordinate amount of
time on maintaining dependencies and packaging hacks to ensure that
our tool, which now undergirds the reproducibility of millions of
dollars worth of research studies, remains compatible with every
platform. In the past couple of years, we estimate that we’ve spent
hundreds of hours and over $250,000 of taxpayer-supported research
funding engineering solutions to this problem. WheelNext would have
solved this entirely, allowing us to focus our efforts on
understanding and treating neurodegenerative diseases.</p>
<p class="attribution">—Talmo Pereira, Ph.D., author of <a class="reference external" href="https://sleap.ai/">SLEAP</a> and Principal Investigator
at the Salk Institute for Biological Studies</p>
</div></blockquote>
<p>The potential for improvement can be summarized as:</p>
<blockquote>
<div>This PEP is a significant step forward in improving the deployment
challenges of the Python ecosystem in the face of increasingly
complex and varied hardware configurations. By enabling multiple
deployment targets for the same libraries in a standard way, it will
consolidate and simplify many awkward and time-consuming
work-arounds developers have been pursuing to support the rapidly
growing AI/ML and scientific computing worlds.<p class="attribution">—Travis Oliphant, the author of <a class="reference external" href="https://numpy.org/">NumPy</a> and <a class="reference external" href="https://scipy.org/">SciPy</a> and Chief AI
Architect at OpenTeams</p>
</div></blockquote>
</section>
</section>
<section id="out-of-scope-features">
<h3><a class="toc-backref" href="#out-of-scope-features" role="doc-backlink">Out-of-scope features</a></h3>
<p>This PEP presents the minimal scope required to meet modern heterogenous system needs. It leaves aspects beyond the minimal scope to evolve via tools or future PEPs. A non-exhaustive list of these aspects include:</p>
<ul class="simple">
<li>The format of a static file to select variants deterministically or
include variants in a <code class="docutils literal notranslate"><span class="pre">pylock.toml</span></code> file,</li>
<li>The list of variant providers that are vendored or re-implemented by
installers,</li>
<li>The specific opt-in mechanisms and UX for allowing an installer to run
non-vendored variant providers,</li>
<li>How to instruct build backends to emit variants through the <a class="pep reference internal" href="../pep-0517/" title="PEP 517 – A build-system independent format for source trees">PEP 517</a>
mechanism.</li>
</ul>
</section>
<section id="prior-art">
<h3><a class="toc-backref" href="#prior-art" role="doc-backlink">Prior art</a></h3>
<p>This problem is not unique to the Python ecosystem, different groups and
ecosystems have come up with various answers to that very problem. This
section will focus on highlighting the strengths and weaknesses of the
different approaches taken by various communities.</p>
<section id="conda-conda-forge">
<h4><a class="toc-backref" href="#conda-conda-forge" role="doc-backlink">Conda - conda-forge</a></h4>
<p><a class="reference external" href="https://docs.conda.io">Conda</a> is a binary-only package ecosystem
that uses aggregated metadata indexes for resolution rather than
filename parsing. Unlike the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/simple-repository-api/" title="(in Python Packaging User Guide)"><span>Simple repository API</span></a>, conda’s
resolution relies on <a class="reference external" href="https://docs.conda.io/projects/conda-build/en/stable/concepts/generating-index.html">repodata indexes per platform</a>
containing full metadata, making filenames purely identifiers with no
parsing requirements.</p>
<p><strong>Variant System</strong>: In <a class="reference external" href="https://www.anaconda.com/blog/package-better-conda-build-3">2016-2017</a>,
conda-build introduced variants to differentiate packages with identical
name/version but different dependencies.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pytorch-2.8.0-cpu_mkl_py313_he1d8d61_100.conda<span class="w">      </span><span class="c1"># CPU + MKL variant</span>
pytorch-2.8.0-cuda128_mkl_py313_hf206996_300.conda<span class="w">  </span><span class="c1"># CUDA 12.8 + MKL variant</span>
pytorch-2.8.0-cuda129_mkl_py313_he100a2c_300.conda<span class="w">  </span><span class="c1"># CUDA 12.9 + MKL variant</span>
</pre></div>
</div>
<p>A hash (computed from variant metadata) prevents filename collisions;
actual variant selection happens via standard dependency constraints in
the solver. No special metadata parsing is needed—installers simply
resolve dependencies like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>conda<span class="w"> </span>install<span class="w"> </span>pytorch<span class="w"> </span>mkl
</pre></div>
</div>
<p><strong>Mutex Metapackages</strong>: Python metadata and conda metadata do not have
good ways to express ideas like “this package conflicts with that one.”
The main mechanism for enforcement is sharing a common package name -
only one package with a given name can exist at one time. Mutex
metapackages are sets of packages with the same name, but different
build string. Packages depend on specific mutex builds (e.g.,
<code class="docutils literal notranslate"><span class="pre">blas=*=openblas</span></code> vs <code class="docutils literal notranslate"><span class="pre">blas=*=mkl</span></code>) to avoid problems with related
packages using different dependency libraries, such as <a class="reference external" href="https://numpy.org/">NumPy</a> using
<a class="reference external" href="https://www.openmathlib.org/OpenBLAS/">OpenBLAS</a> and <a class="reference external" href="https://scipy.org/">SciPy</a> using
<a class="reference external" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html">MKL</a>.</p>
<p><strong>Example software variants</strong>:
<a class="reference external" href="https://conda-forge.org/docs/maintainer/knowledge_base/#blas">BLAS</a>,
<a class="reference external" href="https://conda-forge.org/docs/maintainer/knowledge_base/#message-passing-interface-mpi">MPI</a>,
<a class="reference external" href="https://conda-forge.org/docs/maintainer/knowledge_base/#openmp">OpenMP</a>,
<a class="reference external" href="https://conda-forge.org/blog/2024/10/15/python-noarch-variants/">noarch vs native</a></p>
<p><strong>Virtual Packages</strong>: <a class="reference external" href="https://github.com/conda/conda/pull/8267">Introduced in 2019</a>, virtual packages inject
system detection (CUDA version, glibc, CPU features) as solver
constraints. Built packages express dependencies like <code class="docutils literal notranslate"><span class="pre">__cuda</span> <span class="pre">&gt;=12.8</span></code>,
and the installer verifies compatibility at install time. Current
virtual packages include <code class="docutils literal notranslate"><span class="pre">archspec</span></code> (CPU capabilities), OS/system
libraries, and CUDA driver version. Detection logic is tool-specific
(<a class="reference external" href="https://github.com/conda/rattler/tree/main/crates/rattler_virtual_packages/src">rattler</a>,
<a class="reference external" href="https://github.com/mamba-org/mamba/blob/main/libmamba/src/core/virtual_packages.cpp">mamba</a>).</p>
</section>
<section id="spack-archspec">
<h4><a class="toc-backref" href="#spack-archspec" role="doc-backlink">Spack / Archspec</a></h4>
<p><a class="reference external" href="https://github.com/archspec/archspec">archspec</a> is a library for
detecting, labeling, and reasoning about CPU microarchitecture variants,
developed for the <a class="reference external" href="https://spack.io/">Spack</a> package manager.</p>
<p><strong>Variant Model:</strong> CPU Microarchitectures (e.g., <code class="docutils literal notranslate"><span class="pre">haswell</span></code>,
<code class="docutils literal notranslate"><span class="pre">skylake</span></code>, <code class="docutils literal notranslate"><span class="pre">zen2</span></code>, <code class="docutils literal notranslate"><span class="pre">armv8.1a</span></code>) form a <a class="reference external" href="https://tgamblin.github.io/pubs/archspec-canopie-hpc-2020.pdf">Directed Acyclic Graph
(DAG) encoding binary compatibility</a>,
which helps at resolve to express that <code class="docutils literal notranslate"><span class="pre">packageB</span></code> depends on
<code class="docutils literal notranslate"><span class="pre">packageA</span></code>. The ordering is partial because (1) separate ISA families
are incomparable, and (2) contemporary designs may have incompatible
feature sets—cascadelake and cannonlake are incomparable despite both
descending from skylake, as each has unique AVX-512 extensions.</p>
<p><strong>Implementation:</strong> A language-agnostic JSON database stores
microarchitecture metadata (features, compatibility relationships,
compiler-specific optimization flags). Language bindings provide
detection (queries <code class="docutils literal notranslate"><span class="pre">/proc/cpuinfo</span></code>, matches to microarchitecture with
largest compatible feature subset) and compatibility comparison
operators.</p>
<p><strong>Package Manager Integration:</strong> Spack records target microarchitecture
as package provenance (<code class="docutils literal notranslate"><span class="pre">spack</span> <span class="pre">install</span> <span class="pre">fftw</span> <span class="pre">target=broadwell</span></code>),
automatically selects compiler flags, and enables
microarchitecture-aware binary caching. The <a class="reference external" href="https://onlinelibrary.wiley.com/doi/full/10.1002/spe.3075">European Environment for
Scientific Software Installations (EESSI)</a>
distributes optimized builds in separate subdirectories per
microarchitecture (e.g., <code class="docutils literal notranslate"><span class="pre">x86_64</span></code>, <code class="docutils literal notranslate"><span class="pre">armv8.1a</span></code>, <code class="docutils literal notranslate"><span class="pre">haswell</span></code>);
runtime initialization uses <code class="docutils literal notranslate"><span class="pre">archspec</span></code> to select best compatible build
when no exact match exists.</p>
</section>
<section id="gentoo-linux">
<h4><a class="toc-backref" href="#gentoo-linux" role="doc-backlink">Gentoo Linux</a></h4>
<p><a class="reference external" href="https://www.gentoo.org">Gentoo Linux</a> is a source-first distribution
with support for extensive package customization. This is primarily
achieved via <a class="reference external" href="https://devmanual.gentoo.org/general-concepts/use-flags/index.html">USE flags</a>:
boolean flags exposed by individual packages and permitting fine-tuning
the enabled features, optional dependencies and some build parameters
(e.g. <code class="docutils literal notranslate"><span class="pre">jpegxl</span></code> for JPEG XL image format support,
<code class="docutils literal notranslate"><span class="pre">cpu_flags_x86_avx2</span></code> for AVX2 instruction set use). Flags can be
toggled individually, and separate binary packages can be built for
different sets of flags. The package manager can either pick a binary
package with matching configuration or build from source.</p>
<p>API and ABI matching is primarily done through use of <a class="reference external" href="https://devmanual.gentoo.org/general-concepts/slotting/index.html">slotting</a>.
Slots are generally used to provide multiple versions or variants of
given package that can be installed alongside (e.g. different major GTK+
or LLVM versions, or GTK+3 and GTK4 builds of WebKitGTK), whereas
subslots are used to group versions within a slot, usually corresponding
to the library ABI version. Packages can then declare dependencies bound
to the slot and subslot used at build time. Again, separate binary
packages can be built against different dependency slots. When
installing a dependency version falling into a different slot or
subslot, the package manager may either replace the package needing that
dependency with a binary packages built against the new slot, or rebuild
it from source.</p>
<p>Normally, the use of slots assumes that upgrading to the newest version
possible is desirable. When more fine-grained control is desired, slots
are used in conjunction with USE flags. For example,
<code class="docutils literal notranslate"><span class="pre">llvm_slot_{major}</span></code> flags are used to select a LLVM major version to
build against.</p>
</section>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<section id="wheel-variant-glossary">
<h3><a class="toc-backref" href="#wheel-variant-glossary" role="doc-backlink">Wheel variant glossary</a></h3>
<dl class="simple">
<dt>Variant Wheels</dt><dd>Wheels that share the same distribution name, version, build number,
and platform compatibility tags, but are distinctly identified by an
arbitrary set of variant properties.</dd>
<dt>Variant Namespace</dt><dd>An identifier used to group related features provided by a single
provider (e.g., <code class="docutils literal notranslate"><span class="pre">nvidia</span></code>, <code class="docutils literal notranslate"><span class="pre">x86_64</span></code>, <code class="docutils literal notranslate"><span class="pre">arm</span></code>, etc.).</dd>
<dt>Variant Feature</dt><dd>A specific characteristic (key) within a namespace (e.g.,
<code class="docutils literal notranslate"><span class="pre">version</span></code>, <code class="docutils literal notranslate"><span class="pre">avx512_bf16</span></code>, etc.) that can have one or more
values.</dd>
<dt>Variant Property</dt><dd>A 3-tuple (<code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">::</span> <span class="pre">feature-name</span> <span class="pre">::</span> <span class="pre">feature-value</span></code>)
describing a single specific feature and its value. If a feature has
multiple values, each is represented by a separate property.</dd>
<dt>Variant Label</dt><dd>A string (up to 16 characters) added to the wheel filename to
uniquely identify variants.</dd>
<dt>Null Variant</dt><dd>A special variant with zero variant properties and the reserved
label <code class="docutils literal notranslate"><span class="pre">null</span></code>. Always considered supported but has the lowest
priority among wheel variants, while being preferably chosen over
non-variant wheels.</dd>
<dt>Variant Provider</dt><dd>A provider of supported and valid variant properties for a specific
namespace, usually in the form of a Python package that implements
system detection.</dd>
<dt>Install-time Provider</dt><dd>A provider implemented as a plugin that can be queried during wheel
installation.</dd>
<dt>Ahead-of-Time Provider</dt><dd>A provider that features a static list of supported properties which
is then embedded in the wheel metadata. Such a list can either be
embedded in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> or provided by a plugin queried at
build time.</dd>
</dl>
</section>
<section id="overview">
<h3><a class="toc-backref" href="#overview" role="doc-backlink">Overview</a></h3>
<p>Wheel variants introduce a more fine-grained specification of built
wheel characteristics beyond what existing wheel tags provide.
Individual wheels carry a human-readable label defined at build time, as
described in <a class="reference internal" href="#modified-wheel-filename">modified wheel filename</a>, and are characterizing using
<a class="reference internal" href="#variant-property-system">variant property system</a>. The properties are organized into a
hierarchical structure of namespaces, features and feature values. When
evaluating wheels to install, the installer determines whether variant
properties of a given wheel are compatible with the system, and perform
<a class="reference internal" href="#variant-ordering">variant ordering</a> based on the priority of the compatible variant
properties. This is done in addition to determining the compatibility.
The ordering by variant properties takes precedence over ordering by
tags.</p>
<p>Every variant namespace is governed by a variant provider. There are two
kinds of variant providers: install-time providers and ahead-of-time
(AoT) providers. Install-time providers require plugins that are queried
while installing wheels to determine the set of supported properties and
their preference order. For AoT providers, this data is static and
embedded in the wheel; it can be either provided directly by the
wheel maintainer or queried at wheel build time from an AoT plugin.</p>
<p>Both kinds of plugins are usually implemented as Python packages which
implement the <a class="reference internal" href="#provider-plugin-api">provider plugin API</a>, but they may also be vendored or
reimplemented by installers to improve security, as outlined in
<a class="reference internal" href="#providers">Providers</a>. Plugin packages may be installed in isolated or
non-isolated environments. In particular, all plugins may be returned by
the <code class="docutils literal notranslate"><span class="pre">get_requires_for_build_wheel()</span></code> hook of a <a class="pep reference internal" href="../pep-0517/" title="PEP 517 – A build-system independent format for source trees">PEP 517</a> backend, and
therefore installed along with other build dependencies. For this
reason, it is important that plugin packages do not narrowly pin
dependencies, as that could prevent different packages from being
installed simultaneously in the same environment.</p>
<p>Metadata governing variant support is defined in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>
file, and it is copied into <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> file in wheels, as explored
in <a class="reference internal" href="#metadata-in-source-tree-and-wheels">metadata in source tree and wheels</a>. Additionally, <a class="reference internal" href="#variant-environment-markers">variant
environment markers</a> can be used to define dependencies specific to a
subset of variants.</p>
</section>
<section id="modified-wheel-filename">
<h3><a class="toc-backref" href="#modified-wheel-filename" role="doc-backlink">Modified wheel filename</a></h3>
<p>One of the core requirements of the design is to ensure that installers
predating this PEP will ignore wheel variant files. This makes it
possible to publish both variant wheels and non-variant wheels on a
single index, with installers that do not support variants securely
ignoring the former, and falling back to the latter.</p>
<p>A variant label component is added to the filename for the twofold
purpose of providing a unique mapping from the filename to a set of
variant properties, and providing a human-readable identification for
the variant. The label is kept short and lowercase to avoid issues with
different filesystems. It is added as a <code class="docutils literal notranslate"><span class="pre">-</span></code>-separated component at the
end to ensure that the existing filename validation algorithms reject
it:</p>
<ul>
<li>If both the build tag and the variant label are present, the filename
contains too many components. Example:<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>numpy-2.3.2-1-cp313-cp313t-musllinux_1_2_x86_64-x86_64_v3.whl
                                               ^^^^^^^^^^
</pre></div>
</div>
</li>
<li>If only the variant label is present, the Python tag at third position
will be misinterpreted as a build number. Since the build number must
start with a digit and no Python tags at the time start with digits,
the filename is considered invalid. Example:<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>numpy-2.3.2-cp313-cp313t-musllinux_1_2_x86_64-x86_64_v3.whl
            ^^^^^
</pre></div>
</div>
</li>
</ul>
<p>This behavior was confirmed for a number of existing tools:
<a class="reference external" href="https://github.com/pypa/auditwheel/blob/6839107e9b918e035ab2df4927a25a5f81f1b8b6/src/auditwheel/repair.py#L61-L64">auditwheel</a>,
<a class="reference external" href="https://github.com/pypa/packaging/blob/78c2a5e4f5c04fd782a5729d93892c3a3eafe365/src/packaging/utils.py#L94-L134">packaging</a>,
<a class="reference external" href="https://github.com/pdm-project/pdm/blob/66c86908c9b9d07ad8d101d07879d69a55de5c54/src/pdm/models/requirements.py#L259-L286">pdm</a>,
<a class="reference external" href="https://github.com/pypa/pip/blob/c46141c29c3646a3328bc4e51d354cc732fb1432/src/pip/_internal/models/wheel.py#L38-L46">pip</a>,
<a class="reference external" href="https://github.com/python-poetry/poetry/blob/1c04c65149776ae4993fa508bef53373f45c66eb/src/poetry/utils/wheel.py#L23-L27">poetry</a>,
and <a class="reference external" href="https://github.com/astral-sh/uv/blob/f6a9b55eb73be4f1fb9831362a192cdd8312ab96/crates/uv-distribution-filename/src/wheel.rs#L182-L299">uv</a>.</p>
</section>
<section id="variant-property-system">
<h3><a class="toc-backref" href="#variant-property-system" role="doc-backlink">Variant property system</a></h3>
<p>Variant properties serve the purpose of expressing the characteristics
of the variant. Unlike platform compatibility tags, they are stored in
the variant metadata and therefore do not affect the wheel filename
length. They follow a hierarchical key-value design, with the key
further broken into a namespace and a feature name. Namespaces are used
to group features defined by a single provider, and to avoid conflicts
should multiple providers define a feature with the same name. This
permits independent governance and evolution of every namespace.</p>
<p>The keys are restricted to lowercase letters, digits, and underscores.
Uppercase characters are disallowed to avoid different spellings of the
same name. The character set for values is more relaxed, to permit
values resembling versions.</p>
<p>Variant properties are serialized into a structured 3-tuple format
inspired by Trove Classifiers in <a class="pep reference internal" href="../pep-0301/" title="PEP 301 – Package Index and Metadata for Distutils">PEP 301</a>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{namespace} :: {feature_name} :: {feature_value}
</pre></div>
</div>
<p>Properties are used both to determine variant wheel compatibility, and
to select the best variant to install. Provider plugins indicate which
variant properties are compatible with the system, and order them by
importance. This ordering can further be altered in variant wheel
metadata.</p>
<p>Variant features can be declared as allowing multiple values to be
present within a single variant wheel. If that is the case, these values
are matched as a logical OR, i.e. only a single value needs to
be compatible with the system for the wheel to be considered supported.
On the other hand, features are treated as a logical AND, i.e. all of them
need to be compatible. This provides some flexibility in designating
variant compatibility while avoiding having to implement a complete
boolean logic.</p>
<p>Typically, variant features will be single-value and indicate minimal or
mutually exclusive requirements. The system may indicate multiple
compatible values. For example, if the feature declares a minimum CUDA
runtime version, the provider will indicate compatibility with wheels
requiring a minimum version corresponding to the currently installed
version or older, e.g. for CUDA 12.8, the compatible minimum versions
used in wheels would be, in order of decreasing preference:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nvidia :: cuda_version_lower_bound :: 12.8
nvidia :: cuda_version_lower_bound :: 12.7
nvidia :: cuda_version_lower_bound :: 12.6
...
</pre></div>
</div>
<p>Similarly, a wheel could indicate its minimum required CPU version, and
the provider will indicate all the compatible CPU versions.</p>
<p>Multi-value features are useful for “fat” packages where multiple
incompatible targets are supported by a single package. A typical
example are GPUs. In this case, the wheel declares a number of supported
GPUs, and the provider indicates which GPUs are actually installed
(usually one). The wheel is compatible if there is overlap between the
two lists.</p>
</section>
<section id="null-variant">
<h3><a class="toc-backref" href="#null-variant" role="doc-backlink">Null variant</a></h3>
<p>A null variant is a variant wheel with no properties, but distinct
from non-variant wheels in having the <code class="docutils literal notranslate"><span class="pre">null</span></code> variant label and variant
metadata. During the transition period, it provides the possibility of
providing a distinct fallback for systems that do not support any of
the variants provided, and for systems that do support variant wheels at
all.</p>
<p>For example, a package with optional GPU support could publish three
kinds of wheels:</p>
<ul class="simple">
<li>Multiple GPU-enabled wheels, each built for a single CUDA version with
a matching set of supported GPUs, and used only when the provider
plugin indicates that the system is compatible.</li>
<li>A CPU-only null variant, much smaller than the GPU variants, installed
when the provider plugin indicates that no compatible GPU is
installed.</li>
<li>A GPU+CPU non-variant wheel, that will be installed on systems without
an installer supporting variants.</li>
</ul>
<p>Publishing a null variant is optional, and makes sense only if distinct
fallbacks provide advantages to the user. If one is published, a wheel
variant-enabled installer will prefer it over the non-variant wheel. If
it is not, it will fall back to the non-variant wheel instead. The
non-variant wheel is also used if variant support is explicitly disabled
by an installer flag.</p>
<p>The null variant uses a reserved <code class="docutils literal notranslate"><span class="pre">null</span></code> label to make it clearly
distinguishable from regular variants.</p>
</section>
<section id="install-time-and-ahead-of-time-providers">
<h3><a class="toc-backref" href="#install-time-and-ahead-of-time-providers" role="doc-backlink">Install-time and Ahead-of-Time providers</a></h3>
<p>The variant wheel metadata specifies what providers are used for its
properties. Providers serve a twofold purpose:</p>
<ol class="loweralpha simple">
<li>at install time: determining which variant wheels are compatible with
the user’s system, and which of them constitutes the best choice, and</li>
<li>at build time: determining which variant properties are valid for
building a wheel.</li>
</ol>
<p>The specification proposes two kinds of providers: install-time
providers and Ahead-of-Time providers.</p>
<p>Install-time providers are implemented either as Python packages that
need to be installed and run to query them, or vendored or reimplemented
in the tools. They are used when user systems need to be queried to
determine wheel compatibility, for example for variants utilizing GPUs
or requiring CPU instruction sets beyond what platform tags provide.
Installing third-party packages involves security risks highlighted in
the <a class="reference internal" href="#security-implications">security implications</a> section, and the proposed mitigations incur
a cost on installer implementations.</p>
<p>Ahead-of-Time providers are implemented as static metadata embedded in
the wheel. They are used when particular variant properties are always
compatible with the user’s system (provided that a wheel using them has
been built successfully). However, the metadata indicates which
properties are preferred. For example, AoT providers can be used to
provide choice between builds against different BLAS / LAPACK providers,
or to provide debug builds of packages. Since they do not require
running code external to the installer, they do not pose the problems
faced by install-time providers, and can be used more liberally.</p>
<p>AoT providers are permitted to feature plugin packages. If that is the
case, these packages are only used when building wheels, and their
output is used to fill in the static metadata used at install time.
This way, it is easier to use consistent property names and values
across multiple packages. Otherwise, the package maintainer needs to
include the supported properties directly in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>
file.</p>
<p>When implemented as Python packages, both kinds of provider plugins
expose roughly the same API. However, an AoT provider must always
consider all valid variant properties supported, and it must always
return the same ordered list of supported properties irrespective of the
user system. All AoT providers can technically be used as install-time
providers, but not the other way around.</p>
</section>
<section id="plugin-stability-and-versioning">
<h3><a class="toc-backref" href="#plugin-stability-and-versioning" role="doc-backlink">Plugin stability and versioning</a></h3>
<p>As the specification introduces the potential necessity of installing
and running provider packages to install wheels, it is recommended that
these packages remain functioning correctly for the variant wheels
published in the past, including very old package versions. Ideally, no
properties previously supported should ever be removed.</p>
<p>If a breaking change needs to be performed, it is recommended to either
introduce a new provider package for that, or add a new plugin API
endpoint to the existing package. In both cases, it may be necessary to
preserve the old endpoint in minimal maintenance mode, to ensure that
old wheels can still be installed. The old endpoint can trigger
deprecation warnings in the <code class="docutils literal notranslate"><span class="pre">get_all_configs()</span></code> hook that is used when
building packages.</p>
<p>An alternative approach is to use semantic versioning to cut off
breaking changes. However, this relies on package authors reliably using
caps on dependencies, as otherwise old wheels will start using
incompatible plugin versions. This is already a problem with Python
build backends used today.</p>
<p>When vendoring or reimplementing plugins, installers need to follow
their current behavior. In particular, they should recognize the
relevant provider versions numbers, and possibly fall back to installing
the external plugin when the package in question is incompatible with
the installer’s implementation.</p>
</section>
<section id="metadata-in-source-tree-and-wheels">
<h3><a class="toc-backref" href="#metadata-in-source-tree-and-wheels" role="doc-backlink">Metadata in source tree and wheels</a></h3>
<p>Variants introduce a few new portions of metadata that are stored in the
source tree and in wheels. In the source tree, it is stored in the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file along with other project properties, benefiting
from the TOML format’s readability and strictness. Afterwards, it is
converted into an equivalent JSON structure, and stored as a separate
file in the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory. The existing metadata files are
unchanged to avoid unnecessary incompatibility, and to avoid serializing
into the inconvenient <a class="reference external" href="https://packaging.python.org/en/latest/specifications/core-metadata/" title="(in Python Packaging User Guide)"><span class="xref std std-doc">Core Metadata</span></a> format.</p>
<p>The metadata in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> includes:</p>
<ul class="simple">
<li>information about variant providers that could be used by the wheels,</li>
<li>optionally, lists overriding the default property ordering,</li>
<li>static property lists for Ahead-of-Time providers that do not use
plugins.</li>
</ul>
<p>In wheel metadata, the above is amended by static property lists
obtained from the plugins and variant properties for the built wheel.</p>
<p>When wheels are published on an index, the variant metadata from all
wheels is combined into a single <code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code> file
that is used by clients to efficiently obtain the variant metadata
without having to download it from individual wheels separately, or
implement explicit variant metadata support in an API provided by the
package index server.</p>
</section>
<section id="abi-dependency-variant-provider">
<h3><a class="toc-backref" href="#abi-dependency-variant-provider" role="doc-backlink">ABI dependency variant provider</a></h3>
<p>Some packages provide extension modules exposing an Application Binary
Interface (ABI) that is not compatible across wide ranges of versions.
The packages using this interface need to pin their wheels to the
version used at build time. If ABI changes frequently, the pins are very
narrow and users face problems if they need to install two packages that
may happen to pin to different versions of the same dependency.
Providing variants built against different dependency versions can
increase the chance of a resolver being able to find a dependency version
that is compatible with all the packages being installed.</p>
<p>Unfortunately, such a variant provider cannot be implemented within the
plugin API defined by the specification. Given that a robust
implementation would need to interface with the dependency resolver,
rather than attempt to extend the API to cover this use case and add
significant complexity as a result, the specification reserves
<code class="docutils literal notranslate"><span class="pre">abi_dependency</span></code> as a special variant namespace that can be
implemented by installers wishing the provide this feature.</p>
<p>Given the complexity of the problem, this extension is made entirely
optional. This implies that any packages using it need to provide
non-variant wheels as well.</p>
</section>
<section id="example-use-cases">
<h3><a class="toc-backref" href="#example-use-cases" role="doc-backlink">Example use cases</a></h3>
<section id="pytorch-cpu-gpu-variants">
<h4><a class="toc-backref" href="#pytorch-cpu-gpu-variants" role="doc-backlink">PyTorch CPU/GPU variants</a></h4>
<p>As of October 2025, <a class="reference external" href="https://pytorch.org/get-started/locally/">PyTorch</a> publishes a total of seven
variants for every release: a CPU-only variant, three CUDA variants with
different minimal CUDA runtime versions and supported GPUs, two ROCm
variants and a Linux XPU variant.</p>
<p>This setup could be improved using GPU/XPU plugins that query the
installed runtime version and installed GPUs/XPUs to filter out the
wheels for which the runtime is unavailable, it is too old or the user’s
GPU is not supported, and order the remaining variants by the runtime
version. The CPU-only version is published as a null variant that is
always supported.</p>
<p>If a GPU runtime is available and supported, the installer automatically
chooses the wheel for the newest runtime supported. Otherwise, it falls
back to the CPU-only variant. In the corner case when multiple
accelerators are available and supported, PyTorch package maintainers
indicate which one takes preference by default.</p>
</section>
<section id="optimized-cpu-variants">
<h4><a class="toc-backref" href="#optimized-cpu-variants" role="doc-backlink">Optimized CPU variants</a></h4>
<p>Wheel variants can be used to provide variants requiring specific CPU
extensions, beyond what platform tags currently provide. They can be
particularly helpful when runtime dispatching is impractical, when the
package relies on prebuilt components that use instructions above the
baseline, when availability of instruction sets implies library ABI
changes, or simply to benefit from compiler optimizations such as
auto-vectorization applied across the code base.</p>
<p>For example, an x86-64 CPU plugin can detect the capabilities for the
installed CPU, mapping them onto the appropriate x86-64 architecture
level and a set of extended instruction sets. Variant wheels indicate
which level and/or instruction sets are required. The installer filters
out variants that do not meet the requirements and select the best
optimized variant. A non-variant wheel can be used to represent the
architecture baseline, if supported.</p>
<p>Implementation using wheel variants makes it possible to provide
fine-grained indication of instruction sets required, with plugins that
can be updated as frequently as necessary. In particular, it is neither
necessary to cover all available instruction sets from the start, nor to
update the installers whenever the instruction set coverage needs to be
improved.</p>
</section>
<section id="blas-lapack-variants">
<h4><a class="toc-backref" href="#blas-lapack-variants" role="doc-backlink">BLAS / LAPACK variants</a></h4>
<p>Packages such as <a class="reference external" href="https://numpy.org/">NumPy</a> and <a class="reference external" href="https://scipy.org/">SciPy</a> can be built using different BLAS /
LAPACK libraries. Users may wish to choose a specific library for
improved performance on a particular hardware, or based on license
considerations. Furthermore, different libraries may use different
OpenMP implementations, whereas using a consistent implementation across
the stack can avoid degrading performance through spawning too many
threads.</p>
<p>BLAS / LAPACK variants do not require a plugin at install time, since
all variants built for a particular platform are compatible with it.
Therefore, an ahead-of-time provider (with <code class="docutils literal notranslate"><span class="pre">install-time</span> <span class="pre">=</span> <span class="pre">false</span></code>)
that provides a predefined set of BLAS / LAPACK library names can be
used. When the package is installed, normally the default variant is
used, but the user can explicitly select another one.</p>
</section>
<section id="debug-package-variants">
<h4><a class="toc-backref" href="#debug-package-variants" role="doc-backlink">Debug package variants</a></h4>
<p>A package may wish to provide a special debug-enabled builds for
debugging or CI purposes, in addition to the regular release build. For
this purpose, an optional ahead-of-time provider can be used
(<code class="docutils literal notranslate"><span class="pre">install-time</span> <span class="pre">=</span> <span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">optional</span> <span class="pre">=</span> <span class="pre">true</span></code>), defining a custom
property for the debug builds. Since the provider is disabled by
default, users normally install the non-variant wheel providing the
release build. However, they can easily obtain the debug build by
enabling the optional provider or selecting the variant explicitly.</p>
</section>
<section id="package-abi-matching">
<h4><a class="toc-backref" href="#package-abi-matching" role="doc-backlink">Package ABI matching</a></h4>
<p>Packages such as <a class="reference external" href="https://docs.vllm.ai/en/latest/index.html">vLLM</a>
need to be pinned to the PyTorch version they were built against to
preserve Application Binary Interface (ABI) compatibility. This often
results in unnecessarily strict pins in package versions, making it
impossible to find a satisfactory resolution for an environment
involving multiple packages requiring different versions of PyTorch, or
resorting to source builds. Variant wheels can be used to publish
variants of vLLM built against different PyTorch versions, therefore
enabling upstream to easily provide support for multiple versions
simultaneously.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">abi_dependency</span></code> extension can be used to build multiple
<code class="docutils literal notranslate"><span class="pre">vllm</span></code> variants that are pinned to different PyTorch versions, e.g.:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vllm-0.11.0-...-torch29.wheel</span></code> with
<code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2.9</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">vllm-0.11.0-...-torch28.wheel</span></code> with
<code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2.8</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">vllm-0.11.0-...-torch27.wheel</span></code> with
<code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2.7</span></code></li>
</ul>
</section>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security implications</a></h2>
<p>The proposal introduces a plugin system for querying the system
capabilities in order to determine variant wheel capability. The system
permits specifying additional Python packages providing the plugins
in the package index metadata. Installers and other tools that need
to determine whether a particular wheel is installable, or select
the most preferred variant among multiple variant wheels, may need
to install these packages and execute the code within them while
resolving dependencies or processing wheels.</p>
<p>This elevates the supply-chain attack potential by introducing two new
points for malicious actors to inject arbitrary code payload:</p>
<ol class="arabic simple">
<li>Publishing a version of a variant provider plugin or one of its
dependencies with malicious code.</li>
<li>Introducing a malicious variant provider plugin in an existing
package metadata.</li>
</ol>
<p>While such attacks are already possible at the package dependency level,
it needs to be emphasized that in some scenarios the affected tools are
executed with elevated privileges, e.g. when installing packages for
multi-user systems, while the installed packages are only used with
regular user privileges afterwards. Therefore, variant provider plugins
could introduce a Remote Code Execution vulnerability with elevated
privileges.</p>
<p>A similar issue already exists in the packaging ecosystem when packages
are installed from source distributions, whereas build backends
and other build dependencies are installed and executed. However,
various tools operating purely on wheels, as well as users using
tool-specific options to disable use of source distributions,
have been relying on the assumption that no code external to the system
will be executed while resolving dependencies, installing a wheel or
otherwise processing it. To uphold this assumption, the proposal
explicitly requires that untrusted provider plugin packages are never installed
without explicit user consent.</p>
<p>The <a class="reference internal" href="#providers">Providers</a> section of the specification provides further
suggestions that aim to improve both security and the user experience.
It is expected that a limited subset of popular provider plugins will
be either vendored by the installer, eliminating the use of packages
external to the tool altogether, or pinned to specific versions,
providing the same level of code auditing as the tools themselves.
This will lead to the majority of packages focusing on these specific
plugins. External plugins requiring explicit opt-in should be rare,
minimizing the workflow disruption and reducing the risk that users
blanket-allow all plugins.</p>
<p>Furthermore, the specification permits using static configuration as
input to skip running plugins altogether.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>This PEP proposes a set of extensions to the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/#binary-distribution-format" title="(in Python Packaging User Guide)"><span>Binary distribution format</span></a> specification that enable
building additional variants of wheels that can be installed by
variant-aware tools while being ignored by programs that do not
implement this specification.</p>
<section id="definitions">
<h3><a class="toc-backref" href="#definitions" role="doc-backlink">Definitions</a></h3>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2119.html"><strong>RFC 2119</strong></a>.</p>
</section>
<section id="extended-wheel-filename">
<h3><a class="toc-backref" href="#extended-wheel-filename" role="doc-backlink">Extended wheel filename</a></h3>
<p>The wheel filename template originally defined by <a class="pep reference internal" href="../pep-0427/" title="PEP 427 – The Wheel Binary Package Format 1.0">PEP 427</a> is changed
to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}(-{variant label})?.whl
                                                                             +++++++++++++++++++
</pre></div>
</div>
<p>Wheels using extensions introduced by this PEP MUST feature the variant
label component. The label MUST adhere to the following rules:</p>
<ul class="simple">
<li>Lower case only (to prevent issues with case-sensitive
vs. case-insensitive filesystems)</li>
<li>Between 1-16 characters</li>
<li>Using only <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, <code class="docutils literal notranslate"><span class="pre">.</span></code> or <code class="docutils literal notranslate"><span class="pre">_</span></code> ASCII characters</li>
</ul>
<p>This is equivalent to the following regular expression:
<code class="docutils literal notranslate"><span class="pre">^[0-9a-z._]{1,16}$</span></code>.</p>
<p>Every label MUST uniquely correspond to a specific set of variant
properties, which MUST be the same for all wheels using the same label within a single
package version. Variant labels SHOULD be specified at wheel build time,
as human-readable strings. The label <code class="docutils literal notranslate"><span class="pre">null</span></code> is reserved for the null
variant and MUST use an empty set of variant properties.</p>
<p>Installers that do not implement this specification MUST ignore wheels
with variant label when installing from an index, and fall back to a
wheel without such label if it is available. If no such wheel is
available, the installer SHOULD output an appropriate diagnostic,
in particular warning if it results in selecting an earlier package
version or a clear error if no package version can be installed.</p>
<p>Examples:</p>
<ul class="simple">
<li>Non-variant wheel:
<code class="docutils literal notranslate"><span class="pre">numpy-2.3.2-cp313-cp313t-musllinux_1_2_x86_64.whl</span></code></li>
<li>Wheel with variant label:
<code class="docutils literal notranslate"><span class="pre">numpy-2.3.2-cp313-cp313t-musllinux_1_2_x86_64-x86_64_v3.whl</span></code></li>
</ul>
</section>
<section id="variant-properties">
<h3><a class="toc-backref" href="#variant-properties" role="doc-backlink">Variant properties</a></h3>
<p>Every variant wheel MUST be described by zero or more variant
properties. A variant wheel with exactly zero properties represents the
null variant. The properties are specified when the variant wheel is
being built, using a mechanism defined by the project’s build backend.</p>
<p>Each variant property is described by a 3-tuple that is serialized into
the following format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">namespace</span><span class="p">}</span> <span class="p">::</span> <span class="p">{</span><span class="n">feature_name</span><span class="p">}</span> <span class="p">::</span> <span class="p">{</span><span class="n">feature_value</span><span class="p">}</span>
</pre></div>
</div>
<p>The namespace MUST consist only of <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> ASCII
characters (<code class="docutils literal notranslate"><span class="pre">^[a-z0-9_]+$</span></code>). It MUST correspond to a single variant
provider.</p>
<p>The feature name MUST consist only of <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> ASCII
characters (<code class="docutils literal notranslate"><span class="pre">^[a-z0-9_]+$</span></code>). It MUST correspond to a valid feature
name defined by the respective variant provider in the namespace.</p>
<p>The feature value MUST consist only of <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, <code class="docutils literal notranslate"><span class="pre">_</span></code> and <code class="docutils literal notranslate"><span class="pre">.</span></code>
ASCII Characters (<code class="docutils literal notranslate"><span class="pre">^[a-z0-9_.]+$</span></code>). It MUST correspond to a valid
value defined by the respective variant provider for the feature.</p>
<p>If a feature is marked as “multi-value” by the provider plugin, a single
variant wheel can define multiple properties sharing the same namespace
and feature name. Otherwise, there MUST NOT be more than a single value
corresponding to a single pair of namespace and feature name within a
variant wheel.</p>
<p>For a variant wheel to be considered compatible with the system, all of
the features defined within it MUST be determined to be compatible. For
a feature to be compatible, at least a single value corresponding to it
MUST be compatible.</p>
<p>Examples:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># all of the following must be supported
x86_64 :: level :: v3
x86_64 :: avx512_bf16 :: on
nvidia :: cuda_version_lower_bound :: 12.8
# additionally, at least one of the following must be supported
nvidia :: sm_arch :: 120_real
nvidia :: sm_arch :: 110_real
</pre></div>
</div>
</section>
<section id="providers">
<h3><a class="toc-backref" href="#providers" role="doc-backlink">Providers</a></h3>
<p>When installing or resolving variant wheels, installers SHOULD query the
variant provider to verify whether a given wheel’s properties are
compatible with the system and to select the best variant through
<a class="reference internal" href="#variant-ordering">variant ordering</a>. However, they MAY provide an option to omit the
verification and install a specified variant explicitly.</p>
<p>Providers can be marked as install-time or ahead-of-time. For
install-time providers, installers MUST use the provider package or an
equivalent reimplementation to query variant property compatibility. For
ahead-of-time providers, they MUST use the static metadata embedded in
the wheel instead.</p>
<p>Providers can be marked as optional. If a provider is marked optional,
then the installer MUST NOT query said provider by default, and instead
assume that its properties are incompatible. It SHOULD provide an option
to enable optional providers.</p>
<p>Providers can also be made conditional to
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/#dependency-specifiers-environment-markers" title="(in Python Packaging User Guide)"><span>Environment Markers</span></a>. If that is the case,
the installer MUST check the markers against the environment to which
wheels are going to be installed. It MUST NOT use any providers whose
markers do not match, and instead assume that their properties are
incompatible.</p>
<p>All the tools that need to query variant providers and are run in a
security-sensitive context, MUST NOT install or run code from any
untrusted package for variant resolution without explicit user opt-in.
Install-time provider packages SHOULD take measures to guard against
supply chain attacks, for example by vendoring all dependencies.</p>
<p>It is RECOMMENDED that said tools vendor, reimplement or lock the most
commonly used plugins to specific wheels. For plugins and their
dependencies that are neither reimplemented, vendored nor otherwise
vetted, a trust-on-first-use mechanism for every version is RECOMMENDED.
In interactive sessions, the tool can explicitly ask the user for
approval. In non-interactive sessions, the approval can be given using
command-line interface options. It is important that the user is
informed of the risk before giving such an approval.</p>
<p>For a consistent experience between tools, variant wheels SHOULD be
supported by default. Tools MAY provide an option to only use
non-variant wheels.</p>
</section>
<section id="variant-metadata">
<h3><a class="toc-backref" href="#variant-metadata" role="doc-backlink">Variant metadata</a></h3>
<p>This section describes the metadata format for the providers, variants
and properties of a package and its wheels. The format is used in three
locations, with slight variations:</p>
<ol class="arabic simple">
<li>in the source tree, inside the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file</li>
<li>in the built wheel, as a <code class="docutils literal notranslate"><span class="pre">*.dist-info/variant.json</span></code> file</li>
<li>on the package index, as a <code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code> file.</li>
</ol>
<p>All three variants metadata files share a common JSON-compatible
structure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(root)
|
+- providers
|  +- {namespace}
|     +- enable-if     : str | None = None
|     +- install-time  : bool       = True
|     +- optional      : bool       = False
|     +- plugin-api    : str | None = None
|     +- requires      : list[str]  = []
|
+- default-priorities
|  +- namespace        : list[str]
|  +- feature
|     +- {namespace}   : list[str]  = []
|  +- property
|     +- {namespace}
|        +- {feature}  : list[str]  = []
|
+- static-properties
|  +- {namespace}
|     +- {feature}     : list[str]  = []
|
+- variants
  +- {variant_label}
     +- {namespace}
        +- {feature}   : list[str]  = []
</pre></div>
</div>
<p>The top-level object is a dictionary rooted at a specific point in the
containing file. Its individual keys are sub-dictionaries that are
described in the subsequent sections, along with the requirements for
their presence. The tools MUST ignore unknown keys in the dictionaries
for forwards compatibility of updates to the PEP. However, users
MUST NOT use unsupported keys to avoid potential future conflicts.</p>
<p>A <a class="reference external" href="https://json-schema.org/">JSON schema</a> is included in the Appendix
of this PEP, to ease comprehension and validation of the metadata
format. This schema will be updated with each revision to the variant
metadata specification. The schema is available in
<a class="reference internal" href="appendix-variant-metadata-json-schema/#variant-json-schema"><span class="std std-ref">Appendix: JSON Schema for Variant Metadata</span></a>.</p>
<p>Ultimately, the variant metadata JSON schema SHOULD be served by
<a class="reference external" href="https://packaging.python.org/">packaging.python.org</a>.</p>
<section id="provider-information">
<h4><a class="toc-backref" href="#provider-information" role="doc-backlink">Provider information</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">providers</span></code> is a dictionary, the keys are namespaces, the values are
dictionaries with provider information. It specifies how to install and
use variant providers. A provider information dictionary MUST be
declared in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> for every variant namespace supported by
the package. It MUST be copied to <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> as-is, including
the data for providers that are not used in the particular wheel.</p>
<p>The use of provider information is described in the <a class="reference internal" href="#providers">Providers</a> and
<a class="reference internal" href="#provider-plugin-api">Provider plugin API</a> sections.</p>
<p>A provider information dictionary MAY contain the following keys:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">enable-if:</span> <span class="pre">str</span></code>: An <a class="reference external" href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/#dependency-specifiers-environment-markers" title="(in Python Packaging User Guide)"><span class="xref std std-ref">environment marker</span></a> defining when the plugin
should be used.</li>
<li><code class="docutils literal notranslate"><span class="pre">install-time:</span> <span class="pre">bool</span></code>: Whether this is an install-time provider.
Defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>. <code class="docutils literal notranslate"><span class="pre">false</span></code> means that it is an AoT provider
instead.</li>
<li><code class="docutils literal notranslate"><span class="pre">optional:</span> <span class="pre">bool</span></code>: Whether the provider is optional. Defaults
to <code class="docutils literal notranslate"><span class="pre">false</span></code>. If it is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the provider is
considered optional.</li>
<li><code class="docutils literal notranslate"><span class="pre">plugin-api:</span> <span class="pre">str</span></code>: The API endpoint for the plugin. If it is
specified, it MUST be an object reference as explained in the <a class="reference internal" href="#api-endpoint">API
endpoint</a> section. If it is missing, the package name from the first
dependency specifier in <code class="docutils literal notranslate"><span class="pre">requires</span></code> is used, after replacing all
<code class="docutils literal notranslate"><span class="pre">-</span></code> characters with <code class="docutils literal notranslate"><span class="pre">_</span></code> in the normalized package name.</li>
<li><code class="docutils literal notranslate"><span class="pre">requires:</span> <span class="pre">list[str]</span></code>: A list of zero or more package
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/#dependency-specifiers" title="(in Python Packaging User Guide)"><span class="xref std std-ref">dependency specifiers</span></a>, that are used to
install the provider plugin. If the dependency specifiers include
environment markers, these are evaluated against the environment where
the plugin is being installed and the requirements for which the
markers evaluate to false are filtered out. In that case, at least
one dependency MUST remain present in every possible environment.
Additionally, if <code class="docutils literal notranslate"><span class="pre">plugin-api</span></code> is not specified, the first dependency
present after filtering MUST always evaluate to the same API endpoint.</li>
</ul>
<p>All the fields are OPTIONAL, with the following exceptions:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">install-time</span></code> is true, the dictionary describes an install-time
provider and the <code class="docutils literal notranslate"><span class="pre">requires</span></code> key MUST be present and specify at
least one dependency.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">install-time</span></code> is false, it describes an AoT provider and the
<code class="docutils literal notranslate"><span class="pre">requires</span></code> key is OPTIONAL. In that case:<ol class="loweralpha simple">
<li>If <code class="docutils literal notranslate"><span class="pre">requires</span></code> is provided and non-empty, the provider dictionary
MUST reference an AoT provider plugin that will be queried at
build time to fill <code class="docutils literal notranslate"><span class="pre">static-properties</span></code>.</li>
<li>Otherwise, <code class="docutils literal notranslate"><span class="pre">static-properties</span></code> MUST be specified in
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>.</li>
</ol>
</li>
</ol>
</section>
<section id="default-priorities">
<h4><a class="toc-backref" href="#default-priorities" role="doc-backlink">Default priorities</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">default-priorities</span></code> dictionary controls the ordering of variants.
The exact algorithm is described in the <a class="reference internal" href="#variant-ordering">Variant ordering</a> section.</p>
<p>It has a single REQUIRED key:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">namespace:</span> <span class="pre">list[str]</span></code>: All namespaces used by the wheel variants,
ordered in decreasing priority. This list MUST have the same members
as the keys of the <code class="docutils literal notranslate"><span class="pre">providers</span></code> dictionary.</li>
</ul>
<p>It MAY have the following OPTIONAL keys:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">feature:</span> <span class="pre">dict[str,</span> <span class="pre">list[str]]</span></code>: A dictionary with namespaces as
keys, and ordered list of corresponding feature names as values. The
values in each list override the default ordering from the provider
output. They are listed from the highest priority to the lowest
priority. Features not present on the list are considered of lower
priority than those present, and their relative priority is defined by
the plugin.</li>
<li><code class="docutils literal notranslate"><span class="pre">property:</span> <span class="pre">dict[str,</span> <span class="pre">dict[str,</span> <span class="pre">list[str]]]</span></code>: A nested dictionary
with namespaces as first-level keys, feature names as second-level
keys and ordered lists of corresponding property values as
second-level values. The values present in the list override the
default ordering from the provider output. They are listed from the
the highest priority to the lowest priority. Properties not present on
the list are considered of lower priority than these present, and
their relative priority is defined by the plugin output.</li>
</ul>
</section>
<section id="static-properties">
<h4><a class="toc-backref" href="#static-properties" role="doc-backlink">Static properties</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">static-properties</span></code> dictionary specifies the supported properties
for AoT providers. It is a nested dictionary with namespaces as first
level keys, feature name as second level keys and ordered lists of
feature values as second level values.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file, the namespaces present in this dictionary
MUST correspond to all AoT providers without a
plugin (i.e. with <code class="docutils literal notranslate"><span class="pre">install-time</span></code> of <code class="docutils literal notranslate"><span class="pre">false</span></code> and no or empty
<code class="docutils literal notranslate"><span class="pre">requires</span></code>). When building a wheel, the build backend MUST query the
AoT provider plugins (i.e. these with <code class="docutils literal notranslate"><span class="pre">install-time</span></code> being <code class="docutils literal notranslate"><span class="pre">false</span></code>
and non-empty <code class="docutils literal notranslate"><span class="pre">requires</span></code>) to obtain supported properties and embed
them into the dictionary. Therefore, the dictionary in <code class="docutils literal notranslate"><span class="pre">variant.json</span></code>
and <code class="docutils literal notranslate"><span class="pre">*-variants.json</span></code> MUST contain namespaces for all AoT providers
(i.e. all providers with <code class="docutils literal notranslate"><span class="pre">install-time</span></code> being <code class="docutils literal notranslate"><span class="pre">false</span></code>).</p>
<p>Since TOML and JSON dictionaries are unsorted, so are the features in
the <code class="docutils literal notranslate"><span class="pre">static-properties</span></code> dictionary. If more than one feature is
specified for a namespace, then the order for all features MUST be
specified in <code class="docutils literal notranslate"><span class="pre">default-priorities.feature.{namespace}</span></code>. If an AoT
plugin is used to fill <code class="docutils literal notranslate"><span class="pre">static-properties</span></code>, then the features not
already in the list in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> MUST be appended to it.</p>
<p>The list of values is ordered from the most preferred to the least
preferred, same as the lists returned by <code class="docutils literal notranslate"><span class="pre">get_supported_configs()</span></code>
plugin API call (as defined in <a class="reference internal" href="#plugin-interface">plugin interface</a>). The
<code class="docutils literal notranslate"><span class="pre">default-priorities.property</span></code> dict can be used to override the
property ordering.</p>
</section>
<section id="variants">
<h4><a class="toc-backref" href="#variants" role="doc-backlink">Variants</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">variants</span></code> dictionary is used in <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> to indicate the
variant that the wheel was built for, and in <code class="docutils literal notranslate"><span class="pre">*-variants.json</span></code> to
indicate all the wheel variants available. It’s a 3-level dictionary
listing all properties per variant label: The first level keys are
variant labels, the second level keys are namespaces, the third level
are feature names, and the third level values are lists of feature
values.</p>
</section>
<section id="pyproject-toml-variant-project-level-data-table">
<h4><a class="toc-backref" href="#pyproject-toml-variant-project-level-data-table" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>: variant project-level data table</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file is the standard project configuration file
as defined in <a class="reference external" href="https://packaging.python.org/en/latest/specifications/pyproject-toml/" title="(in Python Packaging User Guide)"><span>pyproject.toml specification</span></a>. The
variant metadata MUST be rooted at a top-level table named <code class="docutils literal notranslate"><span class="pre">variant</span></code>.
It MUST NOT specify the <code class="docutils literal notranslate"><span class="pre">variants</span></code> dictionary. It is used by build
backends to build variant wheels.</p>
<p>Example Structure:</p>
<div class="highlight-toml notranslate"><div class="highlight"><pre><span></span><span class="k">[variant.default-priorities]</span>
<span class="c1"># prefer CPU features over BLAS/LAPACK variants</span>
<span class="n">namespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;x86_64&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;aarch64&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;blas_lapack&quot;</span><span class="p">]</span>

<span class="c1"># prefer aarch64 version and x86_64 level features over other features</span>
<span class="c1"># (specific CPU extensions like &quot;sse4.1&quot;)</span>
<span class="n">feature</span><span class="p">.</span><span class="n">aarch64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span>
<span class="n">feature</span><span class="p">.</span><span class="n">x86_64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;level&quot;</span><span class="p">]</span>

<span class="c1"># prefer x86-64-v3 and then older (even if CPU is newer)</span>
<span class="n">property</span><span class="p">.</span><span class="n">x86_64</span><span class="p">.</span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;v3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;v2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;v1&quot;</span><span class="p">]</span>

<span class="k">[variant.providers.aarch64]</span>
<span class="c1"># example using different package based on Python version</span>
<span class="n">requires</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">   </span><span class="s2">&quot;provider-variant-aarch64 &gt;=0.0.1; python_version &gt;= &#39;3.12&#39;&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="s2">&quot;legacy-provider-variant-aarch64 &gt;=0.0.1; python_version &lt; &#39;3.12&#39;&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="c1"># use only on aarch64/arm machines</span>
<span class="n">enable-if</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;platform_machine == &#39;aarch64&#39; or &#39;arm&#39; in platform_machine&quot;</span>
<span class="n">plugin-api</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;provider_variant_aarch64.plugin:AArch64Plugin&quot;</span>

<span class="k">[variant.providers.x86_64]</span>
<span class="n">requires</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;provider-variant-x86-64 &gt;=0.0.1&quot;</span><span class="p">]</span>
<span class="c1"># use only on x86_64 machines</span>
<span class="n">enable-if</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;platform_machine == &#39;x86_64&#39; or platform_machine == &#39;AMD64&#39;&quot;</span>
<span class="n">plugin-api</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;provider_variant_x86_64.plugin:X8664Plugin&quot;</span>

<span class="k">[variant.providers.blas_lapack]</span>
<span class="c1"># plugin-api inferred from requires</span>
<span class="n">requires</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;blas-lapack-variant-provider&quot;</span><span class="p">]</span>
<span class="c1"># plugin used only when building package, properties will be inlined</span>
<span class="c1"># into variant.json</span>
<span class="n">install-time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span>
</pre></div>
</div>
</section>
<section id="dist-info-variant-json-the-packaged-variant-metadata-file">
<h4><a class="toc-backref" href="#dist-info-variant-json-the-packaged-variant-metadata-file" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">*.dist-info/variant.json</span></code>: the packaged variant metadata file</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> file MUST be present in the <code class="docutils literal notranslate"><span class="pre">*.dist-info/</span></code>
directory of a built variant wheel. It is serialized into JSON, with the
variant metadata dictionary being the top object. It MUST include all
the variant metadata present in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>, copied as indicated
in the individual key sections. In addition to that, it MUST contain:</p>
<ul class="simple">
<li>a <code class="docutils literal notranslate"><span class="pre">$schema</span></code> key whose value is the URL corresponding to the schema
file supplied in the appendix of this PEP. The URL contains the
version of the format, and a new version MUST be added to the appendix
whenever the format changes in the future,</li>
<li>a <code class="docutils literal notranslate"><span class="pre">variants</span></code> object listing exactly one variant - the variant
provided by the wheel.</li>
</ul>
<p>The variant.json file corresponding to the wheel built from the example
pyproject.toml file for x86-64-v3 would look like:</p>
<div class="highlight-json5 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The schema URL will be replaced with the final URL on packaging.python.org</span>
<span class="w">  </span><span class="nv">&quot;$schema&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https://variants-schema.wheelnext.dev/v0.0.3.json&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nv">&quot;default-priorities&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="nv">&quot;feature&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;aarch64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;version&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;level&quot;</span><span class="p">]</span>
<span class="w">     </span><span class="p">},</span>
<span class="w">     </span><span class="nv">&quot;namespace&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;x86_64&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aarch64&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;blas_lapack&quot;</span><span class="p">],</span>
<span class="w">     </span><span class="nv">&quot;property&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;level&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;v3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;v2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;v1&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;providers&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="nv">&quot;aarch64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;enable-if&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;platform_machine == &#39;aarch64&#39; or &#39;arm&#39; in platform_machine&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nv">&quot;plugin-api&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;provider_variant_aarch64.plugin:AArch64Plugin&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nv">&quot;requires&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">           </span><span class="s">&quot;provider-variant-aarch64 &gt;=0.0.1; python_version &gt;= &#39;3.12&#39;&quot;</span><span class="p">,</span>
<span class="w">           </span><span class="s">&quot;legacy-provider-variant-aarch64 &gt;=0.0.1; python_version &lt; &#39;3.12&#39;&quot;</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">     </span><span class="p">},</span>
<span class="w">     </span><span class="nv">&quot;blas_lapack&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;install-time&quot;</span><span class="p">:</span><span class="w"> </span><span class="k">false</span><span class="p">,</span>
<span class="w">        </span><span class="nv">&quot;requires&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;blas-lapack-variant-provider&quot;</span><span class="p">]</span>
<span class="w">     </span><span class="p">},</span>
<span class="w">     </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;enable-if&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;platform_machine == &#39;x86_64&#39; or platform_machine == &#39;AMD64&#39;&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nv">&quot;plugin-api&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;provider_variant_x86_64.plugin:X8664Plugin&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nv">&quot;requires&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;provider-variant-x86-64 &gt;=0.0.1&quot;</span><span class="p">]</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;static-properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="nv">&quot;blas_lapack&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;provider&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;accelerate&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;openblas&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mkl&quot;</span><span class="p">]</span>
<span class="w">     </span><span class="p">},</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;variants&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// always a single entry, expressing the variant properties of the wheel</span>
<span class="w">     </span><span class="nv">&quot;x8664v3_openblas&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;blas_lapack&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;provider&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;openblas&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;level&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;v3&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="name-version-variants-json-the-index-level-variant-metadata-file">
<h4><a class="toc-backref" href="#name-version-variants-json-the-index-level-variant-metadata-file" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code>: the index level variant metadata file</a></h4>
<p>For every package version that includes at least one variant wheel,
there MUST exist a corresponding <code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code>
file, hosted and served by the package index. The <code class="docutils literal notranslate"><span class="pre">{name}</span></code> and
<code class="docutils literal notranslate"><span class="pre">{version}</span></code> placeholders correspond to the package name and version,
normalized according to the same rules as wheel files, as found in the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/#wheel-file-name-spec" title="(in Python Packaging User Guide)"><span>File name convention</span></a> of the Binary Distribution Format
specification. The link to this file MUST be present on all index pages
where the variant wheels are linked. It is presented in the same simple
repository format as source distribution and wheel links in the index,
including an (OPTIONAL) hash.</p>
<p>This file uses the same structure as <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> described above,
except that the variants object MUST list all variants available on the
package index for the package version in question. It is RECOMMENDED
that tools enforce the same contents of the <code class="docutils literal notranslate"><span class="pre">default-priorities</span></code>,
<code class="docutils literal notranslate"><span class="pre">providers</span></code> and <code class="docutils literal notranslate"><span class="pre">static-properties</span></code> sections for all variants listed
in the file, though careful merging is possible, as long as no
conflicting information is introduced, and the resolution results within
a subset of variants do not change.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">foo-1.2.3-variants.json</span></code> corresponding to the package with two
wheel variants, one of them listed in the previous example, would look
like:</p>
<div class="highlight-json5 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The schema URL will be replaced with the final URL on packaging.python.org</span>
<span class="w">  </span><span class="nv">&quot;$schema&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https://variants-schema.wheelnext.dev/v0.0.3.json&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nv">&quot;default-priorities&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// identical to above</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;providers&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// identical to above</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;static-properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// identical to above</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nv">&quot;variants&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// all available wheel variants</span>
<span class="w">     </span><span class="nv">&quot;x8664v3_openblas&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;blas_lapack&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;provider&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;openblas&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;level&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;v3&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">     </span><span class="p">},</span>
<span class="w">     </span><span class="nv">&quot;x8664v4_mkl&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nv">&quot;blas_lapack&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;provider&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;mkl&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nv">&quot;x86_64&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="nv">&quot;level&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;v4&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="variant-ordering">
<h3><a class="toc-backref" href="#variant-ordering" role="doc-backlink">Variant ordering</a></h3>
<p>To determine which variant wheel to install when multiple wheels are
compatible, variant wheels MUST be ordered by their variant properties.</p>
<p>For the purpose of ordering, variant properties are grouped into
features, and features into namespaces. The ordering MUST be equivalent
to the following algorithm:</p>
<ol class="arabic">
<li>Construct the ordered list of namespaces by copying the value of the
<code class="docutils literal notranslate"><span class="pre">default-priorities.namespace</span></code> key.</li>
<li>For every namespace:<ol class="lowerroman simple">
<li>Construct the initial ordered list of feature names by copying the
value of the respective <code class="docutils literal notranslate"><span class="pre">default-priorities.feature.{namespace}</span></code>
key.</li>
<li>Obtain the supported feature names from the provider, in order.
For every feature name that is not present in the constructed
list, append it to the end.</li>
</ol>
<p>After this step, a list of ordered feature names is available for
every namespace.</p>
</li>
<li>For every feature:<ol class="lowerroman simple">
<li>Construct the initial ordered list of values by copying the value
of the respective
<code class="docutils literal notranslate"><span class="pre">default-priorities.property.{namespace}.{feature_name}</span></code> key.</li>
<li>Obtain the supported values from the provider, in order. For
every value that is not present in the constructed list, append
it to the end.</li>
</ol>
<p>After this step, a list of ordered property values is available for
every feature.</p>
</li>
<li>For every variant property present in at least one of the compatible
variant wheels, construct a sort key that is a 3-tuple consisting of
its namespace, feature name and feature value indices in the
respective ordered lists.</li>
<li>For every compatible variant wheel, order its properties by their
sort keys, in ascending order.</li>
<li>To order variant wheels, compare their sorted properties. If the
properties at the first position are different, the variant with the
lower 3-tuple of the respective property is sorted earlier. If they
are the same, compare the properties at the second position, and so
on, until either a tie-breaker is found or the list of properties of
one wheel is exhausted. In the latter case, the variant with more
properties is sorted earlier.</li>
</ol>
<p>After this process, the variant wheels are sorted from the most
preferred to the least preferred. The null variant naturally sorts after
all the other variants, and the non-variant wheel MUST be sorted after
the null variant. Multiple wheels with the same variant set (and
multiple non-variant wheels) MUST then be ordered according to their
platform compatibility tags.</p>
<p>Alternatively, the sort algorithm for variant wheels could be described
using the following pseudocode. For simplicity, this code does not
account for non-variant wheels or tags.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_supported_feature_names</span><span class="p">(</span><span class="n">namespace</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get feature names from plugin&#39;s get_supported_configs()&quot;&quot;&quot;</span>
    <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_supported_feature_values</span><span class="p">(</span><span class="n">namespace</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">feature_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get feature values from plugin&#39;s get_supported_configs()&quot;&quot;&quot;</span>
    <span class="o">...</span>


<span class="c1"># default-priorities dict from variant metadata</span>
<span class="n">default_priorities</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;namespace&quot;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">],</span>  <span class="c1"># : list[str]</span>
    <span class="s2">&quot;feature&quot;</span><span class="p">:</span> <span class="p">{</span><span class="o">...</span><span class="p">},</span>    <span class="c1"># : dict[str, list[str]]</span>
    <span class="s2">&quot;property&quot;</span><span class="p">:</span> <span class="p">{</span><span class="o">...</span><span class="p">},</span>   <span class="c1"># : dict[str, dict[str, list[str]]]</span>
<span class="p">}</span>


<span class="c1"># 1. Construct the ordered list of namespaces.</span>
<span class="n">namespace_order</span> <span class="o">=</span> <span class="n">default_priorities</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span>
<span class="n">feature_order</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">value_order</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">namespace</span> <span class="ow">in</span> <span class="n">namespace_order</span><span class="p">:</span>
    <span class="c1"># 2. Construct the ordered lists of feature names.</span>
    <span class="n">feature_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_priorities</span><span class="p">[</span><span class="s2">&quot;feature&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">feature_name</span> <span class="ow">in</span> <span class="n">get_supported_feature_names</span><span class="p">(</span><span class="n">namespace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">feature_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]:</span>
            <span class="n">feature_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span>

   <span class="n">value_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="k">for</span> <span class="n">feature_name</span> <span class="ow">in</span> <span class="n">feature_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]:</span>
        <span class="c1"># 3. Construct the ordered lists of feature values.</span>
        <span class="n">value_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">][</span><span class="n">feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">default_priorities</span><span class="p">[</span><span class="s2">&quot;property&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feature_name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">feature_value</span> <span class="ow">in</span> <span class="n">get_supported_feature_values</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">feature_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">feature_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">][</span><span class="n">feature_name</span><span class="p">]:</span>
                <span class="n">value_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">][</span><span class="n">feature_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">property_key</span><span class="p">(</span><span class="n">prop</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a sort key for variant property (akin to step 4.)&quot;&quot;&quot;</span>
    <span class="n">namespace</span><span class="p">,</span> <span class="n">feature_name</span><span class="p">,</span> <span class="n">feature_value</span> <span class="o">=</span> <span class="n">prop</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">namespace_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">namespace</span><span class="p">),</span>
        <span class="n">feature_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">feature_name</span><span class="p">),</span>
        <span class="n">value_order</span><span class="p">[</span><span class="n">namespace</span><span class="p">][</span><span class="n">feature_name</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">feature_value</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">VariantWheel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example class exposing properties of a variant wheel&quot;&quot;&quot;</span>
    <span class="n">properties</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variant comparison function for sorting (akin to step 6.)&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">self_prop</span><span class="p">,</span> <span class="n">other_prop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">properties</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">self_prop</span> <span class="o">!=</span> <span class="n">other_prop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">property_key</span><span class="p">(</span><span class="n">self_prop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">property_key</span><span class="p">(</span><span class="n">other_prop</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>


<span class="c1"># A list of variant wheels to sort.</span>
<span class="n">wheels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">VariantWheel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>


<span class="k">for</span> <span class="n">wheel</span> <span class="ow">in</span> <span class="n">wheels</span><span class="p">:</span>
    <span class="c1"># 5. Order variant wheel properties by their sort keys.</span>
    <span class="n">wheel</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">property_key</span><span class="p">)</span>
<span class="c1"># 6. Order variant wheels by comparing their sorted properties</span>
<span class="c1"># (see VariantWheel.__lt__())</span>
<span class="n">wheels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="integration-with-pylock-toml">
<h3><a class="toc-backref" href="#integration-with-pylock-toml" role="doc-backlink">Integration with <code class="docutils literal notranslate"><span class="pre">pylock.toml</span></code></a></h3>
<p>The following section is added to the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/pylock-toml/" title="(in Python Packaging User Guide)"><span>pylock.toml Specification</span></a>:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="nt">_pylock-packages-variants-json:</span>

<span class="gh">``[packages.variants-json]``</span>
<span class="gh">----------------------------</span>

<span class="m">-</span> <span class="gs">**Type**</span>: table
<span class="m">-</span> <span class="gs">**Required?**</span>: no; requires that <span class="na">:ref:</span><span class="nv">`pylock-packages-wheels`</span> is used,
 mutually-exclusive with <span class="na">:ref:</span><span class="nv">`pylock-packages-vcs`</span>,
 <span class="na">:ref:</span><span class="nv">`pylock-packages-directory`</span>, and <span class="na">:ref:</span><span class="nv">`pylock-packages-archive`</span>.
<span class="m">-</span> <span class="gs">**Inspiration**</span>: uv_
<span class="m">-</span> The URL or path to the <span class="s">``variants.json``</span> file.
<span class="m">-</span> Only used if the project uses <span class="na">:ref:</span><span class="nv">`wheel variants &lt;wheel-variants&gt;`</span>.

<span class="p">..</span> <span class="nt">_pylock-packages-variants-json-url:</span>

<span class="gh">``packages.variants-json.url``</span>
<span class="gh">&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;</span>

See <span class="na">:ref:</span><span class="nv">`pylock-packages-archive-url`</span>.

<span class="p">..</span> <span class="nt">_pylock-packages-variants-json-path:</span>

<span class="gh">``packages.variants-json.path``</span>
<span class="gh">&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;</span>

See <span class="na">:ref:</span><span class="nv">`pylock-packages-archive-path`</span>.

<span class="p">..</span> <span class="nt">_pylock-packages-variants-json-hashes:</span>

<span class="gh">``packages.variants-json.hashes``</span>
<span class="gh">&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;</span>

See <span class="na">:ref:</span><span class="nv">`pylock-packages-archive-hashes`</span>.
</pre></div>
</div>
<p>If there is a <code class="docutils literal notranslate"><span class="pre">[packages.variants-json]</span></code> section, the installer SHOULD
resolve variants to select the best wheel file.</p>
</section>
<section id="provider-plugin-api">
<h3><a class="toc-backref" href="#provider-plugin-api" role="doc-backlink">Provider plugin API</a></h3>
<section id="high-level-design">
<h4><a class="toc-backref" href="#high-level-design" role="doc-backlink">High level design</a></h4>
<p>Every provider plugin MUST operate within a single namespace. This
namespace is used as a unique key for all plugin-related operations. All
the properties defined by the plugin are bound within the plugin’s
namespace, and the plugin defines all the valid feature names and values
within that namespace.</p>
<p>Provider plugin authors SHOULD choose namespaces that can be clearly
associated with the project they represent, and avoid namespaces that
refer to other projects or generic terms that could lead to naming
conflicts in the future.</p>
<p>All variants published on a single index for a specific package version
MUST use the same provider for a given namespace. Attempting to load
more than one plugin for the same namespace in the same release version
MUST result in a fatal error. While multiple plugins for the same
namespace MAY exist across different packages or release versions (such
as when a plugin is forked due to being unmaintained), they are mutually
exclusive within any single release version.</p>
<p>To make it easier to discover and install plugins, they SHOULD be
published in the same indexes that the packages using them. In
particular, packages published to PyPI MUST NOT rely on plugins that
need to be installed from other indexes.</p>
<p>Except for namespaces reserved as part of this PEP, installable Python
packages MUST be provided for plugins. However, as noted in the
<a class="reference internal" href="#providers">Providers</a> section, these plugins can also be reimplemented by tools
needing them. In the latter case, the resulting reimplementation does
not need to follow the API defined in this section.</p>
<p>A plugin implemented as Python package exposes two kinds of objects at a
specified API endpoint:</p>
<ol class="loweralpha">
<li>attributes that return a specific value after being accessed via:<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{API endpoint}.{attribute name}
</pre></div>
</div>
</li>
<li>callables that are called via:<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{API endpoint}.{callable name}({arguments}...)
</pre></div>
</div>
</li>
</ol>
<p>These can be implemented either as modules, or classes with class
methods or static methods. The specifics are provided in the subsequent
sections.</p>
</section>
<section id="api-endpoint">
<h4><a class="toc-backref" href="#api-endpoint" role="doc-backlink">API endpoint</a></h4>
<p>The location of the plugin code is called an “API endpoint”, and it is
expressed using the object reference notation following the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/entry-points/" title="(in Python Packaging User Guide)"><span>Entry points specification</span></a>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{import_path}(:{object_path})?
</pre></div>
</div>
<p>An API endpoint specification is equivalent to the following Python
pseudocode:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="p">{</span><span class="n">import_path</span><span class="p">}</span>

<span class="k">if</span> <span class="s2">&quot;</span><span class="si">{object_path}</span><span class="s2">&quot;</span><span class="p">:</span>
    <span class="n">plugin</span> <span class="o">=</span> <span class="p">{</span><span class="n">import_path</span><span class="p">}</span><span class="o">.</span><span class="p">{</span><span class="n">object_path</span><span class="p">}</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">plugin</span> <span class="o">=</span> <span class="p">{</span><span class="n">import_path</span><span class="p">}</span>
</pre></div>
</div>
<p>API endpoints are used in two contexts:</p>
<ol class="loweralpha simple">
<li>in the <code class="docutils literal notranslate"><span class="pre">plugin-api</span></code> key of variant metadata, either explicitly or
inferred from the package name in the <code class="docutils literal notranslate"><span class="pre">requires</span></code> key. This is the
primary method of using the plugin when building and installing
wheels.</li>
<li>as the value of an installed entry point in the <code class="docutils literal notranslate"><span class="pre">variant_plugins</span></code>
group. The name of said entry point is insignificant. This is
OPTIONAL but RECOMMENDED, as it permits variant-related utilities to
discover variant plugins installed to the user’s environment.</li>
</ol>
</section>
<section id="variant-feature-config-class">
<h4><a class="toc-backref" href="#variant-feature-config-class" role="doc-backlink">Variant feature config class</a></h4>
<p>The variant feature config class is used as a return value in plugin API
functions. It defines a single variant feature, along with a list of
possible values. Depending on the context, the order of values MAY be
significant. It is defined using the following protocol:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span>


<span class="k">class</span><span class="w"> </span><span class="nc">VariantFeatureConfigType</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Feature name&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multi_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does this property allow multiple values per variant?&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of values, possibly ordered from most preferred to least&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
<p>A “variant feature config” MUST provide the following properties or
attributes:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">str</span></code> specifying the feature name.</li>
<li><code class="docutils literal notranslate"><span class="pre">multi_value:</span> <span class="pre">bool</span></code> specifying whether the feature is allowed to
have multiple corresponding values within a single variant wheel. If
it is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then it is an error to specify multiple values for
the feature.</li>
<li><code class="docutils literal notranslate"><span class="pre">values:</span> <span class="pre">list[str]</span></code> specifying feature values. In contexts where the
order is significant, the values MUST be ordered from the most
preferred to the least preferred.</li>
</ul>
<p>All features are interpreted as being within the plugin’s namespace.</p>
</section>
<section id="plugin-interface">
<h4><a class="toc-backref" href="#plugin-interface" role="doc-backlink">Plugin interface</a></h4>
<p>The plugin interface MUST follow the following protocol:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span>


<span class="k">class</span><span class="w"> </span><span class="nc">PluginType</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="c1"># Note: properties are used here for docstring purposes, these</span>
    <span class="c1"># must be actually implemented as attributes.</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The provider namespace&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_aot_plugin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is this plugin valid for `install-time = false`?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_configs</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">VariantFeatureConfigType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all valid configs for the plugin&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supported_configs</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">VariantFeatureConfigType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get supported configs for the current system&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
<p>The plugin interface MUST define the following attributes:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">namespace:</span> <span class="pre">str</span></code> specifying the plugin’s namespace.</li>
<li><code class="docutils literal notranslate"><span class="pre">is_aot_plugin:</span> <span class="pre">bool</span></code> indicating whether the plugin is a valid AoT
plugin. If that is the case, <code class="docutils literal notranslate"><span class="pre">get_supported_configs()</span></code> MUST always
return the same value as <code class="docutils literal notranslate"><span class="pre">get_all_configs()</span></code> (modulo ordering),
which MUST be a fixed list independent of the platform on which the
plugin is running. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code> if unspecified.</li>
</ul>
<p>The plugin interface MUST provide the following functions:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">get_all_config()</span> <span class="pre">-&gt;</span> <span class="pre">list[VariantFeatureConfigType]</span></code> that returns a
list of “variant feature configs” describing all valid variant
features within the plugin’s namespace, along with all their permitted
values. The ordering of the lists is insignificant here. A particular
plugin version MUST always return the same value (modulo ordering),
irrespective of any runtime conditions.</li>
<li><code class="docutils literal notranslate"><span class="pre">get_supported_configs()</span> <span class="pre">-&gt;</span> <span class="pre">list[VariantFeatureConfigType]</span></code> that
returns a list of “variant feature configs” describing the variant
features within the plugin’s namespace that are compatible with this
particular system, along with their values that are supported. The
variant feature and value lists MUST be ordered from the most
preferred to the least preferred, as they affect <a class="reference internal" href="#variant-ordering">variant
ordering</a>.</li>
</ul>
<p>The value returned by <code class="docutils literal notranslate"><span class="pre">get_supported_configs()</span></code> MUST be a subset of
the feature names and values returned by <code class="docutils literal notranslate"><span class="pre">get_all_configs()</span></code> (modulo
ordering).</p>
</section>
<section id="example-implementation">
<h4><a class="toc-backref" href="#example-implementation" role="doc-backlink">Example implementation</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VariantFeatureConfig</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">multi_value</span><span class="p">:</span> <span class="nb">bool</span>


<span class="c1"># internal -- provided for illustrative purpose</span>
<span class="n">_MAX_VERSION</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">_ALL_GPUS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;narf&quot;</span><span class="p">,</span> <span class="s2">&quot;poit&quot;</span><span class="p">,</span> <span class="s2">&quot;zort&quot;</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_current_version</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns currently installed runtime version&quot;&quot;&quot;</span>
    <span class="o">...</span>  <span class="c1"># implementation not provided</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_gpu_available</span><span class="p">(</span><span class="n">codename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is specified GPU installed?&quot;&quot;&quot;</span>
    <span class="o">...</span>  <span class="c1"># implementation not provided</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyPlugin</span><span class="p">:</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;example&quot;</span>

    <span class="c1"># optional, defaults to False</span>
    <span class="n">is_aot_plugin</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># all valid properties</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_configs</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">VariantFeatureConfig</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">VariantFeatureConfig</span><span class="p">(</span>
                <span class="c1"># example :: gpu -- multi-valued, since the package</span>
                <span class="c1"># can target multiple GPUs</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span>
                <span class="c1"># [narf, poit, zort]</span>
                <span class="n">values</span><span class="o">=</span><span class="n">_ALL_GPUS</span><span class="p">,</span>
                <span class="n">multi_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">VariantFeatureConfig</span><span class="p">(</span>
                <span class="c1"># example :: min_version -- single-valued, since</span>
                <span class="c1"># there is always one minimum</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;min_version&quot;</span><span class="p">,</span>
                <span class="c1"># [1, 2, 3, 4] (order doesn&#39;t matter)</span>
                <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_MAX_VERSION</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                <span class="n">multi_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">]</span>

    <span class="c1"># properties compatible with the system</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supported_configs</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">VariantFeatureConfig</span><span class="p">]:</span>
        <span class="n">current_version</span> <span class="o">=</span> <span class="n">_get_current_version</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">current_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no runtime found, system not supported at all</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">VariantFeatureConfig</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;min_version&quot;</span><span class="p">,</span>
                <span class="c1"># [current, current - 1, ..., 1]</span>
                <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">current_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                <span class="n">multi_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">VariantFeatureConfig</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span>
                <span class="c1"># this may be empty if no GPUs are supported --</span>
                <span class="c1"># &#39;example :: gpu feature&#39; is not supported then;</span>
                <span class="c1"># but wheels with no GPU-specific code and only</span>
                <span class="c1"># &#39;example :: min_version&#39; could still be installed</span>
                <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_ALL_GPUS</span> <span class="k">if</span> <span class="n">_is_gpu_available</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span>
                <span class="n">multi_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">]</span>
</pre></div>
</div>
</section>
<section id="future-extensions">
<h4><a class="toc-backref" href="#future-extensions" role="doc-backlink">Future extensions</a></h4>
<p>The future versions of this specification, as well as third-party
extensions MAY introduce additional properties and methods on the plugin
instances. The implementations SHOULD ignore additional attributes.</p>
<p>For best compatibility, all private attributes SHOULD be prefixed with
an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) character to avoid incidental conflicts with
future extensions.</p>
</section>
</section>
<section id="build-backends">
<h3><a class="toc-backref" href="#build-backends" role="doc-backlink">Build backends</a></h3>
<p>As a build backend can’t determine whether the frontend supports variant
wheels or not, <a class="pep reference internal" href="../pep-0517/" title="PEP 517 – A build-system independent format for source trees">PEP 517</a> and <a class="pep reference internal" href="../pep-0660/" title="PEP 660 – Editable installs for pyproject.toml based builds (wheel based)">PEP 660</a> hooks MUST build non-variant
wheels by default. Build backends MAY provide ways to request variant
builds. This specification does not define any specific configuration.</p>
<p>When building variant wheels, build backends MUST verify variant
metadata for correctness, and they MUST NOT emit wheels with
nonconformant <code class="docutils literal notranslate"><span class="pre">variant.json</span></code> files. They SHOULD also query providers
to determine whether variant properties requested by the user are valid,
though they MAY permit skipping this verification and therefore emitting
variant wheels with potentially unknown properties.</p>
</section>
<section id="variant-environment-markers">
<h3><a class="toc-backref" href="#variant-environment-markers" role="doc-backlink">Variant environment markers</a></h3>
<p>Four new <a class="reference external" href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/#dependency-specifiers-environment-markers" title="(in Python Packaging User Guide)"><span class="xref std std-ref">environment markers</span></a> are introduced in
dependency specifications:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">variant_namespaces</span></code> corresponding to the set of namespaces of all
the variant properties that the wheel variant was built for.</li>
<li><code class="docutils literal notranslate"><span class="pre">variant_features</span></code> corresponding to the set of
<code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">::</span> <span class="pre">feature</span></code> pairs of all the variant properties that the
wheel variant was built for.</li>
<li><code class="docutils literal notranslate"><span class="pre">variant_properties</span></code> corresponding to the set of
<code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">::</span> <span class="pre">feature</span> <span class="pre">::</span> <span class="pre">value</span></code> tuples of all the variant
properties that the wheel variant was built for.</li>
<li><code class="docutils literal notranslate"><span class="pre">variant_label</span></code> corresponding to the exact variant label that the
wheel was built with. For the non-variant wheel, it is an empty
string.</li>
</ol>
<p>The markers evaluating to sets of strings MUST be matched via the <code class="docutils literal notranslate"><span class="pre">in</span></code>
or <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> operator, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># satisfied by any &quot;foo :: * :: *&quot; property</span>
<span class="n">dep1</span><span class="p">;</span> <span class="s2">&quot;foo&quot;</span> <span class="ow">in</span> <span class="n">variant_namespaces</span>
<span class="c1"># satisfied by any &quot;foo :: bar :: *&quot; property</span>
<span class="n">dep2</span><span class="p">;</span> <span class="s2">&quot;foo :: bar&quot;</span> <span class="ow">in</span> <span class="n">variant_features</span>
<span class="c1"># satisfied only by &quot;foo :: bar :: baz&quot; property</span>
<span class="n">dep3</span><span class="p">;</span> <span class="s2">&quot;foo :: bar :: baz&quot;</span> <span class="ow">in</span> <span class="n">variant_properties</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">variant_label</span></code> marker is a plain string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># satisfied by the variant &quot;foobar&quot;</span>
<span class="n">dep4</span><span class="p">;</span> <span class="n">variant_label</span> <span class="o">==</span> <span class="s2">&quot;foobar&quot;</span>
<span class="c1"># satisfied by any wheel other other than the null variant</span>
<span class="c1"># (including the non-variant wheel)</span>
<span class="n">dep5</span><span class="p">;</span> <span class="n">variant_label</span> <span class="o">!=</span> <span class="s2">&quot;null&quot;</span>
<span class="c1"># satisfied by the non-variant wheel</span>
<span class="n">dep6</span><span class="p">;</span> <span class="n">variant_label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>Implementations MUST ignore differences in whitespace while matching the
features and properties.</p>
<p>Variant marker expressions MUST be evaluated against the variant
properties stored in the wheel being installed, not against the current
output of the provider plugins. If a non-variant wheel was selected or
built, all variant markers evaluate to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</section>
<section id="abi-dependency-variant-namespace-optional">
<h3><a class="toc-backref" href="#abi-dependency-variant-namespace-optional" role="doc-backlink">ABI Dependency Variant Namespace (Optional)</a></h3>
<p>This section describes an <strong>OPTIONAL</strong> extension to the wheel variant
specification. Tools that choose to implement this feature MUST follow
this specification. Tools that do not implement this feature MUST treat
the variants using it as incompatible, and SHOULD inform users when such
wheels are skipped.</p>
<p>The variant namespace <code class="docutils literal notranslate"><span class="pre">abi_dependency</span></code> is reserved for expressing that
different builds of the same version of a package are compatible with
different versions or version ranges of a dependency. This namespace
MUST NOT be used by any variant provider plugin, it MUST NOT be listed
in <code class="docutils literal notranslate"><span class="pre">providers</span></code> metadata, and can only appear in a built wheel variant
property.</p>
<p>Within this namespace, zero or more properties can be used to express
compatible dependency versions. For each property, the feature name MUST
be the <a class="reference external" href="https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization" title="(in Python Packaging User Guide)"><span class="xref std std-ref">normalized name</span></a> of the
dependency, whereas the value MUST be a valid release segment of
a public version identifier, as defined by the
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/version-specifiers/" title="(in Python Packaging User Guide)"><span>Version specifiers</span></a> specification.
It MUST contain up to three version components, that are matched against
the installed version same as the <code class="docutils literal notranslate"><span class="pre">=={value}.*</span></code> specifier. Notably,
trailing zeroes match versions with fewer components (e.g. <code class="docutils literal notranslate"><span class="pre">2.0</span></code>
matches release <code class="docutils literal notranslate"><span class="pre">2</span></code> but not <code class="docutils literal notranslate"><span class="pre">2.1</span></code>). This also implies that the
property values have different semantics than PEP 440 versions, in
particular <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">2.0</span></code> and <code class="docutils literal notranslate"><span class="pre">2.0.0</span></code> represent different ranges.</p>
<p>Versions with nonzero epoch are not supported.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Variant Property</th>
<th class="head">Matching Rule</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">torch==2.*</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2.9</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">torch==2.9.*</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">abi_dependency</span> <span class="pre">::</span> <span class="pre">torch</span> <span class="pre">::</span> <span class="pre">2.8.0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">torch==2.8.0.*</span></code></td>
</tr>
</tbody>
</table>
<p>Multiple variant properties with the same feature name can be used to
indicate wheels compatible with multiple providing package versions,
e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>abi_dependency :: torch :: 2.8.0
abi_dependency :: torch :: 2.9.0
</pre></div>
</div>
<p>This means the wheel is compatible with both PyTorch 2.8.0 and 2.9.0.</p>
</section>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to teach this</a></h2>
<section id="python-package-users">
<h3><a class="toc-backref" href="#python-package-users" role="doc-backlink">Python package users</a></h3>
<p>The primary source of information for Python package users should be
installer documentation, supplemented by helpful informational messages
from command-line interface, and tutorials. Users without special needs
should not require any special variant awareness. Advanced users would
specifically need documentation on (provided the installer in question
implements these features):</p>
<ul class="simple">
<li>enabling untrusted provider plugins and the security implications of
that</li>
<li>controlling provider usage, in particular enabling optional providers,
disabling undesirable plugins or disabling variant usage in general</li>
<li>explicitly selecting variants, as well as controlling variant
selection process</li>
<li>configuring variant selection for remote deployment targets, for
example using a static file generated on the target</li>
</ul>
<p>The installer documentation may also be supplemented by documentation
specific to Python projects, in particular their installation
instructions.</p>
<p>For the transition period, during which some package managers do and
some do not support variant wheels, users need to be aware that certain
features may only be available with certain tools.</p>
</section>
<section id="python-package-maintainers">
<h3><a class="toc-backref" href="#python-package-maintainers" role="doc-backlink">Python package maintainers</a></h3>
<p>The primary source of information for maintainers of Python packages
should be build backend documentation, supplemented by tutorials. The
documentation needs to indicate:</p>
<ul class="simple">
<li>how to declare variant support in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code></li>
<li>how to use variant environment markers to specify dependencies</li>
<li>how to build variant wheels</li>
<li>how to publish them and generate the <code class="docutils literal notranslate"><span class="pre">*-variants.json</span></code> file on local
indexes</li>
</ul>
<p>The maintainers will also need to peruse provider plugin documentation.
They should also be aware which provider plugins are considered trusted
by commonly used installers, and know the implications of using
untrusted plugins. These materials may also be supplemented by generic
documents explaining publishing variant wheels, along with specific
example use cases.</p>
<p>For the transition period, package maintainers need to be aware that
they should still publish non-variant wheels for backwards
compatibility.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards compatibility</a></h2>
<p>Existing installers MUST NOT accidentally install variant wheels, as
they require additional logic to determine whether a wheel is compatible
with the user’s system. This is achieved by <a class="reference external" href="#extended-wheel-filename">extending wheel filename</a> through adding a <code class="docutils literal notranslate"><span class="pre">-{variant</span> <span class="pre">label}</span></code>
component to the end of the filename, effectively causing variant wheels
to be rejected by common installer implementations. For backwards
compatibility, a non-variant wheel can be published in addition to the
variant wheels. It will be the only wheel supported by incompatible
installers, and the least preferred wheel for variant-compatible
installers.</p>
<p>Aside from this explicit incompatibility, the specification makes
minimal and non-intrusive changes to the binary package format. The
<a class="reference internal" href="#variant-metadata">variant metadata</a> is placed in a separate file in the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code>
directory, which should be preserved by tools that are not concerned
with variants, limiting the necessary changes to updating the filename
validation algorithm (if there is one).</p>
<p>If the new <a class="reference internal" href="#variant-environment-markers">variant environment markers</a> are used in wheel
dependencies, these wheels will be incompatible with existing tools.
This is a general problem with the design of environment markers, and
not specific to wheel variants. It is possible to work around this
problem by partially evaluating environment markers at build time, and
removing the markers or dependencies specific to variant wheels from the
non-variant wheel.</p>
<p><a class="reference internal" href="#build-backends">Build backends</a> produce non-variant wheels to preserve backwards
compatibility with existing frontends. Variant wheels can only be output
on explicit user request.</p>
<p>By using a separate <code class="docutils literal notranslate"><span class="pre">*-variants.json</span></code> <a class="reference external" href="#name-version-variants-json-the-index-level-variant-metadata-file">file for shared metadata</a>,
it is
possible to use variant wheels on an index that does not specifically
support variant metadata. However, the index MUST permit distributing
wheels that use the extended filename syntax and the JSON file.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference implementation</a></h2>
<p>The <a class="reference external" href="https://github.com/wheelnext/variantlib">variantlib</a> project
contains a reference implementation of all the protocols and algorithms
introduced in this PEP, as well as a command-line tool to convert
wheels, generate the <code class="docutils literal notranslate"><span class="pre">*-variants.json</span></code> index and query plugins.</p>
<p>A client for installing variant wheels is implemented in a
<a class="reference external" href="https://github.com/astral-sh/uv/pull/12203">uv branch</a>.</p>
<p>The <a class="reference external" href="https://github.com/wheelnext/pep_xxx_wheel_variants">Wheel Variants monorepo</a> includes
example implementations of provider plugins, as well as modified
versions of build backends featuring variant wheel building support and
modified versions of some Python packages demonstrating variant wheel
uses.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected ideas</a></h2>
<section id="an-approach-without-provider-plugins">
<h3><a class="toc-backref" href="#an-approach-without-provider-plugins" role="doc-backlink">An approach without provider plugins</a></h3>
<p>The support for additional variant properties could technically be
implemented without introducing provider plugins, but rather defining
the available properties and their discovery methods as part of the
specification, much like how wheel tags are implemented currently.
However, the existing wheel tag logic already imposes a significant
complexity on packaging tools that need to maintain the logic for
generating supported tags, partially amortized by the data provided by
the Python interpreter itself.</p>
<p>Every new axis would be imposing even more effort on package manager
maintainers, who would have to maintain an algorithm to determine the
property compatibility. This algorithm could become quite complex,
possibly needing to account for different platforms, hardware versions
and requiring more frequent updates than the one for platform tags. This
would also significantly increase the barrier towards adding new axes
and therefore the risk of lack of feature parity between different
installers, as every new axis will be imposing additional maintenance
cost.</p>
<p>For comparison, the plugin design essentially democratizes the variant
properties. Provider plugins can be maintained independently by people
having the necessary knowledge and hardware. They can be updated as
frequently as necessary, independently of package managers. The decision
to use a particular provider falls entirely on the maintainer of package
needing it, though they need to take into consideration that using
plugins that are not vetted by the common installers will inconvenience
their users.</p>
</section>
<section id="resolving-variants-to-separate-packages">
<h3><a class="toc-backref" href="#resolving-variants-to-separate-packages" role="doc-backlink">Resolving variants to separate packages</a></h3>
<p>An alternative proposal was to publish the variants of the package as
separate projects on the index, along with the main package serving as a
“resolver” directing to other variants via its metadata. For example, a
<code class="docutils literal notranslate"><span class="pre">torch</span></code> package could indicate the conditions for using <code class="docutils literal notranslate"><span class="pre">torch-cpu</span></code>,
<code class="docutils literal notranslate"><span class="pre">torch-cu129</span></code>, etc. subpackages.</p>
<p>Such an approach could possibly feature better backwards compatibility
with existing tools. The changes would be limited to installers, and
even with pre-variant installers the users could explicitly request
installing a specific variant. However, it poses problems at multiple
levels.</p>
<p>The necessity of creating a new project for every variant will lead to
the proliferation of old projects, such as <code class="docutils literal notranslate"><span class="pre">torch-cu123</span></code>. While the
use of resolver package will ensure that only the modern variants are
used, users manually installing packages and cross-package dependencies
may accidentally be pinning to old variant projects, or even fall victim
to name squatting. For comparison, the variant wheel proposal scopes
variants to each project version, and ensures that only the project
maintainers can upload them.</p>
<p>Furthermore, it requires significant changes to the dependency resolver
and package metadata formats. In particular, the dependency resolver
would need to query all “resolver” packages before performing
resolution. It is unclear how to account for such variants while
performing universal resolution. The one-to-one mapping between
dependencies and installed packages would be lost, as a <code class="docutils literal notranslate"><span class="pre">torch</span></code>
dependency could effectively be satisfied by <code class="docutils literal notranslate"><span class="pre">torch-cu129</span></code>.</p>
</section>
</section>
<section id="appendices">
<h2><a class="toc-backref" href="#appendices" role="doc-backlink">Appendices</a></h2>
<ul class="simple">
<li><a class="reference internal" href="appendix-variant-metadata-json-schema/#variant-json-schema"><span class="std std-ref">Appendix: JSON Schema for Variant Metadata</span></a></li>
</ul>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>This work would not have been possible without the contributions and
feedback of many people in the Python packaging community. In
particular, we would like to credit the following individuals for their
help in shaping this PEP (in alphabetical order):</p>
<p>Alban Desmaison, Bradley Dice, Chris Gottbrath, Dmitry Rogozhkin,
Emma Smith, Geoffrey Thomas, Henry Schreiner, Jeff Daily, Jeremy Tanner,
Jithun Nair, Keith Kraus, Leo Fang, Mike McCarty, Nikita Shulga,
Paul Ganssle, Philip Hyunsu Cho, Robert Maynard, Vyas Ramasubramani,
and Zanie Blue.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0817.rst">https://github.com/python/peps/blob/main/peps/pep-0817.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0817.rst">2026-01-24 16:52:16 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#the-limitations-of-platform-compatibility-tags">The limitations of platform compatibility tags</a></li>
<li><a class="reference internal" href="#current-workarounds-and-their-drawbacks">Current workarounds and their drawbacks</a><ul>
<li><a class="reference internal" href="#runtime-cpu-dispatching">Runtime CPU dispatching</a></li>
<li><a class="reference internal" href="#separate-package-indexes-as-variants">Separate package indexes as variants</a></li>
<li><a class="reference internal" href="#package-names-as-variants">Package names as variants</a></li>
<li><a class="reference internal" href="#package-extras-as-variants">Package extras as variants</a></li>
<li><a class="reference internal" href="#bundled-universal-packages-monolithic-builds">Bundled universal packages - monolithic builds</a></li>
<li><a class="reference internal" href="#wheel-variant-selection-via-source-distribution">Wheel variant selection via source distribution</a></li>
<li><a class="reference internal" href="#ecosystem-fragmentation">Ecosystem fragmentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact-on-scientific-computing-and-ai-ml-workflows">Impact on scientific computing and AI/ML workflows</a><ul>
<li><a class="reference internal" href="#heterogeneous-computing-environments">Heterogeneous computing environments</a></li>
<li><a class="reference internal" href="#artificial-intelligence-machine-learning-and-deep-learning">Artificial intelligence, machine learning, and deep learning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#out-of-scope-features">Out-of-scope features</a></li>
<li><a class="reference internal" href="#prior-art">Prior art</a><ul>
<li><a class="reference internal" href="#conda-conda-forge">Conda - conda-forge</a></li>
<li><a class="reference internal" href="#spack-archspec">Spack / Archspec</a></li>
<li><a class="reference internal" href="#gentoo-linux">Gentoo Linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#wheel-variant-glossary">Wheel variant glossary</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#modified-wheel-filename">Modified wheel filename</a></li>
<li><a class="reference internal" href="#variant-property-system">Variant property system</a></li>
<li><a class="reference internal" href="#null-variant">Null variant</a></li>
<li><a class="reference internal" href="#install-time-and-ahead-of-time-providers">Install-time and Ahead-of-Time providers</a></li>
<li><a class="reference internal" href="#plugin-stability-and-versioning">Plugin stability and versioning</a></li>
<li><a class="reference internal" href="#metadata-in-source-tree-and-wheels">Metadata in source tree and wheels</a></li>
<li><a class="reference internal" href="#abi-dependency-variant-provider">ABI dependency variant provider</a></li>
<li><a class="reference internal" href="#example-use-cases">Example use cases</a><ul>
<li><a class="reference internal" href="#pytorch-cpu-gpu-variants">PyTorch CPU/GPU variants</a></li>
<li><a class="reference internal" href="#optimized-cpu-variants">Optimized CPU variants</a></li>
<li><a class="reference internal" href="#blas-lapack-variants">BLAS / LAPACK variants</a></li>
<li><a class="reference internal" href="#debug-package-variants">Debug package variants</a></li>
<li><a class="reference internal" href="#package-abi-matching">Package ABI matching</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security implications</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#definitions">Definitions</a></li>
<li><a class="reference internal" href="#extended-wheel-filename">Extended wheel filename</a></li>
<li><a class="reference internal" href="#variant-properties">Variant properties</a></li>
<li><a class="reference internal" href="#providers">Providers</a></li>
<li><a class="reference internal" href="#variant-metadata">Variant metadata</a><ul>
<li><a class="reference internal" href="#provider-information">Provider information</a></li>
<li><a class="reference internal" href="#default-priorities">Default priorities</a></li>
<li><a class="reference internal" href="#static-properties">Static properties</a></li>
<li><a class="reference internal" href="#variants">Variants</a></li>
<li><a class="reference internal" href="#pyproject-toml-variant-project-level-data-table"><code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>: variant project-level data table</a></li>
<li><a class="reference internal" href="#dist-info-variant-json-the-packaged-variant-metadata-file"><code class="docutils literal notranslate"><span class="pre">*.dist-info/variant.json</span></code>: the packaged variant metadata file</a></li>
<li><a class="reference internal" href="#name-version-variants-json-the-index-level-variant-metadata-file"><code class="docutils literal notranslate"><span class="pre">{name}-{version}-variants.json</span></code>: the index level variant metadata file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-ordering">Variant ordering</a></li>
<li><a class="reference internal" href="#integration-with-pylock-toml">Integration with <code class="docutils literal notranslate"><span class="pre">pylock.toml</span></code></a></li>
<li><a class="reference internal" href="#provider-plugin-api">Provider plugin API</a><ul>
<li><a class="reference internal" href="#high-level-design">High level design</a></li>
<li><a class="reference internal" href="#api-endpoint">API endpoint</a></li>
<li><a class="reference internal" href="#variant-feature-config-class">Variant feature config class</a></li>
<li><a class="reference internal" href="#plugin-interface">Plugin interface</a></li>
<li><a class="reference internal" href="#example-implementation">Example implementation</a></li>
<li><a class="reference internal" href="#future-extensions">Future extensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-backends">Build backends</a></li>
<li><a class="reference internal" href="#variant-environment-markers">Variant environment markers</a></li>
<li><a class="reference internal" href="#abi-dependency-variant-namespace-optional">ABI Dependency Variant Namespace (Optional)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to teach this</a><ul>
<li><a class="reference internal" href="#python-package-users">Python package users</a></li>
<li><a class="reference internal" href="#python-package-maintainers">Python package maintainers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected ideas</a><ul>
<li><a class="reference internal" href="#an-approach-without-provider-plugins">An approach without provider plugins</a></li>
<li><a class="reference internal" href="#resolving-variants-to-separate-packages">Resolving variants to separate packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendices">Appendices</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0817.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>