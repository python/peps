
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 276 – Simple Iterator for ints | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0276/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 276 – Simple Iterator for ints | peps.python.org'>
    <meta property="og:description" content="Python 2.1 added new functionality to support iterators (PEP 234). Iterators have proven to be useful and convenient in many coding situations.  It is noted that the implementation of Python’s for-loop control structure uses the iterator protocol as of ...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0276/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="Python 2.1 added new functionality to support iterators (PEP 234). Iterators have proven to be useful and convenient in many coding situations.  It is noted that the implementation of Python’s for-loop control structure uses the iterator protocol as of ...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 276</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 276 – Simple Iterator for ints" data-pagefind-weight="10" class="visually-hidden">PEP 276 – Simple Iterator for ints</span>
            <section id="pep-content">
<h1 class="page-title">PEP 276 – Simple Iterator for ints</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Jim Althoff &lt;james_althoff&#32;&#97;t&#32;i2.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Formally declined and will not be accepted">Rejected</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">12-Nov-2001</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">2.3</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#issues">Issues</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>Python 2.1 added new functionality to support iterators (<a class="pep reference internal" href="../pep-0234/" title="PEP 234 – Iterators">PEP 234</a>).
Iterators have proven to be useful and convenient in many coding
situations.  It is noted that the implementation of Python’s
for-loop control structure uses the iterator protocol as of
release 2.1.  It is also noted that Python provides iterators for
the following builtin types: lists, tuples, dictionaries, strings,
and files.  This PEP proposes the addition of an iterator for the
builtin type int (<code class="docutils literal notranslate"><span class="pre">types.IntType</span></code>).  Such an iterator would simplify
the coding of certain for-loops in Python.</p>
</section>
<section id="bdfl-pronouncement">
<h2><a class="toc-backref" href="#bdfl-pronouncement" role="doc-backlink">BDFL Pronouncement</a></h2>
<p>This PEP was rejected on 17 June 2005 with a note to python-dev.</p>
<p>Much of the original need was met by the <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> function which
was accepted for Python 2.3.</p>
<p>Also, the proposal both allowed and encouraged misuses such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">3</span><span class="p">:</span> <span class="nb">print</span> <span class="n">i</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Likewise, it was not helpful that the proposal would disable the
syntax error in statements like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Define an iterator for types.intType (i.e., the builtin type
“int”) that is returned from the builtin function “iter” when
called with an instance of types.intType as the argument.</p>
<p>The returned iterator has the following behavior:</p>
<ul>
<li>Assume that object i is an instance of <code class="docutils literal notranslate"><span class="pre">types.intType</span></code> (the
builtin type int) and that i &gt; 0</li>
<li><code class="docutils literal notranslate"><span class="pre">iter(i)</span></code> returns an iterator object</li>
<li>said iterator object iterates through the sequence of ints
0,1,2,…,i-1<p>Example:</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">iter(5)</span></code> returns an iterator object that iterates through the
sequence of ints 0,1,2,3,4</div></blockquote>
</li>
<li>if i &lt;= 0, <code class="docutils literal notranslate"><span class="pre">iter(i)</span></code> returns an “empty” iterator, i.e., one that
throws StopIteration upon the first call of its “next” method</li>
</ul>
<p>In other words, the conditions and semantics of said iterator is
consistent with the conditions and semantics of the <code class="docutils literal notranslate"><span class="pre">range()</span></code> and
<code class="docutils literal notranslate"><span class="pre">xrange()</span></code> functions.</p>
<p>Note that the sequence 0,1,2,…,i-1 associated with the int i is
considered “natural” in the context of Python programming because
it is consistent with the builtin indexing protocol of sequences
in Python.  Python lists and tuples, for example, are indexed
starting at 0 and ending at len(object)-1 (when using positive
indices).  In other words, such objects are indexed with the
sequence 0,1,2,…,len(object)-1</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>A common programming idiom is to take a collection of objects and
apply some operation to each item in the collection in some
established sequential order.  Python provides the “for in”
looping control structure for handling this common idiom.  Cases
arise, however, where it is necessary (or more convenient) to
access each item in an “indexed” collection by iterating through
each index and accessing each item in the collection using the
corresponding index.</p>
<p>For example, one might have a two-dimensional “table” object where one
requires the application of some operation to the first column of
each row in the table.  Depending on the implementation of the table
it might not be possible to access first each row and then each
column as individual objects.  It might, rather, be possible to
access a cell in the table using a row index and a column index.
In such a case it is necessary to use an idiom where one iterates
through a sequence of indices (indexes) in order to access the
desired items in the table.  (Note that the commonly used
DefaultTableModel class in Java-Swing-Jython has this very protocol).</p>
<p>Another common example is where one needs to process two or more
collections in parallel.  Another example is where one needs to
access, say, every second item in a collection.</p>
<p>There are many other examples where access to items in a
collection is facilitated by a computation on an index thus
necessitating access to the indices rather than direct access to
the items themselves.</p>
<p>Let’s call this idiom the “indexed for-loop” idiom.  Some
programming languages provide builtin syntax for handling this
idiom.  In Python the common convention for implementing the
indexed for-loop idiom is to use the builtin <code class="docutils literal notranslate"><span class="pre">range()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrange()</span></code>
function to generate a sequence of indices as in, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">rowcount</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">getRowCount</span><span class="p">()):</span>
    <span class="nb">print</span> <span class="n">table</span><span class="o">.</span><span class="n">getValueAt</span><span class="p">(</span><span class="n">rowcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">rowcount</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">getRowCount</span><span class="p">()):</span>
    <span class="nb">print</span> <span class="n">table</span><span class="o">.</span><span class="n">getValueAt</span><span class="p">(</span><span class="n">rowcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>From time to time there are discussions in the Python community
about the indexed for-loop idiom.  It is sometimes argued that the
need for using the <code class="docutils literal notranslate"><span class="pre">range()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrange()</span></code> function for this design
idiom is:</p>
<ul class="simple">
<li>Not obvious (to new-to-Python programmers),</li>
<li>Error prone (easy to forget, even for experienced Python
programmers)</li>
<li>Confusing and distracting for those who feel compelled to understand
the differences and recommended usage of <code class="docutils literal notranslate"><span class="pre">xrange()</span></code> vis-a-vis <code class="docutils literal notranslate"><span class="pre">range()</span></code></li>
<li>Unwieldy, especially when combined with the <code class="docutils literal notranslate"><span class="pre">len()</span></code> function,
i.e., <code class="docutils literal notranslate"><span class="pre">xrange(len(sequence))</span></code></li>
<li>Not as convenient as equivalent mechanisms in other languages,</li>
<li>Annoying, a “wart”, etc.</li>
</ul>
<p>And from time to time proposals are put forth for ways in which
Python could provide a better mechanism for this idiom.  Recent
examples include <a class="pep reference internal" href="../pep-0204/" title="PEP 204 – Range Literals">PEP 204</a>, “Range Literals”, and <a class="pep reference internal" href="../pep-0212/" title="PEP 212 – Loop Counter Iteration">PEP 212</a>, “Loop
Counter Iteration”.</p>
<p>Most often, such proposal include changes to Python’s syntax and
other “heavyweight” changes.</p>
<p>Part of the difficulty here is that advocating new syntax implies
a comprehensive solution for “general indexing” that has to
include aspects like:</p>
<ul class="simple">
<li>starting index value</li>
<li>ending index value</li>
<li>step value</li>
<li>open intervals versus closed intervals versus half opened intervals</li>
</ul>
<p>Finding a new syntax that is comprehensive, simple, general,
Pythonic, appealing to many, easy to implement, not in conflict
with existing structures, not excessively overloading of existing
structures, etc. has proven to be more difficult than one might
anticipate.</p>
<p>The proposal outlined in this PEP tries to address the problem by
suggesting a simple “lightweight” solution that helps the most
common case by using a proven mechanism that is already available
(as of Python 2.1): namely, iterators.</p>
<p>Because for-loops already use “iterator” protocol as of Python
2.1, adding an iterator for types.IntType as proposed in this PEP
would enable by default the following shortcut for the indexed
for-loop idiom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">rowcount</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">getRowCount</span><span class="p">():</span>
    <span class="nb">print</span> <span class="n">table</span><span class="o">.</span><span class="n">getValueAt</span><span class="p">(</span><span class="n">rowcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The following benefits for this approach vis-a-vis the current
mechanism of using the <code class="docutils literal notranslate"><span class="pre">range()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrange()</span></code> functions are claimed
to be:</p>
<ul class="simple">
<li>Simpler,</li>
<li>Less cluttered,</li>
<li>Focuses on the problem at hand without the need to resort to
secondary implementation-oriented functions (<code class="docutils literal notranslate"><span class="pre">range()</span></code> and
<code class="docutils literal notranslate"><span class="pre">xrange()</span></code>)</li>
</ul>
<p>And compared to other proposals for change:</p>
<ul class="simple">
<li>Requires no new syntax</li>
<li>Requires no new keywords</li>
<li>Takes advantage of the new and well-established iterator mechanism</li>
</ul>
<p>And generally:</p>
<ul class="simple">
<li>Is consistent with iterator-based “convenience” changes already
included (as of Python 2.1) for other builtin types such as:
lists, tuples, dictionaries, strings, and files.</li>
</ul>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>The proposed mechanism is generally backwards compatible as it
calls for neither new syntax nor new keywords.  All existing,
valid Python programs should continue to work unmodified.</p>
<p>However, this proposal is not perfectly backwards compatible in
the sense that certain statements that are currently invalid
would, under the current proposal, become valid.</p>
<p>Tim Peters has pointed out two such examples:</p>
<ol class="arabic">
<li>The common case where one forgets to include <code class="docutils literal notranslate"><span class="pre">range()</span></code> or
<code class="docutils literal notranslate"><span class="pre">xrange()</span></code>, for example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">rowcount</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">getRowCount</span><span class="p">():</span>
    <span class="nb">print</span> <span class="n">table</span><span class="o">.</span><span class="n">getValueAt</span><span class="p">(</span><span class="n">rowcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>in Python 2.2 raises a TypeError exception.</p>
<p>Under the current proposal, the above statement would be valid
and would work as (presumably) intended.  Presumably, this is a
good thing.</p>
<p>As noted by Tim, this is the common case of the “forgotten
range” mistake (which one currently corrects by adding a call
to <code class="docutils literal notranslate"><span class="pre">range()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrange()</span></code>).</p>
</li>
<li>The (hopefully) very uncommon case where one makes a typing
mistake when using tuple unpacking.  For example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>in Python 2.2 raises a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> exception.</p>
<p>Under the current proposal, the above statement would be valid
and would set x to 0.  The PEP author has no data as to how
common this typing error is nor how difficult it would be to
catch such an error under the current proposal.  He imagines
that it does not occur frequently and that it would be
relatively easy to correct should it happen.</p>
</li>
</ol>
</section>
<section id="issues">
<h2><a class="toc-backref" href="#issues" role="doc-backlink">Issues</a></h2>
<p>Extensive discussions concerning <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> on the Python interest
mailing list suggests a range of opinions: some in favor, some
neutral, some against.  Those in favor tend to agree with the
claims above of the usefulness, convenience, ease of learning,
and simplicity of a simple iterator for integers.</p>
<p>Issues with <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> include:</p>
<ul>
<li>Using range/xrange is fine as is.<p>Response: Some posters feel this way.  Other disagree.</p>
</li>
<li>Some feel that iterating over the sequence “0, 1, 2, …, n-1”
for an integer n is not intuitive.  “for i in 5:” is considered
(by some) to be “non-obvious”, for example.  Some dislike this
usage because it doesn’t have “the right feel”.  Some dislike it
because they believe that this type of usage forces one to view
integers as a sequences and this seems wrong to them.  Some
dislike it because they prefer to view for-loops as dealing
with explicit sequences rather than with arbitrary iterators.<p>Response: Some like the proposed idiom and see it as simple,
elegant, easy to learn, and easy to use.  Some are neutral on
this issue.  Others, as noted, dislike it.</p>
</li>
<li>Is it obvious that <code class="docutils literal notranslate"><span class="pre">iter(5)</span></code> maps to the sequence 0,1,2,3,4?<p>Response: Given, as noted above, that Python has a strong
convention for indexing sequences starting at 0 and stopping at
(inclusively) the index whose value is one less than the length
of the sequence, it is argued that the proposed sequence is
reasonably intuitive to the Python programmer while being useful
and practical.  More importantly, it is argued that once learned
this convention is very easy to remember.  Note that the doc
string for the range function makes a reference to the
natural and useful association between <code class="docutils literal notranslate"><span class="pre">range(n)</span></code> and the indices
for a list whose length is n.</p>
</li>
<li>Possible ambiguity<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">10</span><span class="p">:</span> <span class="nb">print</span> <span class="n">i</span>
</pre></div>
</div>
<p>might be mistaken for</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">10</span><span class="p">,):</span> <span class="nb">print</span> <span class="n">i</span>
</pre></div>
</div>
<p>Response: This is exactly the same situation with strings in
current Python (replace 10 with ‘spam’ in the above, for
example).</p>
</li>
<li>Too general: in the newest releases of Python there are
contexts – as with for-loops – where iterators are called
implicitly.  Some fear that having an iterator invoked for
an integer in one of the context (excluding for-loops) might
lead to unexpected behavior and bugs.  The “x, = 1” example
noted above is an a case in point.<p>Response: From the author’s perspective the examples of the
above that were identified in the <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> discussions did
not appear to be ones that would be accidentally misused
in ways that would lead to subtle and hard-to-detect errors.</p>
<p>In addition, it seems that there is a way to deal with this
issue by using a variation of what is outlined in the
specification section of this proposal.  Instead of adding
an <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> method to class int, change the for-loop handling
code to convert (in essence) from</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>  <span class="c1"># when isinstance(n,int) is 1</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</pre></div>
</div>
<p>This approach gives the same results in a for-loop as an
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code> method would but would prevent iteration on integer
values in any other context.  Lists and tuples, for example,
don’t have <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> and are handled with special code.
Integer values would be one more special case.</p>
</li>
<li>“i in n” seems very unnatural.<p>Response: Some feel that “i in len(mylist)” would be easily
understandable and useful.  Some don’t like it, particularly
when a literal is used as in “i in 5”.  If the variant
mentioned in the response to the previous issue is implemented,
this issue is moot.  If not, then one could also address this
issue by defining a <code class="docutils literal notranslate"><span class="pre">__contains__</span></code> method in class int that would
always raise a TypeError.  This would then make the behavior of
“i in n” identical to that of current Python.</p>
</li>
<li>Might dissuade newbies from using the indexed for-loop idiom when
the standard “for item in collection:” idiom is clearly better.<p>Response: The standard idiom is so nice when it fits that it
needs neither extra “carrot” nor “stick”.  On the other hand,
one does notice cases of overuse/misuse of the standard idiom
(due, most likely, to the awkwardness of the indexed for-loop
idiom), as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">sequence</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>Why not propose even bigger changes?</li>
</ul>
<p>The majority of disagreement with <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> came from those who
favor much larger changes to Python to address the more general
problem of specifying a sequence of integers where such
a specification is general enough to handle the starting value,
ending value, and stepping value of the sequence and also
addresses variations of open, closed, and half-open (half-closed)
integer intervals.  Many suggestions of such were discussed.</p>
<p>These include:</p>
<ul class="simple">
<li>adding Haskell-like notation for specifying a sequence of
integers in a literal list,</li>
<li>various uses of slicing notation to specify sequences,</li>
<li>changes to the syntax of for-in loops to allow the use of
relational operators in the loop header,</li>
<li>creation of an integer-interval class along with methods that
overload relational operators or division operators
to provide “slicing” on integer-interval objects,</li>
<li>and more.</li>
</ul>
<p>It should be noted that there was much debate but not an
overwhelming consensus for any of these larger-scale suggestions.</p>
<p>Clearly, <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> does not propose such a large-scale change
and instead focuses on a specific problem area.  Towards the
end of the discussion period, several posters expressed favor
for the narrow focus and simplicity of <a class="pep reference internal" href="../pep-0276/" title="PEP 276 – Simple Iterator for ints">PEP 276</a> vis-a-vis the more
ambitious suggestions that were advanced.  There did appear to be
consensus for the need for a PEP for any such larger-scale,
alternative suggestion.  In light of this recognition, details of
the various alternative suggestions are not discussed here further.</p>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>An implementation is not available at this time but is expected
to be straightforward.  The author has implemented a subclass of
int with an <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> method (written in Python) as a means to test
out the ideas in this proposal, however.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0276.rst">https://github.com/python/peps/blob/main/peps/pep-0276.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0276.rst">2025-02-01 08:55:40 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#issues">Issues</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0276.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>