
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 800 – Disjoint bases in the type system | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0800/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 800 – Disjoint bases in the type system | peps.python.org'>
    <meta property="og:description" content="To analyze Python programs precisely, type checkers need to know when two classes can and cannot have a common child class. However, the information necessary to determine this is not currently part of the type system. This PEP adds a new decorator, @ty...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0800/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="To analyze Python programs precisely, type checkers need to know when two classes can and cannot have a common child class. However, the information necessary to determine this is not currently part of the type system. This PEP adds a new decorator, @ty...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 800</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 800 – Disjoint bases in the type system</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Jelle Zijlstra &lt;jelle.zijlstra&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/99910/">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Topic<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="../topic/typing/">Typing</a></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">21-Jul-2025</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/solid-bases-for-detecting-incompatible-base-classes/99280" title="Discourse thread">18-Jul-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#invalid-class-definitions">Invalid class definitions</a></li>
<li><a class="reference internal" href="#reachability">Reachability</a></li>
<li><a class="reference internal" href="#overloads">Overloads</a></li>
<li><a class="reference internal" href="#intersection-types">Intersection types</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#naming">Naming</a></li>
<li><a class="reference internal" href="#runtime-restrictions-on-multiple-inheritance">Runtime restrictions on multiple inheritance</a></li>
<li><a class="reference internal" href="#disjoint-base-in-implementation-files"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> in implementation files</a></li>
<li><a class="reference internal" href="#disjoint-base-on-special-classes"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> on special classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#runtime-implementation">Runtime implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility">Backward compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#appendix">Appendix</a><ul>
<li><a class="reference internal" href="#solid-bases-in-cpython">Solid bases in CPython</a></li>
<li><a class="reference internal" href="#mypy-s-incompatibility-check">Mypy’s incompatibility check</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>To analyze Python programs precisely, type checkers need to know when two classes can and cannot have a common child class.
However, the information necessary to determine this is not currently part of the type system. This PEP adds a new
decorator, <code class="docutils literal notranslate"><span class="pre">&#64;typing.disjoint_base</span></code>, that indicates that a class is a “disjoint base”. Two classes that have distinct, unrelated
disjoint bases cannot have a common child class.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>In type checking Python, an important concept is that of reachability. Python type checkers generally
detect when a branch of code can never be reached, and they warn users about such code. This is useful
because unreachable code unnecessarily complicates the program, and its presence can be an indication of a bug.</p>
<p>For example, in this program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s both!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>both pyright and mypy (with <code class="docutils literal notranslate"><span class="pre">--warn-unreachable</span></code>), two popular type checkers, will warn that the body of the
<code class="docutils literal notranslate"><span class="pre">if</span></code> block is unreachable, because if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, it cannot also be a <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<p>Reachability is complicated in Python by the presence of multiple inheritance. If instead of <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code>,
we use two user-defined classes, mypy and pyright do not show any warnings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s both!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is correct, because a class that inherits from both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> could exist.</p>
<p>We see a divergence between type checkers in another case, where we use <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s both!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For this code, pyright shows no errors but mypy will claim that the branch is unreachable. Mypy is technically correct
here: CPython does not allow a class to inherit from both <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code>, so the branch is unreachable.
However, the information necessary to determine that these base classes are incompatible is not currently available in
the type system. Mypy, in fact, uses a heuristic based on the presence of incompatible methods; this heuristic works
reasonably well in practice, especially for built-in types, but it is
incorrect in general, as discussed in more detail <a class="reference internal" href="#pep-800-mypy-incompatibility-check"><span class="std std-ref">below</span></a>.</p>
<p>The experimental <code class="docutils literal notranslate"><span class="pre">ty</span></code> type checker uses a third approach that aligns more closely with the <a class="reference internal" href="#pep-800-solid-bases-cpython"><span class="std std-ref">runtime behavior of Python</span></a>:
it recognizes certain classes as “solid bases” that restrict multiple inheritance. Broadly speaking, every class must
inherit from at most one unique solid base, and if there is no unique solid base, the class cannot exist; we’ll provide a more
precise definition below. However, ty’s approach relies on hardcoded knowledge of particular built-in types. The term “solid base” derives from the
CPython implementation; this PEP uses the newly proposed term “disjoint base” instead.</p>
<p>This PEP proposes an extension to the type system that makes it possible to express when multiple inheritance is not
allowed at runtime: an <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator that marks a classes as a <em>disjoint base</em>.
This gives type checkers a more precise understanding of reachability, and helps in several concrete areas.</p>
<section id="invalid-class-definitions">
<h3><a class="toc-backref" href="#invalid-class-definitions" role="doc-backlink">Invalid class definitions</a></h3>
<p>The following class definition raises an error at runtime, because <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code> are distinct disjoint bases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>Without knowledge of disjoint bases, type checkers are not currently able to detect the reason why this class
definition is invalid, though they may detect that if this class were to exist, some of its methods would be incompatible.
(When it sees this class definition, mypy will point at incompatible definitions of <code class="docutils literal notranslate"><span class="pre">__add__</span></code> and several other
methods.)</p>
<p>This is not a particularly compelling problem by itself, as the error would usually be caught the first time the code
is imported, but it is mentioned here for completeness.</p>
</section>
<section id="reachability">
<h3><a class="toc-backref" href="#reachability" role="doc-backlink">Reachability</a></h3>
<p>We already mentioned the reachability of code using <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>. Similar issues arise with other type
narrowing constructs such as <code class="docutils literal notranslate"><span class="pre">match</span></code> statements: correct inference of reachability requires an understanding of
disjoint bases.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">B</span><span class="p">():</span>  <span class="c1"># reachable</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s both!&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>  <span class="c1"># unreachable</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s both!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="overloads">
<h3><a class="toc-backref" href="#overloads" role="doc-backlink">Overloads</a></h3>
<p>Functions decorated with <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> may be unsafe if the parameter types of some overloads overlap, but the return types
do not. For example, the following set of overloads could be exploited to
<a class="reference external" href="https://github.com/JelleZijlstra/unsoundness/blob/04d16e5ea1a6492d82e8131f72894c9dcad1a55c/examples/overload/undetected_overlap.py">achieve unsound behavior</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">overload</span>

<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">:</span> <span class="k">pass</span>

<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>If a class exists that inherits from both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, then type checkers could pick the wrong overload on a
call to <code class="docutils literal notranslate"><span class="pre">f()</span></code>.</p>
<p>Type checkers could detect this source of unsafety and warn about it, but a correct implementation requires an understanding of disjoint bases,
because it relies on knowing whether values that are instances of both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> can exist.
Although many type checkers already perform a version of this check for overlapping overloads, the typing specification does not
currently prescribe how this check should work. This PEP does not propose to change that, but it helps provide a building block for
a sound check for overlapping overloads.</p>
</section>
<section id="intersection-types">
<h3><a class="toc-backref" href="#intersection-types" role="doc-backlink">Intersection types</a></h3>
<p>Explicit intersection types, denoting a type that contains values that are instances of all of the
given types, are not currently part of the type system. They do, however, arise naturally in a set-theoretic type system
like Python’s as a result of type narrowing, and future extensions to the type system may add support for explicit intersection types.</p>
<p>With intersection types, it is often important to know whether a particular intersection is inhabited, that is, whether
there are values that can be members of that intersection. This allows type checkers to understand reachability and
provide more precise type information to users.</p>
<p>As a concrete example, a possible implementation of assignability with intersection types could be that
given an intersection type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;</span> <span class="pre">B</span></code>, a type <code class="docutils literal notranslate"><span class="pre">C</span></code> is assignable to it if <code class="docutils literal notranslate"><span class="pre">C</span></code> is assignable to at least one of
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, and overlaps with all of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>. (“Overlaps” here means that at least one runtime value could exist
that would be a member of both types. That is, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> overlap if <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;</span> <span class="pre">B</span></code> is inhabited.) The second part of the rule ensures that <code class="docutils literal notranslate"><span class="pre">str</span></code> is not assignable to a type like <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">&amp;</span> <span class="pre">Any</span></code>: while <code class="docutils literal notranslate"><span class="pre">str</span></code> is assignable to <code class="docutils literal notranslate"><span class="pre">Any</span></code>,
it does not overlap with <code class="docutils literal notranslate"><span class="pre">int</span></code>. But of course, we can only know that <code class="docutils literal notranslate"><span class="pre">str</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code> do not overlap if we know
that both classes are disjoint bases.</p>
</section>
<section id="overview">
<h3><a class="toc-backref" href="#overview" role="doc-backlink">Overview</a></h3>
<p>Disjoint bases can be helpful in many corners of the type system. Though some of these corners are underspecified,
speculative, or of marginal importance, in each case the concept of disjoint bases enables type checkers to gain a more
precise understanding than the current type system allows. Thus, disjoint bases provide a firm foundation
(a solid base, if you will) for improving the Python type system.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The concept of “disjoint bases” enables type checkers to understand when a common child class of two classes can and cannot
exist. To communicate this concept to type checkers, we add an <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator to the type system that marks
a class as a disjoint base. The semantics are roughly that a class cannot have two unrelated disjoint bases.</p>
<section id="naming">
<h3><a class="toc-backref" href="#naming" role="doc-backlink">Naming</a></h3>
<p>The initial version of this PEP used the name “solid base”, following the terminology used in CPython’s implementation.
However, this term is somewhat vague. The alternative term “disjoint base” suggests that a class with this decorator
is disjoint from other bases, which is a good first-order description of the concept. (The exact semantics are more subtle
and are described below.)</p>
</section>
<section id="runtime-restrictions-on-multiple-inheritance">
<h3><a class="toc-backref" href="#runtime-restrictions-on-multiple-inheritance" role="doc-backlink">Runtime restrictions on multiple inheritance</a></h3>
<p>While Python generally allows multiple inheritance, the runtime imposes various restrictions, as
<a class="reference external" href="https://docs.python.org/3.15/reference/compound_stmts.html#multiple-inheritance" title="(in Python v3.15)"><span class="xref std std-ref">documented in CPython</span></a>.
Two sets of restrictions, around a consistent MRO and a consistent metaclass, can already be implemented by
type checkers using information available in the type system. The third restriction, around instance layout,
is the one that requires knowledge of disjoint bases. Classes that contain a non-empty <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> definition
are automatically disjoint bases, as are many built-in classes implemented in C.</p>
<p>Alternative implementations of Python, such as PyPy, tend to behave similarly to CPython but may differ in details,
such as exactly which standard library classes are disjoint bases. As the type system does not currently contain any
explicit support for alternative Python implementations, this PEP recommends that stub libraries such as typeshed
use CPython’s behavior to determine when to use the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator. If future extensions to the type system
add support for alternative implementations (for example, branching on the value of <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.implementation" title="(in Python v3.14)"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.implementation.name</span></code></a>),
stubs could condition the presence of the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator on the implementation where necessary.</p>
<p>Although the concept of “disjoint bases” (referred to as “solid bases”) in the CPython implementation has existed
for decades, the rules for deciding which classes are disjoint bases have occasionally changed.
Before Python 3.12, adding a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> or support for weakrefs relative to the base class could make a
class a disjoint base. In practice, this often meant that Python-implemented classes inheriting from
classes implemented in C, such as <a class="reference external" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" title="(in Python v3.14)"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a> classes, were themselves disjoint bases.
This behavior was changed in Python 3.12 by
<a class="reference external" href="https://github.com/python/cpython/pull/96028">python/cpython#96028</a>.
This PEP focuses on supporting the behavior of Python 3.12 and later, which is simpler and easier to understand.
Type checkers may choose to implement a version of the pre-3.12 behavior if they wish, but doing this correctly
requires information that is not currently available in the type system.</p>
<p>The exact set of classes that are disjoint bases at runtime may change again in future versions of Python.
If this were to happen, the type stubs used by type checkers could be updated to reflect this new reality.
In other words, this PEP adds the concept of disjoint bases to the type system, but it does not prescribe exactly
which classes are disjoint bases.</p>
</section>
<section id="disjoint-base-in-implementation-files">
<h3><a class="toc-backref" href="#disjoint-base-in-implementation-files" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> in implementation files</a></h3>
<p>The most obvious use case for the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator will be in stub files for C libraries, such as the standard library,
for marking disjoint bases implemented in C.</p>
<p>However, there are also use cases for marking disjoint bases in implementation files, where the effect would be to disallow
the existence of child classes that inherit from the decorated class and another disjoint base, such as a standard library class
or another user class decorated with <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code>. For example, this could allow type checkers to flag code that can only
be reachable if a class exists that inherits from both a user class and a standard library class such as <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code>,
which may be technically possible but not practically plausible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@disjoint_base</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseModel</span><span class="p">:</span>
    <span class="c1"># ... General logic for model classes</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Species</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># ... more fields</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_species</span><span class="p">(</span><span class="n">species</span><span class="p">:</span> <span class="n">Species</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># oops, forgot `.name`</span>
        <span class="k">pass</span>  <span class="c1"># type checker should warn about this branch being unreachable</span>
        <span class="c1"># BaseModel and str are disjoint bases, so a class that inherits from both cannot exist</span>
</pre></div>
</div>
<p>This is similar in principle to the existing <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> decorator, which also acts to restrict subclassing: in stubs, it
is used to mark classes that programmatically disallow subclassing, but in implementation files, it is often used to
indicate that a class is not intended to be subclassed, without runtime enforcement.</p>
</section>
<section id="disjoint-base-on-special-classes">
<h3><a class="toc-backref" href="#disjoint-base-on-special-classes" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> on special classes</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator is primarily intended for nominal classes, but the type system contains some other constructs that
syntactically use class definitions, so we have to consider whether the decorator should be allowed on them as well, and if so,
what it would mean.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> definitions, the most consistent interpretation would be that the only classes that can implement the
protocol would be classes that use nominal inheritance from the protocol, or <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> classes that implement the protocol.
Other classes either have or could potentially have a disjoint base that is not the protocol. This is convoluted and not useful,
so we disallow <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> on <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> definitions.</p>
<p>Similarly, the concept of a “disjoint base” is not meaningful on <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> definitions, as TypedDicts are purely structural types.</p>
<p>Although they receive some special treatment in the type system, <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> definitions create real nominal classes that can
have child classes, so it makes sense to allow <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> on them and treat them like regular classes for the purposes
of the disjoint base mechanism. All <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> classes have <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, a disjoint base, in their MRO, so they
cannot multiple inherit from other disjoint bases.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>A decorator <code class="docutils literal notranslate"><span class="pre">&#64;typing.disjoint_base</span></code> is added to the type system. It may only be used on nominal classes, including <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code>
definitions; it is a type checker error to use the decorator on a function, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> definition, or <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> definition.</p>
<p>We define two properties on (nominal) classes: a class may or may not <em>be</em> a disjoint base, and every class must <em>have</em> a valid disjoint base.</p>
<p>A class is a disjoint base if it is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;typing.disjoint_base</span></code>, or if it contains a non-empty <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> definition.
This includes classes that have <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> because of the <code class="docutils literal notranslate"><span class="pre">&#64;dataclass(slots=True)</span></code> decorator or
because of the use of the <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> mechanism to add slots.
The universal base class, <code class="docutils literal notranslate"><span class="pre">object</span></code>, is also a disjoint base.</p>
<p>To determine a class’s disjoint base, we look at all of its base classes to determine a set of candidate disjoint bases. For each base
that is itself a disjoint base, the candidate is the base itself; otherwise, it is the base’s disjoint base. If the candidate set contains
a single disjoint base, that is the class’s disjoint base. If there are multiple candidates, but one of them is a subclass of all other candidates,
that class is the disjoint base. If no such candidate exists, the class does not have a valid disjoint base, and therefore cannot exist.</p>
<p>Type checkers must check for a valid disjoint base when checking class definitions, and emit a diagnostic if they encounter a class
definition that lacks a valid disjoint base. Type checkers may also use the disjoint base mechanism to determine whether types are disjoint,
for example when checking whether a type narrowing construct like <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> results in an unreachable branch.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">disjoint_base</span><span class="p">,</span> <span class="n">assert_never</span>

<span class="nd">@disjoint_base</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Disjoint1</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="nd">@disjoint_base</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Disjoint2</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="nd">@disjoint_base</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DisjointChild</span><span class="p">(</span><span class="n">Disjoint1</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C1</span><span class="p">:</span>  <span class="c1"># disjoint base is `object`</span>
    <span class="k">pass</span>

<span class="c1"># OK: candidate disjoint bases are `Disjoint1` and `object`, and `Disjoint1` is a subclass of `object`.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">C2</span><span class="p">(</span><span class="n">Disjoint1</span><span class="p">,</span> <span class="n">C1</span><span class="p">):</span>  <span class="c1"># disjoint base is `Disjoint1`</span>
    <span class="k">pass</span>

<span class="c1"># OK: candidate disjoint bases are `DisjointChild` and `Disjoint1`, and `DisjointChild` is a subclass of `Disjoint1`.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">C3</span><span class="p">(</span><span class="n">DisjointChild</span><span class="p">,</span> <span class="n">Disjoint1</span><span class="p">):</span>  <span class="c1"># disjoint base is `DisjointChild`</span>
    <span class="k">pass</span>

<span class="c1"># error: candidate disjoint bases are `Disjoint1` and `Disjoint2`, but neither is a subclass of the other</span>
<span class="k">class</span><span class="w"> </span><span class="nc">C4</span><span class="p">(</span><span class="n">Disjoint1</span><span class="p">,</span> <span class="n">Disjoint2</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">narrower</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Disjoint1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Disjoint2</span><span class="p">):</span>
        <span class="n">assert_never</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># OK: child class of `Disjoint1` and `Disjoint2` cannot exist</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">C1</span><span class="p">):</span>
        <span class="n">reveal_type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># Shows a non-empty type, e.g. `Disjoint1 &amp; C1`</span>
</pre></div>
</div>
</section>
<section id="runtime-implementation">
<h2><a class="toc-backref" href="#runtime-implementation" role="doc-backlink">Runtime implementation</a></h2>
<p>A new decorator, <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code>, will be added to the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module. Its runtime behavior (consistent with
similar decorators like <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code>) is to set an attribute <code class="docutils literal notranslate"><span class="pre">.__disjoint_base__</span> <span class="pre">=</span> <span class="pre">True</span></code> on the decorated object,
then return its argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">disjoint_base</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__disjoint_base__</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="bp">cls</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__disjoint_base__</span></code> attribute may be used for runtime introspection. However, there is no runtime
enforcement of this decorator on user-defined classes.</p>
<p>It will be useful to validate whether the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator should be applied in a stub. While
CPython does not document precisely which classes are disjoint bases, it is possible to replicate the behavior
of the interpreter using runtime introspection
(<a class="reference external" href="https://github.com/JelleZijlstra/pycroscope/blob/0d19236e4eda771175170a6b165b0e9f6a211d19/pycroscope/relations.py#L1469">example implementation</a>).
Stub validation tools, such as mypy’s <code class="docutils literal notranslate"><span class="pre">stubtest</span></code>, could use this logic to check whether the
<code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator is applied to the correct classes in stubs.</p>
</section>
<section id="backward-compatibility">
<h2><a class="toc-backref" href="#backward-compatibility" role="doc-backlink">Backward compatibility</a></h2>
<p>For compatibility with earlier versions of Python, the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator will be added to the
<code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code> backport package.</p>
<p>At runtime, the new decorator poses no compatibility issues.</p>
<p>In stubs, the decorator may be added to disjoint base classes even if not all type checkers understand the decorator yet;
such type checkers should simply treat the decorator as a no-op.</p>
<p>When type checkers add support for this PEP, users may see some changes in type checking behavior around reachability
and intersections. These changes should be positive, as they will better reflect the runtime behavior, and the scale of
user-visible changes is likely limited, similar to the normal amount of change between type checker versions. Type checkers
that are concerned about the impact of this change could use transition mechanisms such as opt-in flags.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>None known.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Most users will not have to directly use or understand the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator, as the expectation is that will be
primarily used in library stubs for low-level libraries. Teachers of Python can introduce
the concept of “disjoint bases” to explain why multiple inheritance is not allowed in certain cases. Teachers of
Python typing can introduce the decorator when teaching type narrowing constructs like <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> to
explain to users why type checkers treat certain branches as unreachable.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The runtime implementation of the <code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> decorator is available in
<a class="reference external" href="https://pypi.org/project/typing-extensions/4.15.0/">typing-extensions 4.15.0</a>.
<a class="reference external" href="https://github.com/python/mypy/pull/19678">python/mypy#19678</a>
implements support for disjoint bases in mypy and in the stubtest tool.
<a class="reference external" href="https://github.com/astral-sh/ruff/pull/20084">astral-sh/ruff#20084</a>
implements support for disjoint bases in the ty type checker.</p>
</section>
<section id="appendix">
<h2><a class="toc-backref" href="#appendix" role="doc-backlink">Appendix</a></h2>
<p>This appendix discusses the existing situation around multiple inheritance in the type system and
in the CPython runtime in more detail.</p>
<section id="solid-bases-in-cpython">
<span id="pep-800-solid-bases-cpython"></span><h3><a class="toc-backref" href="#solid-bases-in-cpython" role="doc-backlink">Solid bases in CPython</a></h3>
<p>The concept of “solid bases” has been part of the CPython implementation for a long time;
the concept dates back to <a class="reference external" href="https://github.com/python/cpython/commit/6d6c1a35e08b95a83dbe47dbd9e6474daff00354">a 2001 commit</a>.
Nevertheless, the concept has received little attention in the documentation.
Although details of the mechanism are closely tied to CPython’s internal object representation,
it is useful to explain at a high level how and why CPython works this way.</p>
<p>Every object in CPython is essentially a pointer to a C struct, a contiguous piece of memory that
contains information about the object. Some information is managed by the interpreter and shared
by many or all objects, such as a reference to the type of the object, and the attribute <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>
for user-defined objects. Some classes contain additional information that is specific to that class.
For example, user-defined classes with <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> contain a place in memory for each slot,
and the built-in <code class="docutils literal notranslate"><span class="pre">float</span></code> class contains a C <code class="docutils literal notranslate"><span class="pre">double</span></code> value that stores the value of the float.
This memory layout must be preserved for all instances of the class: C code that
interacts with a <code class="docutils literal notranslate"><span class="pre">float</span></code> expects to find the value at a particular offset in the object’s memory.</p>
<p>When a child class is created, CPython must create a memory layout for the new class that
is compatible with all of its parent classes. For example, when a child class of <code class="docutils literal notranslate"><span class="pre">float</span></code>
is created, it must be possible to pass instances of the child class to C code that interacts
directly with the underlying struct for the <code class="docutils literal notranslate"><span class="pre">float</span></code> class. Therefore, such a subclass must store
the <code class="docutils literal notranslate"><span class="pre">double</span></code> value at the same offset as the parent <code class="docutils literal notranslate"><span class="pre">float</span></code> class does. It may, however, add
additional fields at the end of the struct. CPython knows how to do this with the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>
attribute, which is why it is possible to create a child class of <code class="docutils literal notranslate"><span class="pre">float</span></code> that adds a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.</p>
<p>However, there is no way to combine a <code class="docutils literal notranslate"><span class="pre">float</span></code>, which must have a <code class="docutils literal notranslate"><span class="pre">double</span></code> in its struct,
with another C type like <code class="docutils literal notranslate"><span class="pre">int</span></code>, which stores different data at the same spot. Therefore,
a common subclass of <code class="docutils literal notranslate"><span class="pre">float</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code> cannot exist. We say that <code class="docutils literal notranslate"><span class="pre">float</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code>
are solid bases.</p>
<p>A class implemented in C is a solid base if it has an underlying struct that stores
data at a fixed offset, and that struct is different from the struct of its parent class.
A C class may also store a variable-size array of data (such as the contents of a string);
if this differs from the parent class, the class also becomes a solid base.
CPython’s implementation deduces this from the <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="(in Python v3.14)"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>
and <a class="reference external" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="(in Python v3.14)"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> fields of the type object, which are also
accessible from Python code as the undocumented attributes <code class="docutils literal notranslate"><span class="pre">__itemsize__</span></code> and <code class="docutils literal notranslate"><span class="pre">__basicsize__</span></code>
on type objects.</p>
<p>Similarly, classes implemented in Python are solid bases if they have <code class="docutils literal notranslate"><span class="pre">__slots__</span></code>, because
slots force a particular memory layout.</p>
</section>
<section id="mypy-s-incompatibility-check">
<span id="pep-800-mypy-incompatibility-check"></span><h3><a class="toc-backref" href="#mypy-s-incompatibility-check" role="doc-backlink">Mypy’s incompatibility check</a></h3>
<p>The mypy type checker considers two classes to be incompatible if they have
incompatible methods. For example, mypy considers the <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code> classes to be incompatible
because they have incompatible definitions of various methods. Given a class definition like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Mypy will output <code class="docutils literal notranslate"><span class="pre">Definition</span> <span class="pre">of</span> <span class="pre">&quot;__add__&quot;</span> <span class="pre">in</span> <span class="pre">base</span> <span class="pre">class</span> <span class="pre">&quot;int&quot;</span> <span class="pre">is</span> <span class="pre">incompatible</span> <span class="pre">with</span> <span class="pre">definition</span> <span class="pre">in</span> <span class="pre">base</span> <span class="pre">class</span> <span class="pre">&quot;str&quot;</span></code>,
and similar errors for a number of other methods. These errors are correct, because the definitions of
<code class="docutils literal notranslate"><span class="pre">__add__</span></code> in the two classes are indeed incompatible: <code class="docutils literal notranslate"><span class="pre">int.__add__</span></code> expects an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument, while
<code class="docutils literal notranslate"><span class="pre">str.__add__</span></code> expects a <code class="docutils literal notranslate"><span class="pre">str</span></code>. If this class were to exist, at runtime <code class="docutils literal notranslate"><span class="pre">__add__</span></code> would resolve to
<code class="docutils literal notranslate"><span class="pre">int.__add__</span></code>. Instances of <code class="docutils literal notranslate"><span class="pre">C</span></code> would also be members of the <code class="docutils literal notranslate"><span class="pre">str</span></code> type, but they would not support
some of the operations that <code class="docutils literal notranslate"><span class="pre">str</span></code> supports, such as concatenation with another <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<p>So far, so good. But mypy also uses very similar logic to conclude that no class
can inherit from both <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code>.
Nevertheless, it accepts the following class definition without error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">other</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">other</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">other</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">other</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">other</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">other</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">other</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
</pre></div>
</div>
<p>There is a similar situation with attributes. Given two classes with incompatible
attributes, mypy claims that a common subclass cannot exist, yet it accepts
a subclass that overrides these attributes to make them compatible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>

<span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Y</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">str</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no luck&quot;</span><span class="p">)</span>
    <span class="nd">@a</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>While the examples given so far rely on overrides that return <code class="docutils literal notranslate"><span class="pre">Never</span></code>, mypy’s rule
can also reject classes that have more practically useful implementations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Carnivore</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;meat&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;devouring meat&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Herbivore</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;plants&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nibbling on plants&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Omnivore</span><span class="p">(</span><span class="n">Carnivore</span><span class="p">,</span> <span class="n">Herbivore</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eating </span><span class="si">{</span><span class="n">food</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_it_both</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Carnivore</span><span class="p">):</span>
    <span class="c1"># mypy --warn-unreachable:</span>
    <span class="c1"># Subclass of &quot;Carnivore&quot; and &quot;Herbivore&quot; cannot exist: would have incompatible method signatures</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Herbivore</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Mypy’s rule works reasonably well in practice for deducing whether an intersection of two
classes is inhabited. Most builtin classes that are disjoint bases happen to implement common dunder
methods such as <code class="docutils literal notranslate"><span class="pre">__add__</span></code> and <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> in incompatible ways, so mypy will consider them
incompatible. There are some exceptions: mypy allows <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">C(BaseException,</span> <span class="pre">int):</span> <span class="pre">...</span></code>,
though both of these classes are disjoint bases and the class definition is rejected at runtime.
Conversely, when multiple inheritance is used in practice, usually the parent classes will not
have incompatible methods.</p>
<p>Thus, mypy’s approach to deciding that two classes cannot intersect is both too broad
(it incorrectly considers some intersections to be uninhabited) and too narrow (it misses
some intersections that are uninhabited because of disjoint bases). This is discussed in
<a class="reference external" href="https://github.com/python/mypy/issues/19377">an issue on the mypy tracker</a>.</p>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0800.rst">https://github.com/python/peps/blob/main/peps/pep-0800.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0800.rst">2025-08-25 19:44:56 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#invalid-class-definitions">Invalid class definitions</a></li>
<li><a class="reference internal" href="#reachability">Reachability</a></li>
<li><a class="reference internal" href="#overloads">Overloads</a></li>
<li><a class="reference internal" href="#intersection-types">Intersection types</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#naming">Naming</a></li>
<li><a class="reference internal" href="#runtime-restrictions-on-multiple-inheritance">Runtime restrictions on multiple inheritance</a></li>
<li><a class="reference internal" href="#disjoint-base-in-implementation-files"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> in implementation files</a></li>
<li><a class="reference internal" href="#disjoint-base-on-special-classes"><code class="docutils literal notranslate"><span class="pre">&#64;disjoint_base</span></code> on special classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#runtime-implementation">Runtime implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility">Backward compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#appendix">Appendix</a><ul>
<li><a class="reference internal" href="#solid-bases-in-cpython">Solid bases in CPython</a></li>
<li><a class="reference internal" href="#mypy-s-incompatibility-check">Mypy’s incompatibility check</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0800.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>