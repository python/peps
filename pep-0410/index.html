
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 410 – Use decimal.Decimal type for timestamps | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0410/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 410 – Use decimal.Decimal type for timestamps | peps.python.org'>
    <meta property="og:description" content="Decimal becomes the official type for high-resolution timestamps to make Python support new functions using a nanosecond resolution without loss of precision.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0410/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="Decimal becomes the official type for high-resolution timestamps to make Python support new functions using a nanosecond resolution without loss of precision.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 410</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 410 – Use decimal.Decimal type for timestamps</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Victor Stinner &lt;vstinner&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Formally declined and will not be accepted">Rejected</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">01-Feb-2012</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.3</dd>
<dt class="field-even">Resolution<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-February/116837.html">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#rejection-notice">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#objection-clocks-accuracy">Objection: clocks accuracy</a></li>
<li><a class="reference internal" href="#alternatives-timestamp-types">Alternatives: Timestamp types</a><ul>
<li><a class="reference internal" href="#number-of-nanoseconds-int">Number of nanoseconds (int)</a></li>
<li><a class="reference internal" href="#bits-float">128-bits float</a></li>
<li><a class="reference internal" href="#datetime-datetime">datetime.datetime</a></li>
<li><a class="reference internal" href="#datetime-timedelta">datetime.timedelta</a></li>
<li><a class="reference internal" href="#tuple-of-integers">Tuple of integers</a></li>
<li><a class="reference internal" href="#timespec-structure">timespec structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternatives-api-design">Alternatives: API design</a><ul>
<li><a class="reference internal" href="#add-a-string-argument-to-specify-the-return-type">Add a string argument to specify the return type</a></li>
<li><a class="reference internal" href="#add-a-global-flag-to-change-the-timestamp-type">Add a global flag to change the timestamp type</a></li>
<li><a class="reference internal" href="#add-a-protocol-to-create-a-timestamp">Add a protocol to create a timestamp</a></li>
<li><a class="reference internal" href="#add-new-fields-to-os-stat">Add new fields to os.stat</a></li>
<li><a class="reference internal" href="#add-a-boolean-argument">Add a boolean argument</a></li>
<li><a class="reference internal" href="#add-new-functions">Add new functions</a></li>
<li><a class="reference internal" href="#add-a-new-hires-module">Add a new hires module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#links">Links</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="rejection-notice">
<h2><a class="toc-backref" href="#rejection-notice" role="doc-backlink">Rejection Notice</a></h2>
<p>This PEP is rejected.
See <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-February/116837.html">https://mail.python.org/pipermail/python-dev/2012-February/116837.html</a>.</p>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>Decimal becomes the official type for high-resolution timestamps to make Python
support new functions using a nanosecond resolution without loss of precision.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Python 2.3 introduced float timestamps to support sub-second resolutions.
os.stat() uses float timestamps by default since Python 2.5. Python 3.3
introduced functions supporting nanosecond resolutions:</p>
<ul class="simple">
<li>os module: futimens(), utimensat()</li>
<li>time module: clock_gettime(), clock_getres(), monotonic(), wallclock()</li>
</ul>
<p>os.stat() reads nanosecond timestamps but returns timestamps as float.</p>
<p>The Python float type uses binary64 format of the IEEE 754 standard. With a
resolution of one nanosecond (10<sup>-9</sup>), float timestamps lose precision
for values bigger than 2<sup>24</sup> seconds (194 days: 1970-07-14 for an Epoch
timestamp).</p>
<p>Nanosecond resolution is required to set the exact modification time on
filesystems supporting nanosecond timestamps (e.g. ext4, btrfs, NTFS, …). It
helps also to compare the modification time to check if a file is newer than
another file. Use cases: copy the modification time of a file using
shutil.copystat(), create a TAR archive with the tarfile module, manage a
mailbox with the mailbox module, etc.</p>
<p>An arbitrary resolution is preferred over a fixed resolution (like nanosecond)
to not have to change the API when a better resolution is required. For
example, the NTP protocol uses fractions of 2<sup>32</sup> seconds
(approximately 2.3 × 10<sup>-10</sup> second), whereas the NTP protocol version
4 uses fractions of 2<sup>64</sup> seconds (5.4 × 10<sup>-20</sup> second).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With a resolution of 1 microsecond (10<sup>-6</sup>), float timestamps lose
precision for values bigger than 2<sup>33</sup> seconds (272 years: 2242-03-16
for an Epoch timestamp). With a resolution of 100 nanoseconds
(10<sup>-7</sup>, resolution used on Windows), float timestamps lose precision
for values bigger than 2<sup>29</sup> seconds (17 years: 1987-01-05 for an
Epoch timestamp).</p>
</div>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Add decimal.Decimal as a new type for timestamps. Decimal supports any
timestamp resolution, support arithmetic operations and is comparable. It is
possible to coerce a Decimal to float, even if the conversion may lose
precision. The clock resolution can also be stored in a Decimal object.</p>
<p>Add an optional <em>timestamp</em> argument to:</p>
<ul class="simple">
<li>os module: fstat(), fstatat(), lstat(), stat() (st_atime,
st_ctime and st_mtime fields of the stat structure),
sched_rr_get_interval(), times(), wait3() and wait4()</li>
<li>resource module: ru_utime and ru_stime fields of getrusage()</li>
<li>signal module: getitimer(), setitimer()</li>
<li>time module: clock(), clock_gettime(), clock_getres(),
monotonic(), time() and wallclock()</li>
</ul>
<p>The <em>timestamp</em> argument value can be float or Decimal, float is still the
default for backward compatibility. The following functions support Decimal as
input:</p>
<ul class="simple">
<li>datetime module: date.fromtimestamp(), datetime.fromtimestamp() and
datetime.utcfromtimestamp()</li>
<li>os module: futimes(), futimesat(), lutimes(), utime()</li>
<li>select module: epoll.poll(), kqueue.control(), select()</li>
<li>signal module: setitimer(), sigtimedwait()</li>
<li>time module: ctime(), gmtime(), localtime(), sleep()</li>
</ul>
<p>The os.stat_float_times() function is deprecated: use an explicit cast using
int() instead.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The decimal module is implemented in Python and is slower than float, but
there is a new C implementation which is almost ready for inclusion in
CPython.</p>
</div>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>The default timestamp type (float) is unchanged, so there is no impact on
backward compatibility nor on performances. The new timestamp type,
decimal.Decimal, is only returned when requested explicitly.</p>
</section>
<section id="objection-clocks-accuracy">
<h2><a class="toc-backref" href="#objection-clocks-accuracy" role="doc-backlink">Objection: clocks accuracy</a></h2>
<p>Computer clocks and operating systems are inaccurate and fail to provide
nanosecond accuracy in practice. A nanosecond is what it takes to execute a
couple of CPU instructions.  Even on a real-time operating system, a
nanosecond-precise measurement is already obsolete when it starts being
processed by the higher-level application. A single cache miss in the CPU will
make the precision worthless.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linux <em>actually</em> is able to measure time in nanosecond precision, even
though it is not able to keep its clock synchronized to UTC with a
nanosecond accuracy.</p>
</div>
</section>
<section id="alternatives-timestamp-types">
<h2><a class="toc-backref" href="#alternatives-timestamp-types" role="doc-backlink">Alternatives: Timestamp types</a></h2>
<p>To support timestamps with an arbitrary or nanosecond resolution, the following
types have been considered:</p>
<ul class="simple">
<li>decimal.Decimal</li>
<li>number of nanoseconds</li>
<li>128-bits float</li>
<li>datetime.datetime</li>
<li>datetime.timedelta</li>
<li>tuple of integers</li>
<li>timespec structure</li>
</ul>
<p>Criteria:</p>
<ul class="simple">
<li>Doing arithmetic on timestamps must be possible</li>
<li>Timestamps must be comparable</li>
<li>An arbitrary resolution, or at least a resolution of one nanosecond without
losing precision</li>
<li>It should be possible to coerce the new timestamp to float for backward
compatibility</li>
</ul>
<p>A resolution of one nanosecond is enough to support all current C functions.</p>
<p>The best resolution used by operating systems is one nanosecond. In practice,
most clock accuracy is closer to microseconds than nanoseconds. So it sounds
reasonable to use a fixed resolution of one nanosecond.</p>
<section id="number-of-nanoseconds-int">
<h3><a class="toc-backref" href="#number-of-nanoseconds-int" role="doc-backlink">Number of nanoseconds (int)</a></h3>
<p>A nanosecond resolution is enough for all current C functions and so a
timestamp can simply be a number of nanoseconds, an integer, not a float.</p>
<p>The number of nanoseconds format has been rejected because it would require to
add new specialized functions for this format because it not possible to
differentiate a number of nanoseconds and a number of seconds just by checking
the object type.</p>
</section>
<section id="bits-float">
<h3><a class="toc-backref" href="#bits-float" role="doc-backlink">128-bits float</a></h3>
<p>Add a new IEEE 754-2008 quad-precision binary float type. The IEEE 754-2008
quad precision float has 1 sign bit, 15 bits of exponent and 112 bits of
mantissa.  128-bits float is supported by GCC (4.3), Clang and ICC compilers.</p>
<p>Python must be portable and so cannot rely on a type only available on some
platforms. For example, Visual C++ 2008 doesn’t support 128-bits float, whereas
it is used to build the official Windows executables. Another example: GCC 4.3
does not support __float128 in 32-bit mode on x86 (but GCC 4.4 does).</p>
<p>There is also a license issue: GCC uses the MPFR library for 128-bits float,
library distributed under the GNU LGPL license. This license is not compatible
with the Python license.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The x87 floating point unit of Intel CPU supports 80-bit floats. This format
is not supported by the SSE instruction set, which is now preferred over
float, especially on x86_64. Other CPU vendors don’t support 80-bit float.</p>
</div>
</section>
<section id="datetime-datetime">
<h3><a class="toc-backref" href="#datetime-datetime" role="doc-backlink">datetime.datetime</a></h3>
<p>The datetime.datetime type is the natural choice for a timestamp because it is
clear that this type contains a timestamp, whereas int, float and Decimal are
raw numbers. It is an absolute timestamp and so is well defined. It gives
direct access to the year, month, day, hours, minutes and seconds. It has
methods related to time like methods to format the timestamp as string (e.g.
datetime.datetime.strftime).</p>
<p>The major issue is that except os.stat(), time.time() and
time.clock_gettime(time.CLOCK_GETTIME), all time functions have an unspecified
starting point and no timezone information, and so cannot be converted to
datetime.datetime.</p>
<p>datetime.datetime has also issues with timezone. For example, a datetime object
without timezone (unaware) and a datetime with a timezone (aware) cannot be
compared. There is also an ordering issues with daylight saving time (DST) in
the duplicate hour of switching from DST to normal time.</p>
<p>datetime.datetime has been rejected because it cannot be used for functions
using an unspecified starting point like os.times() or time.clock().</p>
<p>For time.time() and time.clock_gettime(time.CLOCK_GETTIME): it is already
possible to get the current time as a datetime.datetime object using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
</pre></div>
</div>
<p>For os.stat(), it is simple to create a datetime.datetime object from a
decimal.Decimal timestamp in the UTC timezone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>datetime.datetime only supports microsecond resolution, but can be enhanced
to support nanosecond.</p>
</div>
</section>
<section id="datetime-timedelta">
<h3><a class="toc-backref" href="#datetime-timedelta" role="doc-backlink">datetime.timedelta</a></h3>
<p>datetime.timedelta is the natural choice for a relative timestamp because it is
clear that this type contains a timestamp, whereas int, float and Decimal are
raw numbers. It can be used with datetime.datetime to get an absolute timestamp
when the starting point is known.</p>
<p>datetime.timedelta has been rejected because it cannot be coerced to float and
has a fixed resolution. One new standard timestamp type is enough, Decimal is
preferred over datetime.timedelta. Converting a datetime.timedelta to float
requires an explicit call to the datetime.timedelta.total_seconds() method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>datetime.timedelta only supports microsecond resolution, but can be enhanced
to support nanosecond.</p>
</div>
</section>
<section id="tuple-of-integers">
<span id="tuple"></span><h3><a class="toc-backref" href="#tuple-of-integers" role="doc-backlink">Tuple of integers</a></h3>
<p>To expose C functions in Python, a tuple of integers is the natural choice to
store a timestamp because the C language uses structures with integers fields
(e.g. timeval and timespec structures). Using only integers avoids the loss of
precision (Python supports integers of arbitrary length). Creating and parsing
a tuple of integers is simple and fast.</p>
<p>Depending of the exact format of the tuple, the precision can be arbitrary or
fixed. The precision can be choose as the loss of precision is smaller than
an arbitrary limit like one nanosecond.</p>
<p>Different formats have been proposed:</p>
<ul class="simple">
<li>A: (numerator, denominator)<ul>
<li>value = numerator / denominator</li>
<li>resolution = 1 / denominator</li>
<li>denominator &gt; 0</li>
</ul>
</li>
<li>B: (seconds, numerator, denominator)<ul>
<li>value = seconds + numerator / denominator</li>
<li>resolution = 1 / denominator</li>
<li>0 &lt;= numerator &lt; denominator</li>
<li>denominator &gt; 0</li>
</ul>
</li>
<li>C: (intpart, floatpart, base, exponent)<ul>
<li>value = intpart + floatpart / base<sup>exponent</sup></li>
<li>resolution = 1 / base <sup>exponent</sup></li>
<li>0 &lt;= floatpart &lt; base <sup>exponent</sup></li>
<li>base &gt; 0</li>
<li>exponent &gt;= 0</li>
</ul>
</li>
<li>D: (intpart, floatpart, exponent)<ul>
<li>value = intpart + floatpart / 10<sup>exponent</sup></li>
<li>resolution = 1 / 10 <sup>exponent</sup></li>
<li>0 &lt;= floatpart &lt; 10 <sup>exponent</sup></li>
<li>exponent &gt;= 0</li>
</ul>
</li>
<li>E: (sec, nsec)<ul>
<li>value = sec + nsec × 10<sup>-9</sup></li>
<li>resolution = 10 <sup>-9</sup> (nanosecond)</li>
<li>0 &lt;= nsec &lt; 10 <sup>9</sup></li>
</ul>
</li>
</ul>
<p>All formats support an arbitrary resolution, except of the format (E).</p>
<p>The format (D) may not be able to store the exact value (may loss of precision)
if the clock frequency is arbitrary and cannot be expressed as a power of 10.
The format (C) has a similar issue, but in such case, it is possible to use
base=frequency and exponent=1.</p>
<p>The formats (C), (D) and (E) allow optimization for conversion to float if the
base is 2 and to decimal.Decimal if the base is 10.</p>
<p>The format (A) is a simple fraction. It supports arbitrary precision, is simple
(only two fields), only requires a simple division to get the floating point
value, and is already used by float.as_integer_ratio().</p>
<p>To simplify the implementation (especially the C implementation to avoid
integer overflow), a numerator bigger than the denominator can be accepted.
The tuple may be normalized later.</p>
<p>Tuple of integers have been rejected because they don’t support arithmetic
operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows, the <code class="docutils literal notranslate"><span class="pre">QueryPerformanceCounter()</span></code> clock uses the frequency of
the processor which is an arbitrary number and so may not be a power or 2 or
10. The frequency can be read using <code class="docutils literal notranslate"><span class="pre">QueryPerformanceFrequency()</span></code>.</p>
</div>
</section>
<section id="timespec-structure">
<h3><a class="toc-backref" href="#timespec-structure" role="doc-backlink">timespec structure</a></h3>
<p>timespec is the C structure used to store timestamp with a nanosecond
resolution. Python can use a type with the same structure: (seconds,
nanoseconds). For convenience, arithmetic operations on timespec are supported.</p>
<p>Example of an incomplete timespec type supporting addition, subtraction and
coercion to float:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">timespec</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">nsec</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">asec</span><span class="p">,</span> <span class="n">nsec</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">+=</span> <span class="n">asec</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">nsec</span><span class="p">))</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">sec</span> <span class="o">=</span> <span class="n">sec</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">nsec</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span> <span class="o">*</span> <span class="mf">1e-9</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">total_nanoseconds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">timespec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">ns_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nanoseconds</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">total_nanoseconds</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">timespec</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">ns_sum</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">timespec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">ns_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nanoseconds</span><span class="p">()</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">total_nanoseconds</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">timespec</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">ns_diff</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span><span class="p">:</span>
            <span class="n">sec</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec</span><span class="p">)</span>
            <span class="n">nsec</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span>
            <span class="k">return</span> <span class="s1">&#39;-</span><span class="si">%i</span><span class="s1">.</span><span class="si">%09u</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">nsec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%i</span><span class="s1">.</span><span class="si">%09u</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;timespec(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsec</span><span class="p">)</span>
</pre></div>
</div>
<p>The timespec type is similar to the format (E) of tuples of integer, except
that it supports arithmetic and coercion to float.</p>
<p>The timespec type was rejected because it only supports nanosecond resolution
and requires to implement each arithmetic operation, whereas the Decimal type
is already implemented and well tested.</p>
</section>
</section>
<section id="alternatives-api-design">
<h2><a class="toc-backref" href="#alternatives-api-design" role="doc-backlink">Alternatives: API design</a></h2>
<section id="add-a-string-argument-to-specify-the-return-type">
<h3><a class="toc-backref" href="#add-a-string-argument-to-specify-the-return-type" role="doc-backlink">Add a string argument to specify the return type</a></h3>
<p>Add a string argument to function returning timestamps, example:
time.time(format=”datetime”). A string is more extensible than a type: it is
possible to request a format that has no type, like a tuple of integers.</p>
<p>This API was rejected because it was necessary to import implicitly modules to
instantiate objects (e.g. import datetime to create datetime.datetime).
Importing a module may raise an exception and may be slow, such behaviour is
unexpected and surprising.</p>
</section>
<section id="add-a-global-flag-to-change-the-timestamp-type">
<h3><a class="toc-backref" href="#add-a-global-flag-to-change-the-timestamp-type" role="doc-backlink">Add a global flag to change the timestamp type</a></h3>
<p>A global flag like os.stat_decimal_times(), similar to os.stat_float_times(),
can be added to set globally the timestamp type.</p>
<p>A global flag may cause issues with libraries and applications expecting float
instead of Decimal. Decimal is not fully compatible with float. float+Decimal
raises a TypeError for example. The os.stat_float_times() case is different
because an int can be coerced to float and int+float gives float.</p>
</section>
<section id="add-a-protocol-to-create-a-timestamp">
<h3><a class="toc-backref" href="#add-a-protocol-to-create-a-timestamp" role="doc-backlink">Add a protocol to create a timestamp</a></h3>
<p>Instead of hard coding how timestamps are created, a new protocol can be added
to create a timestamp from a fraction.</p>
<p>For example, time.time(timestamp=type) would call the class method
type.__fromfraction__(numerator, denominator) to create a timestamp object of
the specified type. If the type doesn’t support the protocol, a fallback is
used: type(numerator) / type(denominator).</p>
<p>A variant is to use a “converter” callback to create a timestamp. Example
creating a float timestamp:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">timestamp_to_float</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">numerator</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">denominator</span><span class="p">)</span>
</pre></div>
</div>
<p>Common converters can be provided by time, datetime and other modules, or maybe
a specific “hires” module. Users can define their own converters.</p>
<p>Such protocol has a limitation: the timestamp structure has to be decided once
and cannot be changed later. For example, adding a timezone or the absolute
start of the timestamp would break the API.</p>
<p>The protocol proposition was as being excessive given the requirements, but
that the specific syntax proposed (time.time(timestamp=type)) allows this to be
introduced later if compelling use cases are discovered.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other formats may be used instead of a fraction: see the tuple of integers
section for example.</p>
</div>
</section>
<section id="add-new-fields-to-os-stat">
<h3><a class="toc-backref" href="#add-new-fields-to-os-stat" role="doc-backlink">Add new fields to os.stat</a></h3>
<p>To get the creation, modification and access time of a file with a nanosecond
resolution, three fields can be added to os.stat() structure.</p>
<p>The new fields can be timestamps with nanosecond resolution (e.g. Decimal) or
the nanosecond part of each timestamp (int).</p>
<p>If the new fields are timestamps with nanosecond resolution, populating the
extra fields would be time-consuming. Any call to os.stat() would be slower,
even if os.stat() is only called to check if a file exists. A parameter can be
added to os.stat() to make these fields optional, the structure would have a
variable number of fields.</p>
<p>If the new fields only contain the fractional part (nanoseconds), os.stat()
would be efficient. These fields would always be present and so set to zero if
the operating system does not support sub-second resolution. Splitting a
timestamp in two parts, seconds and nanoseconds, is similar to the timespec
type and tuple of integers, and so have the same drawbacks.</p>
<p>Adding new fields to the os.stat() structure does not solve the nanosecond
issue in other modules (e.g. the time module).</p>
</section>
<section id="add-a-boolean-argument">
<h3><a class="toc-backref" href="#add-a-boolean-argument" role="doc-backlink">Add a boolean argument</a></h3>
<p>Because we only need one new type (Decimal), a simple boolean flag can be
added. Example: time.time(decimal=True) or time.time(hires=True).</p>
<p>Such flag would require to do a hidden import which is considered as a bad
practice.</p>
<p>The boolean argument API was rejected because it is not “pythonic”. Changing
the return type with a parameter value is preferred over a boolean parameter (a
flag).</p>
</section>
<section id="add-new-functions">
<h3><a class="toc-backref" href="#add-new-functions" role="doc-backlink">Add new functions</a></h3>
<p>Add new functions for each type, examples:</p>
<ul class="simple">
<li>time.clock_decimal()</li>
<li>time.time_decimal()</li>
<li>os.stat_decimal()</li>
<li>os.stat_timespec()</li>
<li>etc.</li>
</ul>
<p>Adding a new function for each function creating timestamps duplicate a lot of
code and would be a pain to maintain.</p>
</section>
<section id="add-a-new-hires-module">
<h3><a class="toc-backref" href="#add-a-new-hires-module" role="doc-backlink">Add a new hires module</a></h3>
<p>Add a new module called “hires” with the same API than the time module, except
that it would return timestamp with high resolution, e.g. decimal.Decimal.
Adding a new module avoids to link low-level modules like time or os to the
decimal module.</p>
<p>This idea was rejected because it requires to duplicate most of the code of the
time module, would be a pain to maintain, and timestamps are used modules other
than the time module. Examples: signal.sigtimedwait(), select.select(),
resource.getrusage(), os.stat(), etc. Duplicate the code of each module is not
acceptable.</p>
</section>
</section>
<section id="links">
<h2><a class="toc-backref" href="#links" role="doc-backlink">Links</a></h2>
<p>Python:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue7652">Issue #7652: Merge C version of decimal into py3k</a> (cdecimal)</li>
<li><a class="reference external" href="http://bugs.python.org/issue11457">Issue #11457: os.stat(): add new fields to get timestamps as Decimal objects with nanosecond resolution</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue13882">Issue #13882: PEP 410: Use decimal.Decimal type for timestamps</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-January/116025.html">[Python-Dev] Store timestamps as decimal.Decimal objects</a></li>
</ul>
<p>Other languages:</p>
<ul class="simple">
<li>Ruby (1.9.3), the <a class="reference external" href="http://ruby-doc.org/core-1.9.3/Time.html">Time class</a>
supports picosecond (10<sup>-12</sup>)</li>
<li>.NET framework, <a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.datetime.ticks.aspx">DateTime type</a>:
number of 100-nanosecond intervals that have elapsed since 12:00:00
midnight, January 1, 0001. DateTime.Ticks uses a signed 64-bit integer.</li>
<li>Java (1.5), <a class="reference external" href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/System.html#nanoTime()">System.nanoTime()</a>:
wallclock with an unspecified starting point as a number of nanoseconds, use
a signed 64 bits integer (long).</li>
<li>Perl, <a class="reference external" href="http://perldoc.perl.org/Time/HiRes.html">Time::Hiref module</a>:
use float so has the same loss of precision issue with nanosecond resolution
than Python float timestamps</li>
</ul>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0410.rst">https://github.com/python/peps/blob/main/peps/pep-0410.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0410.rst">2025-02-01 08:59:27 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#rejection-notice">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#objection-clocks-accuracy">Objection: clocks accuracy</a></li>
<li><a class="reference internal" href="#alternatives-timestamp-types">Alternatives: Timestamp types</a><ul>
<li><a class="reference internal" href="#number-of-nanoseconds-int">Number of nanoseconds (int)</a></li>
<li><a class="reference internal" href="#bits-float">128-bits float</a></li>
<li><a class="reference internal" href="#datetime-datetime">datetime.datetime</a></li>
<li><a class="reference internal" href="#datetime-timedelta">datetime.timedelta</a></li>
<li><a class="reference internal" href="#tuple-of-integers">Tuple of integers</a></li>
<li><a class="reference internal" href="#timespec-structure">timespec structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternatives-api-design">Alternatives: API design</a><ul>
<li><a class="reference internal" href="#add-a-string-argument-to-specify-the-return-type">Add a string argument to specify the return type</a></li>
<li><a class="reference internal" href="#add-a-global-flag-to-change-the-timestamp-type">Add a global flag to change the timestamp type</a></li>
<li><a class="reference internal" href="#add-a-protocol-to-create-a-timestamp">Add a protocol to create a timestamp</a></li>
<li><a class="reference internal" href="#add-new-fields-to-os-stat">Add new fields to os.stat</a></li>
<li><a class="reference internal" href="#add-a-boolean-argument">Add a boolean argument</a></li>
<li><a class="reference internal" href="#add-new-functions">Add new functions</a></li>
<li><a class="reference internal" href="#add-a-new-hires-module">Add a new hires module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#links">Links</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0410.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>