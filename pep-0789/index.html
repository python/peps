
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 789 – Preventing task-cancellation bugs by limiting yield in async generators | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0789/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 789 – Preventing task-cancellation bugs by limiting yield in async generators | peps.python.org'>
    <meta property="og:description" content="Structured concurrency is increasingly popular in Python.  Interfaces such as the asyncio.TaskGroup and asyncio.timeout context managers support compositional reasoning, and allow developers to clearly scope the lifetimes of concurrent tasks. However, u...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0789/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="Structured concurrency is increasingly popular in Python.  Interfaces such as the asyncio.TaskGroup and asyncio.timeout context managers support compositional reasoning, and allow developers to clearly scope the lifetimes of concurrent tasks. However, u...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 789</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 789 – Preventing task-cancellation bugs by limiting yield in async generators</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Zac Hatfield-Dodds &lt;zac&#32;&#97;t&#32;zhd.dev&gt;,
Nathaniel J. Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;</dd>
<dt class="field-even">PEP-Delegate<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">14-May-2024</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.14</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#problem-statement">Problem statement</a></li>
<li><a class="reference internal" href="#motivating-examples">Motivating examples</a><ul>
<li><a class="reference internal" href="#leaking-a-timeout-to-the-outer-scope">Leaking a timeout to the outer scope</a></li>
<li><a class="reference internal" href="#leaking-background-tasks-breaks-cancellation-and-exception-handling">Leaking background tasks (breaks cancellation and exception handling)</a></li>
<li><a class="reference internal" href="#in-a-user-defined-context-manager">In a user-defined context manager</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#implementation-tracking-frames">Implementation - tracking frames</a></li>
<li><a class="reference internal" href="#worked-examples">Worked examples</a><ul>
<li><a class="reference internal" href="#no-yield-example">No-yield example</a></li>
<li><a class="reference internal" href="#attempts-to-yield-example">Attempts-to-yield example</a></li>
<li><a class="reference internal" href="#allowed-to-yield-example">Allowed-to-yield example</a></li>
<li><a class="reference internal" href="#allowing-yield-for-context-managers">Allowing yield for context managers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#behavior-if-sys-prevent-yields-is-misused">Behavior if <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> is misused</a></li>
</ul>
</li>
<li><a class="reference internal" href="#anticipated-uses">Anticipated uses</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#how-widespread-is-this-bug">How widespread is this bug?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternatives">Rejected alternatives</a><ul>
<li><a class="reference internal" href="#pep-533-deterministic-cleanup-for-iterators">PEP 533, deterministic cleanup for iterators</a></li>
<li><a class="reference internal" href="#deprecate-async-generators-entirely">Deprecate async generators entirely</a></li>
<li><a class="reference internal" href="#can-t-we-just-deliver-exceptions-to-the-right-place">Can’t we just deliver exceptions to the right place?</a></li>
<li><a class="reference internal" href="#alternative-implementation-inspecting-bytecode">Alternative implementation - inspecting bytecode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p><a class="reference external" href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Structured concurrency</a> is increasingly popular in Python.  Interfaces such as
the <code class="docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code> and <code class="docutils literal notranslate"><span class="pre">asyncio.timeout</span></code> context managers support
compositional reasoning, and allow developers to clearly scope the lifetimes of
concurrent tasks. However, using <code class="docutils literal notranslate"><span class="pre">yield</span></code> to suspend a frame inside such a
context leads to situations where the wrong task is canceled, timeouts are
ignored, and exceptions are mishandled. More fundamentally, suspending a frame
inside a <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code> violates the structured concurrency design principle that
child tasks are encapsulated within their parent frame.</p>
<p>To address these issues, this PEP proposes a new <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields()</span></code> context
manager. When syntactically inside this context, attempting to <code class="docutils literal notranslate"><span class="pre">yield</span></code> will
raise a RuntimeError, preventing the task from yielding. Additionally, a
mechanism will be provided for decorators such as <code class="docutils literal notranslate"><span class="pre">&#64;contextmanager</span></code> to allow
yields inside the decorated function.  <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields()</span></code> will be used by
asyncio and downstream libraries to implement task groups, timeouts, and
cancellation; and a related mechanism by <code class="docutils literal notranslate"><span class="pre">contextlib</span></code> etc. to convert
generators into context managers which allow safe yields.</p>
</section>
<section id="background">
<h2><a class="toc-backref" href="#background" role="doc-backlink">Background</a></h2>
<p>Structured concurrency is increasingly popular in Python, in the form of newer
<a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> interfaces and third-party libraries such as Trio and anyio.
These interfaces support compositional reasoning, <em>so long as</em> users never write
a <code class="docutils literal notranslate"><span class="pre">yield</span></code> which suspends a frame while inside a cancel scope.</p>
<p>A cancel scope is a context manager which can… cancel… whatever work occurs
within that context (…scope).  In asyncio, this is implicit in the design of
<code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">asyncio.timeout():</span></code> or <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span> <span class="pre">asyncio.TaskGroup()</span> <span class="pre">as</span> <span class="pre">tg:</span></code>, which
respectively cancel the contained work after the specified duration, or cancel
sibling tasks when one of them raises an exception.  The core functionality of
a cancel scope is synchronous, but the user-facing context managers may be
either sync or async. <a class="footnote-reference brackets" href="#trio-cancel-scope" id="id1">[1]</a> <a class="footnote-reference brackets" href="#tg-cs" id="id2">[2]</a></p>
<p>This structured approach works beautifully, unless you hit one specific sharp
edge: breaking the nesting structure by <code class="docutils literal notranslate"><span class="pre">yield</span></code>ing inside a cancel scope.
This has much the same effect on structured control flow as adding just a few
cross-function <code class="docutils literal notranslate"><span class="pre">goto</span></code>s, and the effects are truly dire:</p>
<ul class="simple">
<li>The wrong task can be canceled, whether due to a timeout, an error in a
sibling task, or an explicit request to cancel some other task</li>
<li>Exceptions, including <code class="docutils literal notranslate"><span class="pre">CancelledError</span></code>, can be delivered to the wrong task</li>
<li>Exceptions can go missing entirely, being dropped instead of added to an
<code class="docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></li>
</ul>
</section>
<section id="problem-statement">
<h2><a class="toc-backref" href="#problem-statement" role="doc-backlink">Problem statement</a></h2>
<p>Here’s the fundamental issue: yield suspends a call frame. It only makes sense
to yield in a leaf frame – i.e., if your call stack goes like A -&gt; B -&gt; C, then
you can suspend C, but you can’t suspend B while leaving C running.</p>
<p>But, TaskGroup is a kind of “concurrent call” primitive, where a single frame
can have multiple child frames that run concurrently. This means that if we
allow people to mix yield and TaskGroup, then we can end up in exactly this
situation, where B gets suspended but C is actively running. This is
nonsensical, and causes serious practical problems (e.g., if C raises an
exception and A has returned, we have no way to propagate it).</p>
<p>This is a fundamental incompatibility between generator control flow and
structured concurrency control flow, not something we can fix by tweaking our
APIs. The only solution seems to be to forbid yield inside a TaskGroup.</p>
<p>Although timeouts don’t leave a child task running, the close analogy and
related problems lead us to conclude that yield should be forbidden inside all
cancel scopes, not only TaskGroups.  See <a class="reference internal" href="#just-deliver"><span class="std std-ref">Can’t we just deliver exceptions to the right place?</span></a> for discussion.</p>
</section>
<section id="motivating-examples">
<h2><a class="toc-backref" href="#motivating-examples" role="doc-backlink">Motivating examples</a></h2>
<p>Let’s consider three examples, to see what this might look like in practice.</p>
<section id="leaking-a-timeout-to-the-outer-scope">
<h3><a class="toc-backref" href="#leaking-a-timeout-to-the-outer-scope" role="doc-backlink">Leaking a timeout to the outer scope</a></h3>
<p>Suppose that we want to iterate over an async iterator, but wait for at most
<code class="docutils literal notranslate"><span class="pre">max_time</span></code> seconds for each element.  We might naturally encapsulate the logic
for doing so in an async generator, so that the call site can continue to use a
straightforward <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">iter_with_timeout</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">max_time</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">timeout</span><span class="p">(</span><span class="n">max_time</span><span class="p">):</span>
                <span class="k">yield</span> <span class="k">await</span> <span class="n">anext</span><span class="p">(</span><span class="n">ait</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopAsyncIteration</span><span class="p">:</span>
        <span class="k">return</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fn</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iter_with_timeout</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">max_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">do_something_with</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, there’s a bug in this version: the timeout might expire after the
generator yields but before it is resumed!  In this case, we’ll see a
<code class="docutils literal notranslate"><span class="pre">CancelledError</span></code> raised in the outer task, where it cannot be caught by the
<code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">timeout(max_time):</span></code> statement.</p>
<p>The fix is fairly simple: get the next element inside the timeout context, and
then yield <em>outside</em> that context.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">correct_iter_with_timeout</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">max_time</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">timeout</span><span class="p">(</span><span class="n">max_time</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="k">await</span> <span class="n">anext</span><span class="p">(</span><span class="n">ait</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">tmp</span>
    <span class="k">except</span> <span class="ne">StopAsyncIteration</span><span class="p">:</span>
        <span class="k">return</span>
</pre></div>
</div>
</section>
<section id="leaking-background-tasks-breaks-cancellation-and-exception-handling">
<h3><a class="toc-backref" href="#leaking-background-tasks-breaks-cancellation-and-exception-handling" role="doc-backlink">Leaking background tasks (breaks cancellation and exception handling)</a></h3>
<p>Timeouts are not the only interface which wrap a cancel scope - and if you
need some background worker tasks, you can’t simply close the <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code>
before yielding.</p>
<p>As an example, let’s look at a fan-in generator, which we’ll use to merge the
feeds from several “sensors”.  We’ll also set up our mock sensors with a small
buffer, so that we’ll raise an error in the background task while control flow
is outside the <code class="docutils literal notranslate"><span class="pre">combined_iterators</span></code> generator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">mock_sensor</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">():</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>  <span class="c1"># &#39;presence detection&#39;</span>
            <span class="k">yield</span> <span class="s2">&quot;PRESENT&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>  <span class="c1"># inject a simple bug</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;oops, raising RuntimeError&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># non-presence sensor data</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">move_elements_to_queue</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ait</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">combined_iterators</span><span class="p">(</span><span class="o">*</span><span class="n">aits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine async iterators by starting N tasks, each of</span>
<span class="sd">    which move elements from one iterable to a shared queue.&quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ait</span> <span class="ow">in</span> <span class="n">aits</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">move_elements_to_queue</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="k">await</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">turn_on_lights_when_someone_gets_home</span><span class="p">():</span>
    <span class="n">combined</span> <span class="o">=</span> <span class="n">combined_iterators</span><span class="p">(</span><span class="n">mock_sensor</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">mock_sensor</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">combined</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s2">&quot;PRESENT&quot;</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;main task sleeping for a bit&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># do some other operation</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">turn_on_lights_when_someone_gets_home</span><span class="p">())</span>
</pre></div>
</div>
<p>When we run this code, we see the expected sequence of observations, then a
‘detection’, and then while the main task is sleeping we trigger that
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> in the background.  But… we don’t actually observe the
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>, not even as the <code class="docutils literal notranslate"><span class="pre">__context__</span></code> of another exception!</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt; python3.11 demo.py</span>
<span class="go">a-0</span>
<span class="go">b-0</span>
<span class="go">a-1</span>
<span class="go">PRESENT</span>
<span class="go">main task sleeping for a bit</span>
<span class="go">oops, raising RuntimeError</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;demo.py&quot;</span>, line <span class="m">39</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">turn_on_lights_when_someone_gets_home</span><span class="p">())</span>
<span class="w">  </span><span class="c">...</span>
  File <span class="nb">&quot;demo.py&quot;</span>, line <span class="m">37</span>, in <span class="n">turn_on_lights_when_someone_gets_home</span>
<span class="w">    </span><span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># do some other operation</span>
  File <span class="nb">&quot;.../python3.11/asyncio/tasks.py&quot;</span>, line <span class="m">649</span>, in <span class="n">sleep</span>
<span class="w">    </span><span class="k">return</span> <span class="k">await</span> <span class="n">future</span>
<span class="gr">asyncio.exceptions.CancelledError</span>
</pre></div>
</div>
<p>Here, again, the problem is that we’ve <code class="docutils literal notranslate"><span class="pre">yield</span></code>ed inside a cancel scope;
this time the scope which a <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code> uses to cancel sibling tasks when one
of the child tasks raises an exception.  However, the <code class="docutils literal notranslate"><span class="pre">CancelledError</span></code> which
was intended for the sibling task was instead injected into the <em>outer</em> task,
and so we never got a chance to create and raise an
<code class="docutils literal notranslate"><span class="pre">ExceptionGroup(...,</span> <span class="pre">[RuntimeError()])</span></code>.</p>
<p>To fix this, we need to turn our async generator into an async context manager,
which yields an async iterable - in this case a generator wrapping the queue; in
future <a class="reference external" href="https://github.com/python/cpython/issues/119154">perhaps the queue itself</a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">queue_as_aiterable</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="c1"># async generators that don&#39;t `yield` inside a cancel scope are fine!</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">QueueShutDown</span><span class="p">:</span>
            <span class="k">return</span>

<span class="nd">@asynccontextmanager</span>  <span class="c1">#  yield-in-cancel-scope is OK in a context manager</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">combined_iterators</span><span class="p">(</span><span class="o">*</span><span class="n">aits</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ait</span> <span class="ow">in</span> <span class="n">aits</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">move_elements_to_queue</span><span class="p">(</span><span class="n">ait</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">queue_as_aiterable</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">turn_on_lights_when_someone_gets_home</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">combined_iterators</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="k">as</span> <span class="n">ait</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">ait</span><span class="p">:</span>
            <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="in-a-user-defined-context-manager">
<h3><a class="toc-backref" href="#in-a-user-defined-context-manager" role="doc-backlink">In a user-defined context manager</a></h3>
<p>Yielding inside a cancel scope can be safe, if and only if you’re using the
generator to implement a context manager <a class="footnote-reference brackets" href="#redirected" id="id3">[3]</a> - in this case any
propagating exceptions will be redirected to the expected task.</p>
<p>We’ve also implemented the <code class="docutils literal notranslate"><span class="pre">ASYNC101</span></code> linter rule in <a class="reference external" href="https://pypi.org/project/flake8-async/">flake8-async</a>, which warns against yielding in
known cancel scopes.  Could user education be sufficient to avoid these
problems?  Unfortunately not: user-defined context managers can also wrap a
cancel scope, and it’s infeasible to recognize or lint for all such cases.</p>
<p>This regularly arises in practice, because ‘run some background tasks for the
duration of this context’ is a very common pattern in structured concurrency.
We saw that in <code class="docutils literal notranslate"><span class="pre">combined_iterators()</span></code> above; and have seen this bug in
multiple implementations of the websocket protocol:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">get_messages</span><span class="p">(</span><span class="n">websocket_url</span><span class="p">):</span>
    <span class="c1"># The websocket protocol requires background tasks to manage the socket heartbeat</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">open_websocket</span><span class="p">(</span><span class="n">websocket_url</span><span class="p">)</span> <span class="k">as</span> <span class="n">ws</span><span class="p">:</span>  <span class="c1"># contains a TaskGroup!</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="k">await</span> <span class="n">ws</span><span class="o">.</span><span class="n">get_message</span><span class="p">()</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">open_websocket</span><span class="p">(</span><span class="n">websocket_url</span><span class="p">)</span> <span class="k">as</span> <span class="n">ws</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">get_messages</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>To prevent these problems, we propose:</p>
<ol class="arabic simple">
<li>a new context manager, <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">sys.prevent_yields(reason):</span> <span class="pre">...</span></code> which will
raise a RuntimeError if you attempt to yield while inside it. <a class="footnote-reference brackets" href="#also-sync" id="id4">[4]</a>
Cancel-scope-like context managers in asyncio and downstream code can then
wrap this to prevent yielding inside <em>their</em> with-block.</li>
<li>a mechanism by which generator-to-context-manager decorators can allow yields
across one call.  We’re not yet sure what this should look like; the leading
candidates are:<ol class="loweralpha simple">
<li>a code-object attribute, <code class="docutils literal notranslate"><span class="pre">fn.__code__.co_allow_yields</span> <span class="pre">=</span> <span class="pre">True</span></code>, or</li>
<li>some sort of invocation flag, e.g. <code class="docutils literal notranslate"><span class="pre">fn.__invoke_with_yields__</span></code>, to avoid
mutating a code object that might be shared between decorated and undecorated
functions</li>
</ol>
</li>
</ol>
<section id="implementation-tracking-frames">
<h3><a class="toc-backref" href="#implementation-tracking-frames" role="doc-backlink">Implementation - tracking frames</a></h3>
<p>The new <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> context manager will require interpreter support.
For each frame, we track the entries and exits of this context manager.</p>
<p>We’re not particularly attached to the exact representation; we’ll discuss it as
a stack (which would support clear error messages), but more compact
representations such as pair-of-integers would also work.</p>
<ul class="simple">
<li>When entering a newly-created or resumed frame, initialize empty stacks of
entries and exits.</li>
<li>When returning from a frame, merge these stacks into that of the parent frame.</li>
<li>When yielding:<ul>
<li>if <code class="docutils literal notranslate"><span class="pre">entries</span> <span class="pre">!=</span> <span class="pre">[]</span> <span class="pre">and</span> <span class="pre">not</span> <span class="pre">frame.allow_yield_flag</span></code>, raise a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>
instead of yielding (the new behavior this PEP proposes)</li>
<li>otherwise, merge stacks into the parent frame as for a return.</li>
</ul>
</li>
</ul>
<p>Because this is about yielding frames <em>within</em> a task, not switching between
tasks, syntactic <code class="docutils literal notranslate"><span class="pre">yield</span></code> and <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> should be affected, but <code class="docutils literal notranslate"><span class="pre">await</span></code>
expressions should not.</p>
<p>We can reduce the overhead by storing this metadata in a single stack per thread
for all stack frames which are not generators.</p>
</section>
<section id="worked-examples">
<h3><a class="toc-backref" href="#worked-examples" role="doc-backlink">Worked examples</a></h3>
<section id="no-yield-example">
<h4><a class="toc-backref" href="#no-yield-example" role="doc-backlink">No-yield example</a></h4>
<p>In this example, we see multiple rounds of the stack merging as we unwind from
<code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code>, through the user-defined ContextManager, back to the
original Frame.  For brevity, the reason for preventing yields is not shown;
it is part of the “1 enter” state.</p>
<a class="reference internal image-reference" href="../_images/pep-789-example-no-yield.png"><img alt="../_images/pep-789-example-no-yield.png" class="align-center" src="../_images/pep-789-example-no-yield.png" style="width: 600px;" />
</a>
<p>With no <code class="docutils literal notranslate"><span class="pre">yield</span></code> we don’t raise any errors, and because the number of enters
and exits balance the frame returns as usual with no further tracking.</p>
</section>
<section id="attempts-to-yield-example">
<h4><a class="toc-backref" href="#attempts-to-yield-example" role="doc-backlink">Attempts-to-yield example</a></h4>
<p>In this example, the Frame attempts to <code class="docutils literal notranslate"><span class="pre">yield</span></code> while inside the
<code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> context. This is detected by the interpreter,
which raises a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> instead of suspending the frame.</p>
<a class="reference internal image-reference" href="../_images/pep-789-example-yield-errors.png"><img alt="../_images/pep-789-example-yield-errors.png" class="align-center" src="../_images/pep-789-example-yield-errors.png" style="width: 500px;" />
</a>
</section>
<section id="allowed-to-yield-example">
<h4><a class="toc-backref" href="#allowed-to-yield-example" role="doc-backlink">Allowed-to-yield example</a></h4>
<p>In this example, a decorator has marked the Frame as allowing yields. This
could be <code class="docutils literal notranslate"><span class="pre">&#64;contextlib.contextmanager</span></code> or a related decorator.</p>
<a class="reference internal image-reference" href="../_images/pep-789-example-yield-allowed.png"><img alt="../_images/pep-789-example-yield-allowed.png" class="align-center" src="../_images/pep-789-example-yield-allowed.png" style="width: 600px;" />
</a>
<p>When the Frame is allowed to yield, the entry/exit stack is merged into the
parent frame’s stack before suspending. When the Frame resumes, its stack is
empty. Finally, when the Frame exits, the exit is merged into the parent
frame’s stack, rebalancing it.</p>
<p>This ensures that the parent frame correctly inherits any remaining
<code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> state, while allowing the Frame to safely suspend
and resume.</p>
</section>
<section id="allowing-yield-for-context-managers">
<h4><a class="toc-backref" href="#allowing-yield-for-context-managers" role="doc-backlink">Allowing yield for context managers</a></h4>
<p><em>TODO: this section is a placeholder, pending a decision on the mechanism for
``&#64;contextmanager`` to re-enable yields in the wrapped function.</em></p>
<ul class="simple">
<li>Explain and show a code sample of how <code class="docutils literal notranslate"><span class="pre">&#64;asynccontextmanager</span></code> sets the flag</li>
</ul>
<p>Note that third-party decorators such as <code class="docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code> demonstrate that
we can’t just have the interpreter special-case contextlib.</p>
</section>
</section>
<section id="behavior-if-sys-prevent-yields-is-misused">
<h3><a class="toc-backref" href="#behavior-if-sys-prevent-yields-is-misused" role="doc-backlink">Behavior if <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> is misused</a></h3>
<p>While unwise, it’s possible to call <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields.__enter__</span></code> and
<code class="docutils literal notranslate"><span class="pre">.__exit__</span></code> in an order that does not correspond to any valid nesting, or get
an invalid frame state in some other way.</p>
<p>There are two ways <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields.__exit__</span></code> could detect an invalid state.
First, if yields are not prevented, we can simply raise an exception without
changing the state.  Second, if an unexpected entry is at the top of the stack,
we suggest popping that entry and raising an exception – this ensures that
out-of-order calls will still clear the stack, while still making it clear that
something is wrong.</p>
<p>(and if we choose e.g. an integer- rather than stack-based representation, such
states may not be distinguishable from correct nesting at all, in which case the
question will not arise)</p>
</section>
</section>
<section id="anticipated-uses">
<h2><a class="toc-backref" href="#anticipated-uses" role="doc-backlink">Anticipated uses</a></h2>
<p>In the standard library, <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> could be used by
<code class="docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code>, <code class="docutils literal notranslate"><span class="pre">asyncio.timeout</span></code>, and <code class="docutils literal notranslate"><span class="pre">asyncio.timeout_at</span></code>.
Downstream, we expect to use it in <code class="docutils literal notranslate"><span class="pre">trio.CancelScope</span></code>, async fixtures (in
pytest-trio, anyio, etc.), and perhaps other places.</p>
<p>We consider use-cases unrelated to async correctness, such as preventing
<code class="docutils literal notranslate"><span class="pre">decimal.localcontext</span></code> from leaking out of a generator, out of scope for this
PEP.</p>
<p>The generator-to-context-manager support would be used by
<code class="docutils literal notranslate"><span class="pre">&#64;contextlib.(async)contextmanager</span></code>, and if necessary in <code class="docutils literal notranslate"><span class="pre">(Async)ExitStack</span></code>.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>The addition of the <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> context manager, changes to
<code class="docutils literal notranslate"><span class="pre">&#64;contextlib.(async)contextmanager</span></code>, and corresponding interpreter
support are all fully backwards-compatible.</p>
<p>Preventing yields inside <code class="docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code>, <code class="docutils literal notranslate"><span class="pre">asycio.timeout</span></code>, and
<code class="docutils literal notranslate"><span class="pre">asyncio.timeout_at</span></code> would be a breaking change to at least some code in the
wild, which (however unsafe and prone to the motivating problems above) may work
often enough to make it into production.</p>
<p>We will seek community feedback on appropriate deprecation pathways for
standard-library code, including the suggested length of any deprecation period.
As an initial suggestion, we could make suspending stdlib contexts emit a
DeprecationWarning only under asyncio debug mode in 3.14; then transition to
warn-by-default and error under debug mode in 3.15; and finally a hard error in
3.16.</p>
<p>Irrespective of stdlib usage, downstream frameworks would adopt this
functionality immediately.</p>
<section id="how-widespread-is-this-bug">
<h3><a class="toc-backref" href="#how-widespread-is-this-bug" role="doc-backlink">How widespread is this bug?</a></h3>
<p>We don’t have solid numbers here, but believe that many projects are affected in
the wild.  Since hitting a moderate and a critical bug attributed to suspending
a cancel scope in the same week at work, we’ve <a class="reference external" href="https://flake8-async.readthedocs.io/en/latest/">used static analysis</a> with some success. Three
people Zac spoke to at PyCon recognized the symptoms and concluded that they had
likely been affected.</p>
<p><em>TODO: run the ASYNC101 lint rule across ecosystem projects, e.g. the aio-libs
packages, and get some sense of frequency in widely-used PyPI packages?
This would help inform the break/deprecation pathways for stdlib code.</em></p>
</section>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Async generators are very rarely taught to novice programmers.</p>
<p>Most intermediate and advanced Python programmers will only interact with this
PEP as users of <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code>, <code class="docutils literal notranslate"><span class="pre">timeout</span></code>, and <code class="docutils literal notranslate"><span class="pre">&#64;contextmanager</span></code>.  For this
group, we expect a clear exception message and documentation to be sufficient.</p>
<ul class="simple">
<li>A new section will be added to the <a class="reference external" href="https://docs.python.org/3/library/asyncio-dev.html">developing with asyncio</a> page, which
briefly states that async generators are not permitted to <code class="docutils literal notranslate"><span class="pre">yield</span></code> when
inside a “cancel scope” context, i.e. <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code> or <code class="docutils literal notranslate"><span class="pre">timeout</span></code> context
manager.  We anticipate that the problem-restatement and some parts of the
motivation section will provide a basis for these docs.<ul>
<li>When working in codebases which avoid async generators entirely <a class="footnote-reference brackets" href="#exp-report" id="id5">[5]</a>,
we’ve found that an async context manager yielding an async iterable is a safe
and ergonomic replacement for async generators – and avoids the delayed-cleanup
problems described in <a class="pep reference internal" href="../pep-0533/" title="PEP 533 – Deterministic cleanup for iterators">PEP 533</a>, which this proposal does not address.</li>
</ul>
</li>
<li>In the docs for each context manager which wraps a cancel scope, and thus now
<code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code>, include a standard sentence such as “If used within an
async generator, [it is an error to <code class="docutils literal notranslate"><span class="pre">yield</span></code> inside this context manager].”
with a hyperlink to the explanation above.</li>
</ul>
<p>For asyncio, Trio, curio, or other-framework maintainers who implement
cancel scope semantics, we will ensure that the documentation of
<code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> gives a full explanation distilled from the solution and
implementation sections of this PEP.  We anticipate consulting most such
maintainers for their feedback on the draft PEP.</p>
</section>
<section id="rejected-alternatives">
<h2><a class="toc-backref" href="#rejected-alternatives" role="doc-backlink">Rejected alternatives</a></h2>
<section id="pep-533-deterministic-cleanup-for-iterators">
<h3><a class="toc-backref" href="#pep-533-deterministic-cleanup-for-iterators" role="doc-backlink">PEP 533, deterministic cleanup for iterators</a></h3>
<p><a class="pep reference internal" href="../pep-0533/" title="PEP 533 – Deterministic cleanup for iterators">PEP 533</a> proposes adding <code class="docutils literal notranslate"><span class="pre">__[a]iterclose__</span></code> to the iterator protocol,
essentially wrapping a <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">[a]closing(ait)</span></code> around each (async) for loop.
While this would be useful for ensuring timely and deterministic cleanup of
resources held by iterators, the problem it aims to solve, it does not fully
address the issues that motivate this PEP.</p>
<p>Even with PEP 533, misfired cancellations would still be delivered to the wrong
task and could wreak havoc before the iterator is closed. Moreover, it does not
address the fundamental structured concurrency problem with <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code>, where
suspending a frame that owns a TaskGroup is incompatible with the model of child
tasks being fully encapsulated within their parent frame.</p>
</section>
<section id="deprecate-async-generators-entirely">
<h3><a class="toc-backref" href="#deprecate-async-generators-entirely" role="doc-backlink">Deprecate async generators entirely</a></h3>
<p>At the 2024 language summit, several attendees suggested instead deprecating async
generators <em>in toto.</em>  Unfortunately, while the common-in-practice cases all use
async generators, Trio code can trigger the same problem with standard generators:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># We use Trio for this example, because while `asyncio.timeout()` is async,</span>
<span class="c1"># Trio&#39;s CancelScope type and timeout context managers are synchronous.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">trio</span>

<span class="k">def</span><span class="w"> </span><span class="nf">abandon_each_iteration_after</span><span class="p">(</span><span class="n">max_seconds</span><span class="p">):</span>
    <span class="c1"># This is of course broken, but I can imagine someone trying it...</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">move_on_after</span><span class="p">(</span><span class="n">max_seconds</span><span class="p">):</span>
            <span class="k">yield</span>

<span class="nd">@trio</span><span class="o">.</span><span class="n">run</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">abandon_each_iteration_after</span><span class="p">(</span><span class="n">max_seconds</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>If it wasn’t for the bug in question, this code would look pretty idiomatic -
but after about a second, instead of moving on to the next iteration it raises:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;demo.py&quot;</span>, line <span class="m">10</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
  File <span class="nb">&quot;trio/_core/_run.py&quot;</span>, line <span class="m">2297</span>, in <span class="n">run</span>
<span class="w">    </span><span class="k">raise</span> <span class="n">runner</span><span class="o">.</span><span class="n">main_task_outcome</span><span class="o">.</span><span class="n">error</span>
  File <span class="nb">&quot;demo.py&quot;</span>, line <span class="m">12</span>, in <span class="n">main</span>
<span class="w">    </span><span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  File <span class="nb">&quot;trio/_timeouts.py&quot;</span>, line <span class="m">87</span>, in <span class="n">sleep</span>
<span class="w">    </span><span class="k">await</span> <span class="n">sleep_until</span><span class="p">(</span><span class="n">trio</span><span class="o">.</span><span class="n">current_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">seconds</span><span class="p">)</span>
<span class="w">  </span><span class="c">...</span>
  File <span class="nb">&quot;trio/_core/_run.py&quot;</span>, line <span class="m">1450</span>, in <span class="n">raise_cancel</span>
<span class="w">    </span><span class="k">raise</span> <span class="n">Cancelled</span><span class="o">.</span><span class="n">_create</span><span class="p">()</span>
<span class="gr">trio.Cancelled</span>: <span class="n">Cancelled</span>
</pre></div>
</div>
<p>Furthermore, there are some non-cancel-scope synchronous context managers which
exhibit related problems, such as the abovementioned <code class="docutils literal notranslate"><span class="pre">decimal.localcontext</span></code>.
While fixing the example below is not a goal of this PEP, it demonstrates that
yield-within-with problems are not exclusive to async generators:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">decimal</span>

<span class="k">def</span><span class="w"> </span><span class="nf">why_would_you_do_this</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">decimal</span><span class="o">.</span><span class="n">localcontext</span><span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">yield</span>

<span class="n">one</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 0.3333333333333333333333333333</span>
<span class="nb">next</span><span class="p">(</span><span class="n">gen</span> <span class="o">:=</span> <span class="n">why_would_you_do_this</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 0.3</span>
</pre></div>
</div>
<p>While I’ve had good experiences in async Python without async generators
<a class="footnote-reference brackets" href="#exp-report" id="id6">[5]</a>, I’d prefer to fix the problem than remove them from the
language.</p>
</section>
<section id="can-t-we-just-deliver-exceptions-to-the-right-place">
<span id="just-deliver"></span><h3><a class="toc-backref" href="#can-t-we-just-deliver-exceptions-to-the-right-place" role="doc-backlink">Can’t we just deliver exceptions to the right place?</a></h3>
<p>If we implemented <a class="pep reference internal" href="../pep-0568/" title="PEP 568 – Generator-sensitivity for Context Variables">PEP 568</a> (Generator-sensitivity for Context Variables; see
also <a class="pep reference internal" href="../pep-0550/" title="PEP 550 – Execution Context">PEP 550</a>), it would be possible to handle exceptions from timeouts: the
event loop could avoid firing a <code class="docutils literal notranslate"><span class="pre">CancelledError</span></code> until the generator frame
which contains the context manager is on the stack - either when the generator
is resumed, or when it is finalized.</p>
<p>This can take arbitrarily long; even if we implemented <a class="pep reference internal" href="../pep-0533/" title="PEP 533 – Deterministic cleanup for iterators">PEP 533</a> to ensure
timely cleanup on exiting (async) for-loops it’s still possible to drive a
generator manually with next/send.</p>
<p>However, this doesn’t address the other problem with <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code>. The model
for generators is that you put a stack frame in suspended animation and can then
treat it as an inert value which can be stored, moved around, and maybe
discarded or revived in some arbitrary place. The model for structured
concurrency is that your stack becomes a tree, with child tasks encapsulated
within some parent frame.  They’re extending the basic structured programming
model in different, and unfortunately incompatible, directions.</p>
<p>Suppose for example that suspending a frame containing an open <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code>
also suspended all child tasks.  This would preserve the ‘downward’ structured
concurrency, in that children remain encapsulated - albeit at the cost of
deadlocking both of our motivating examples, and much real-world code.
However, it would still be possible to resume the generator in a different
task, violating the ‘upwards’ invariant of structured concurrency.</p>
<p>We don’t think it’s worth adding this much machinery to handle cancel scopes,
while still leaving task groups broken.</p>
</section>
<section id="alternative-implementation-inspecting-bytecode">
<h3><a class="toc-backref" href="#alternative-implementation-inspecting-bytecode" role="doc-backlink">Alternative implementation - inspecting bytecode</a></h3>
<p>Jelle Zijlstra has <a class="reference external" href="https://gist.github.com/JelleZijlstra/a53b17417c5189b487316628acc5555f">sketched an alternative</a>, where <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code>
inspects the bytecode of callers until satisfied that there is no yield between
the calling instruction pointer and the next context exit. We expect that
support for syntatically-nested context managers could be added fairly easily.</p>
<p>However, it’s not yet clear how this would work when user-defined context
managers wrap <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code>.  Worse, this approach ignores explicit
calls to <code class="docutils literal notranslate"><span class="pre">__enter__()</span></code> and <code class="docutils literal notranslate"><span class="pre">__exit__()</span></code>, meaning that the context management
protocol would vary depending on whether the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement was used.</p>
<p>The ‘only pay if you use it’ performance cost is very attractive.  However,
inspecting frame objects is prohibitively expensive for core control-flow
constructs, and causes whole-program slowdowns via de-optimization.
On the other hand, adding interpreter support for better performance leads
back to the same pay-regardless semantics as our preferred solution above.</p>
</section>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="trio-cancel-scope" role="doc-footnote">
<dt class="label" id="trio-cancel-scope">[<a href="#id1">1</a>]</dt>
<dd>While cancel scopes are implicit in asyncio, the analogous
<a class="reference external" href="https://trio.readthedocs.io/en/latest/reference-core.html#trio.fail_after" title="(in Trio v0.31.0+dev)"><code class="docutils literal notranslate"><span class="pre">trio.fail_after()</span></code></a> (sync) and <a class="reference external" href="https://trio.readthedocs.io/en/latest/reference-core.html#trio.open_nursery" title="(in Trio v0.31.0+dev)"><code class="docutils literal notranslate"><span class="pre">trio.open_nursery()</span></code></a>
(async) context managers literally wrap an instance of
<a class="reference external" href="https://trio.readthedocs.io/en/latest/reference-core.html#trio.CancelScope" title="(in Trio v0.31.0+dev)"><code class="docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a>. We’ll stick with asyncio for examples
here, but say “cancel scope” when referring to the framework-independent
concept.</aside>
<aside class="footnote brackets" id="tg-cs" role="doc-footnote">
<dt class="label" id="tg-cs">[<a href="#id2">2</a>]</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">TaskGroup</span></code> is not _only_ a cancel scope, but preventing yields would
resolve their further problem too.  See <a class="reference internal" href="#just-deliver"><span class="std std-ref">Can’t we just deliver exceptions to the right place?</span></a>.</aside>
<aside class="footnote brackets" id="redirected" role="doc-footnote">
<dt class="label" id="redirected">[<a href="#id3">3</a>]</dt>
<dd>via e.g. <code class="docutils literal notranslate"><span class="pre">contextlib.[async]contextmanager</span></code>, or moral
equivalents such as <code class="docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code></aside>
<aside class="footnote brackets" id="also-sync" role="doc-footnote">
<dt class="label" id="also-sync">[<a href="#id4">4</a>]</dt>
<dd>Note that this prevents yields in both sync and async generators, so that
downstream frameworks can safely define sync cancel scope countexts such as
<a class="reference external" href="https://trio.readthedocs.io/en/latest/reference-core.html#trio.fail_after" title="(in Trio v0.31.0+dev)"><code class="docutils literal notranslate"><span class="pre">trio.fail_after()</span></code></a>.</aside>
<aside class="footnote brackets" id="exp-report" role="doc-footnote">
<dt class="label" id="exp-report">[5]<em> (<a href='#id5'>1</a>, <a href='#id6'>2</a>) </em></dt>
<dd>see <a class="reference external" href="https://discuss.python.org/t/using-exceptiongroup-at-anthropic-experience-report/20888">Zac’s experience report here</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0789.rst">https://github.com/python/peps/blob/main/peps/pep-0789.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0789.rst">2024-06-04 01:45:13 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#problem-statement">Problem statement</a></li>
<li><a class="reference internal" href="#motivating-examples">Motivating examples</a><ul>
<li><a class="reference internal" href="#leaking-a-timeout-to-the-outer-scope">Leaking a timeout to the outer scope</a></li>
<li><a class="reference internal" href="#leaking-background-tasks-breaks-cancellation-and-exception-handling">Leaking background tasks (breaks cancellation and exception handling)</a></li>
<li><a class="reference internal" href="#in-a-user-defined-context-manager">In a user-defined context manager</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#implementation-tracking-frames">Implementation - tracking frames</a></li>
<li><a class="reference internal" href="#worked-examples">Worked examples</a><ul>
<li><a class="reference internal" href="#no-yield-example">No-yield example</a></li>
<li><a class="reference internal" href="#attempts-to-yield-example">Attempts-to-yield example</a></li>
<li><a class="reference internal" href="#allowed-to-yield-example">Allowed-to-yield example</a></li>
<li><a class="reference internal" href="#allowing-yield-for-context-managers">Allowing yield for context managers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#behavior-if-sys-prevent-yields-is-misused">Behavior if <code class="docutils literal notranslate"><span class="pre">sys.prevent_yields</span></code> is misused</a></li>
</ul>
</li>
<li><a class="reference internal" href="#anticipated-uses">Anticipated uses</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#how-widespread-is-this-bug">How widespread is this bug?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#rejected-alternatives">Rejected alternatives</a><ul>
<li><a class="reference internal" href="#pep-533-deterministic-cleanup-for-iterators">PEP 533, deterministic cleanup for iterators</a></li>
<li><a class="reference internal" href="#deprecate-async-generators-entirely">Deprecate async generators entirely</a></li>
<li><a class="reference internal" href="#can-t-we-just-deliver-exceptions-to-the-right-place">Can’t we just deliver exceptions to the right place?</a></li>
<li><a class="reference internal" href="#alternative-implementation-inspecting-bytecode">Alternative implementation - inspecting bytecode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0789.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>