PEP: 9999
Title: Type Stubs
Author: Jelle Zijlstra <jelle.zijlstra@gmail.com>,
 Rebecca Chen <rechen@google.com>,
 Teddy Sudol <tsudol@google.com>,
 Sebastian Rittau <sebastian.rittau@zfutura.de>
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created:
Post-History:

Abstract
========

Optional type hints were introduced to the Python language in PEP 484
[#pep484]_, based on the function annotation syntax from PEP 3107
[#pep3107]_. Static type checkers can use type hints to prevent bugs,
documentation tools can automatically add type information,
and IDEs can offer improved autocompletion and support safer refactorings.

PEP 484 also introduced *type stubs*, also called *stub files*,
that provide type information for untyped Python packages and modules. Type
stubs serve multiple purposes:

* They are the only way to add type information to extension modules.
* They can provide type information for packages that do not wish to
  add them inline.
* They can be distributed separately from the implementation.
  This allows stubs to be develped at a different pace or by different
  authors, which is especially useful when adding type annotations to
  existing packages.
* They act as documentation, succinctly explaining the external
  API of a package, without including the implementation or private
  members.

This PEP aims to give guidance to both authors of type stubs and developers
of type checkers. It describes the contents of compliant type stubs,
suggests a style guide for them, and lists constructs that compliant type
checkers are expected to support.

A type stub is considered to be compliant if it only uses constructs decribed
in this PEP. Type stub authors can elect to use additional constructs, but
must be prepared that some type checkers will not parse them as expected.

A type checker is considered to be compliant if
it accepts all compliant type stubs. This means it
will parse a compliant type stub without error and does not interpret any
construct in a contradictory manner. A compliant type checker is not
required to interpret all standard constructs, and additionally a type checker
can support extra constructs not described in this PEP. All deviations from
this PEP should be documented.

Syntax
======

Type stubs are syntactically valid Python files with a ``.pyi`` suffix.
They should be valid according to the latest Python version six months
after release at the latest, but can start to use features from that
release from the release date on.
Type stubs authors are encouraged to use the latest available syntax
features in stubs, even if the type information in the stub is targeted
to an older Python version.

Type checkers are expected to support the syntax of the latest released Python
version.

For example, Python 3.7, which reserved ``async`` and ``await``
as keywords (see [#pep492]_), was released on June 27nd, 2018. Type
checkers should support them by that date and type stubs could start
using ``async`` to mark function definitions. Additionally, type stubs
should stop using the new keyword as an attribute or function name before
December 27nd, 2018.

Distribution
============

Type stubs can be distributed with or separately from the implementation;
see PEP 561 [#pep561]_ for more information. The typeshed_ project
includes stubs for Python's standard library and several third-party
packages. These are usually distributed with type checkers and do not
require separate installation.

Supported Constructs
====================

This sections lists constructs that compliant type checkers are expected
to accept. Type stub authors can safely use these constructs. If a
construct is marked as "unspecified", type checkers may handle it
as they best see fit or report an error. Linters should usually
flag those constructs. Type stub authors should avoid using them to
ensure compatibility across type checkers.

Imports
-------

Type stubs distinguish between imports that are re-exported and those
that are only used internally. Imports are only re-exported if they
use one of these forms:[#pep484]_

* ``import ... as ...``
* ``from ... import ... as ...``
* ``from ... import *``

Stub authors can use ``import foo as foo`` to re-export an import using
the same name::

    from foo import func as func  # re-exported as "func"
    from foo import Cls as OtherCls  # re-exported as "OtherCls"
    from foo import baz  # internal use only
    import bar as bar  # re-exported as "bar"
    import baz  # internal use only

Sub-modules are always exported when they are imported in a module.
For example, consider the following file structure::

    foo/
        __init__.pyi
        bar.pyi

Then ``foo`` will export ``bar`` when one of the following constructs is used in
``__init__.pyi``::

    from . import bar
    from .bar import Bar

Module Level Attributes
-----------------------

Module level variables and constants can be annotated using either
type comments or variable annotation syntax::

    x: int  # recommended
    x: int = 0
    x = 0  # type: int
    x = ...  # type: int

The type of a variable is unspecified when the variable is unannotated or
when the annotation
and the assigned value disagree. As an exception, the ellipsis literal can
stand in for any type::

    x = 0  # type is unspecified
    x: int = ""  # type is unspecified
    x: int = ...  # type is int

Classes
-------

Class definition syntax follows general Python syntax, but type checkers
are only expected to understand the following constructs in class bodies:

* The ellipsis operator or pass statement are ignored and used for empty
  class bodies.
* Instance attributes follow the same rules as module level attributes
  (see above).
* Method definitions (see below) and properties.
* Method aliases.
* Inner class definitions.

More complex statements don't need to be supported.

Yes::

    class Simple: ...

    class Complex(Base):
        read_write: int
        @property
        def read_only(self) -> int: ...
        def do_stuff(self, y: str) -> None: ...
        doStuff = do_stuff

Functions and Methods
---------------------

Function and method definition syntax follows general Python syntax.
Unless an argument is prefixed with two underscores (but not suffixed
with two underscores), it can be used as a keyword argument [#pep484]_::

    # x is positional-only
    # y can be used positionally or as keyword argument
    # z is keyword-only
    def foo(__x, y, *, z): ...

If an argument is unannotated, its type is assumed to be ``Any``. The type of
an argument where annotation and the type of the default argument disagree
is unspecified. As an exception, the ellipsis literal can stand in for any
type::

    # x has type Any
    # y's type is unspecified
    # z has type int
    def foo(x, y: int = "", z: int = ...): ...

For a class ``C``, the type of the first argument to a classmethod is
assumed to be ``Type[C]``, if unannotated. For other non-static methods,
its type is assumed to be ``C``::

    class Foo:
        def do_things(self): ...  # self has type Foo
        @classmethod
        def create_it(cls): ...  # cls has type Type[Foo]
        @staticmethod
        def utility(x): ...  # x has type Any

But::

    _T = TypeVar("_T")

    class Foo:
        def do_things(self: _T): ...  # self has type _T
        @classmethod
        def create_it(cls: _T): ...  # cls has type _T

An unannotated return type is assumed to be ``Any``.

Using a function or method body other than the ellipsis literal is
unspecified. Stub authors should avoid any other body, including
ones consisting only of ``pass`` or a docstring if they want to ensure
compatibility with all type checkers::

    def foo(): ...  # compatible
    def bar(): pass  # behaviour undefined

Aliases
-------

Type checkers should accept module-level and class-level aliases, e.g.::

  _IntList = List[int]

  class C:
    def f(self) -> int: ...
    g = f

An alias to a type may contain type variables, in which case all type variables
must be substituted when the alias is used::

  _K = TypeVar("_K")
  _V = TypeVar("_V")
  _MyMap = Dict[str, Dict[_K, _V]]

  # either concrete types or other type variables can be substituted
  def f(x: _MyMap[str, _V]) -> _V: ...
  # explicitly substitute in Any rather than using a bare alias
  def g(x: _MyMap[Any, Any]) -> Any: ...

Otherwise, type variables in aliases follow the same rules as type variables in
generic class definitions.

Decorators
----------

Type stubs may only use decorators defined in the ``typing`` module, plus a
fixed set of additional ones:

* ``classmethod``
* ``staticmethod``
* ``property`` (including ``.setter``)
* ``abc.abstractmethod``
* ``asyncio.coroutines.coroutine``

The behavior of other decorators should instead be incorporated into the types.
For example, for the following function::

  import contextlib
  @contextlib.contextmanager
  def f():
    yield 42

the stub definition should be::

  from typing import ContextManager
  def f() -> ContextManager[int]: ...

Structured comments
-------------------

Two kinds of structured comments are accepted:

* A ``# type: X`` comment at the end of a line that defines a variable,
  declaring that the variable has type ``X``. However, PEP 526-style [#pep526]_
  variable annotations are preferred over type comments.
* A ``# type: ignore`` comment at the end of any line, which suppresses all type
  errors in that line.

Type Stub Content
=================

This section documents best practices on what elements to include or
leave out of type stubs.

Public Interface
----------------

Stubs should include the complete interface (classes, functions,
constants, etc.) of the module they cover, but it is not always
clear exactly what is part of the interface.

The following should always be included:

* All objects listed in the module's documentation.
* All objects included in ``__all__`` (if present).

Other objects may be included if they are being used in practice
or if they are not prefixed with an underscore. (See the next section.)

Undocumented Objects
--------------------

Undocumented objects may be included as long as they are marked with a comment
of the form ``# undocumented``.

Example::

    def list2cmdline(seq: Sequence[str]) -> str: ...  # undocumented

Such undocumented objects are allowed because omitting objects can confuse
users. Users who see an error like "module X has no attribute Y" will
not know whether the error appeared because their code had a bug or
because the stub is wrong. Although it may also be helpful for a type
checker to point out usage of private objects, we usually prefer false
negatives (no errors for wrong code) over false positives (type errors
for correct code). In addition, even for private objects a type checker
can be helpful in pointing out that an incorrect type was used.

Stub-Only Objects
-----------------

Definitions that do not exist at runtime may be included in stubs to aid in
expressing types. Sometimes, it is desirable to make a stub-only class available
to a stub's users - for example, to allow them to type the return value of a
public method for which a library does not provided a usable runtime type. In
this case, the class should be marked with ``typing.type_check_only``::

  from typing import Protocol, type_check_only

  @type_check_only
  class Readable(Protocol):
    def read(self) -> str: ...

  def get_reader() -> Readable: ...

Incomplete Stubs
----------------

Partial stubs can be useful, especially for larger packages, but they should
follow the following guidelines:

* Included functions and methods must list all arguments, but the arguments
  can be left unannotated. Do not use ``Any`` to mark unannotated arguments
  or return values.
* Partial classes must include a ``__getattr__()`` method marked with an
  ``# incomplete`` comment (see example below).
* Partial modules (i.e. modules that are missing some or all classes,
  functions, or attributes) must include a top-level ``__getattr__()``
  function marked with an ``# incomplete`` comment (see example below).
* Partial packages (i.e. packages that are missing one or more sub-modules)
  must have a ``__init__.pyi`` stub that is marked as incomplete (see above).
  A better alternative is to create empty stubs for all sub-modules and
  mark them as incomplete individually.

Example of a partial module with a partial class ``Foo`` and a partially
annotated function ``bar()``::

    def __getattr__(name: str) -> Any: ...  # incomplete

    class Foo:
        def __getattr__(self, name: str) -> Any:  # incomplete
        x: int
        y: str

    def bar(x: str, y, *, z=...): ...

Attribute Access
----------------

Python has several methods for customizing attribute access: ``__getattr__``,
``__getattribute__``, ``__setattr__``, and ``__delattr__``. Of these,
``__getattr__`` and ``__setattr___`` should sometimes be included in stubs.

In addition to marking incomplete definitions, ``__getattr__`` should be
included when a class or module allows any name to be accessed. For example, for
the following class::

  class Foo:
      def __getattribute__(self, name):
          return self.__dict__.setdefault(name)

an appropriate stub definition is::

  from typing import Any, Optional
  class Foo:
      def __getattr__(self, name: str) -> Optional[Any]: ...

Note that only ``__getattr__``, not ``__getattribute__``, is guaranteed to be
supported in stubs.

On the other hand, ``__getattr__`` should be omitted even if the source code
includes it, if only limited names are allowed. For example, for this class::

  class ComplexNumber:
      def __init__(self, n):
          self._n = n
      def __getattr__(self, name):
          if name in ("real", "imag"):
              return getattr(self._n, name)
          raise AttributeError(name)

the stub should list attributes individually::

  class ComplexNumber:
      real: float
      imag: float
      def __init__(self, n: complex) -> None: ...

``__setattr___`` should be included when a class allows any name to be set and
restricts the type, e.g.::

  class IntHolder:
      def __setattr__(self, name, value):
          if isinstance(value, int):
              return super().__setattr__(name, value)
          raise ValueError(value)

A good stub definition::

  class IntHolder:
      def __setattr__(self, name: str, value: int) -> None: ...

``__delattr__`` should not be included in stubs.

Finally, even in the presence of ``__getattr__`` and ``__setattr__``, it is
still recommended to separately define known attributes.

Documentation or Implementation
-------------------------------

Sometimes a library's documented types will differ from the actual types in the
code. In such cases, type stub authors should use their best judgment. Consider
these two examples::

  def print_elements(x):
      """Print every element of list x."""
      for y in x:
          print(y)

  def maybe_raise(x):
      """Raise an error if x (a boolean) is true."""
      if x:
          raise ValueError()

The implementation of ``print_elements`` takes any iterable, despite the
documented type of ``list``. In this case, one should annotate the argument as
``Iterable[Any]``, to follow this PEP's style recommendation of preferring
abstract types.

For ``maybe_raise``, on the other hand, it is better to annotate the argument as
``bool`` even though the implementation accepts any object. This guards against
common mistakes like unintentionally passing in ``None``.

If in doubt, consider asking the library maintainers about their intent.

Style Guide
===========

The recommendations in this section are aimed at type stubs authors
that wish to provide a consistent style for type stubs. Type checkers
should not reject stubs that do not follow these recommendations, but
linters can warn about them.

Stub files should generally follow the Style Guide for Python Code (PEP 8)
[#pep8]_. There are a few exceptions, outlined below, that take the
different structure of stub files into account and are aimed to create
more concise files.

Maximum Line Length
-------------------

Type stubs should be limited to 130 characters per line.

Blank Lines
-----------

Do not use empty lines between functions, methods, and fields, except to
group them with one empty line. Use one empty line around classes, but do not
use empty lines between body-less classes, except for grouping.

Yes::

    def time_func() -> None: ...
    def date_func() -> None: ...

    def ip_func() -> None: ...

    class Foo:
        x: int
        y: int
        def __init__(self) -> None: ...

    class MyError(Exception): ...
    class AnotherError(Exception): ...

No::

    def time_func() -> None: ...

    def date_func() -> None: ...  # do no leave unnecessary empty lines

    def ip_func() -> None: ...


    class Foo:  # leave only one empty line above
        x: int
    class MyError(Exception): ...  # leave an empty line between the classes

Module Level Attributes
-----------------------

Do not use an assignment for module-level attributes.

Yes::

    CONST: str
    x: int

No::

    CONST = ""
    x: int = 0
    y: float = ...
    z = 0  # type: int
    a = ...  # type: int

Classes
-------

Do not include docstrings in class bodies.

Classes without bodies should use the ellipsis operator ``...`` in place
of the body on the same line as the class definition.

Yes::

    class MyError(Exception): ...

No::

    class MyError(Exception):
        ...
    class AnotherError(Exception): pass

Functions and Methods
---------------------

Use the same argument names as in the implementation.
Otherwise using keyword arguments will fail. Of course, that
does not apply to positional-only arguments, marked with a double
underscore.

Use the ellipsis operator ``...`` in place of actual default argument
values. Use an explicit ``Optional`` annotation instead of
a ``None`` default.

Yes::

    def foo(x: int = ...) -> None: ...
    def bar(y: Optional[str] = ...) -> None: ...

No::

    def foo(x: int = 0) -> None: ...
    def bar(y: str = None) -> None: ...
    def baz(z: Optional[str] = None) -> None: ...

Do not annotate ``self`` and ``cls`` in method definitions, except when
referencing a type variable.

Yes::

    _T = TypeVar("_T")
    class Foo:
        def bar(self) -> None: ...
        @classmethod
        def create(cls: Type[_T]) -> _T: ...

No::

    class Foo:
        def bar(self: Foo) -> None: ...
        @classmethod
        def baz(cls: Type[Foo]) -> int: ...

The bodies of functions and methods should consist of only the ellipsis
operator ``...`` on the same line as the closing parenthesis and colon.
Do not include docstrings.

Yes::

    def to_int1(x: str) -> int: ...
    def to_int2(
        x: str,
    ) -> int: ...

No::

    def to_int1(x: str) -> int:
        return int(x)
    def to_int2(x: str) -> int:
        ...
    def to_int3(x: str) -> int: pass

Private Definitions
-------------------

Type variables, type aliases, and other definitions that should not
be used outside the stub should be marked as private by prefixing them
with an underscore.

Yes::

    _T = TypeVar("_T")
    _DictList = Dict[str, List[Optional[int]]]

No::

    T = TypeVar("T")
    DictList = Dict[str, List[Optional[int]]]

Language Features
-----------------

Use the latest language features available as outlined
in the Syntax_ section, even for stubs targeting older Python versions.
Do not use quotes around forward references and do not use ``__future__``
imports.

Yes::

    class Py35Class:
        x: int
        forward_reference: OtherClass
    class OtherClass: ...

No::

    class Py35Class:
        x = 0  # type: int
        forward_reference: 'OtherClass'
    class OtherClass: ...

Types
-----

Generally, use ``Any`` when a type can not be expressed appropriately
with the current type system or using the correct type is unergonomic.

Use ``float`` instead of ``Union[int, float]``.
Use ``None`` instead of ``Literal[None]``.
For argument types,
use ``bytes`` instead of ``Union[bytes, memoryview, bytearray]``.

Use ``Text`` in stubs that support Python 2 when something accepts both
``str`` and ``unicode``. Avoid using ``Text`` in stubs or branches for
Python 3 only.

Yes::

    if sys.version_info < (3,):
        def foo(s: Text) -> None: ...
    else:
        def foo(s: str, *, i: int) -> None: ...
    def bar(s: Text) -> None: ...

No::

    if sys.version_info < (3,):
        def foo(s: unicode) -> None: ...
    else:
        def foo(s: Text, *, i: int) -> None: ...

For arguments, prefer protocols and abstract types (``Mapping``,
``Sequence``, ``Iterable``, etc.). If an argument accepts any value,
use ``object`` instead of ``Any``.

For return values, prefer concrete types (``List``, ``Dict``, etc.) for
concrete implementations. The return values of protocols
and abstract base classes must be judged on a case-by-case basis.

Yes::

    def map_it(input: Iterable[str]) -> List[int]: ...
    def create_map() -> Dict[str, int]: ...
    def to_string(o: object) -> str: ...  # accepts any object

No::

    def map_it(input: List[str]) -> List[int]: ...
    def create_map() -> MutableMapping[str, int]: ...
    def to_string(o: Any) -> str: ...

Maybe::

    class MyProto(Protocol):
        def foo(self) -> List[int]: ...
        def bar(self) -> Mapping[str]: ...

Avoid ``Union`` return types, since they require ``isinstance()`` checks.
Use ``Any`` if necessary.

Existing Tools
==============

Type Checkers
-------------

* mypy [#mypy]_, the reference implementation for type checkers.
  Supports Python 2 and 3.
* pyre [#pyre]_, written in OCaml and optimized for performance.
  Supports Python 3 only.
* pytype [#pytype]_, checks and infers types for unannotated code.
  Supports Python 2 and 3.

Development Environments
------------------------

* PyCharm [#pycharm]_, an IDE that supports type stubs both for type
  checking and code completion.

Linters and Formatters
----------------------

* black [#black]_, a code formatter with support for type stub files.
* flake8-pyi [#flake8-pyi]_, a plugin for the flake8 linter [#flake8]_ that adds support for
  type stubs.

References
==========

PEPs
----

.. [#pep8] PEP 8 -- Style Guide for Python Code, van Rossum et al. (https://www.python.org/dev/peps/pep-0008/)
.. [#pep484] PEP 484 -- Type Hints, van Rossum et al. (https://www.python.org/dev/peps/pep-0484)
.. [#pep492] PEP 492 -- Coroutines with async and await syntax, Selivanov (https://www.python.org/dev/peps/pep-0492/)
.. [#pep526] PEP 526 -- Syntax for Variable Annotations, Gonzalez et al. (https://www.python.org/dev/peps/pep-0526)
.. [#pep561] PEP 561 -- Distributing and Packaging Type Information, Smith (https://www.python.org/dev/peps/pep-0561)
.. [#pep3107] PEP 3107 -- Function Annotations, Winter and Lownds (https://www.python.org/dev/peps/pep-3107)

Type Checkers
-------------

.. [#mypy] mypy -- Optional Static Typing for Python (http://www.mypy-lang.org/)
.. [#pycharm] PyCharm -- The Python IDE for Professional Developers (https://www.jetbrains.com/pycharm/)
.. [#pyre] Pyre -- A performant type-checker for Python 3 (https://pyre-check.org/)
.. [#pytype] pytype -- A static analyzer for Python code (https://github.com/google/pytype)

Other Resources
---------------

.. [#black] black -- The uncompromising code formatter (https://black.readthedocs.io/)
.. [#flake8] Flake8: Your Tool For Style Guide Enforcement (http://flake8.pycqa.org/)
.. [#flake8-pyi] flake8-pyi (https://github.com/ambv/flake8-pyi)
.. [#typeshed] typeshed -- Collection of library stubs for Python, with static types (https://github.com/python/typeshed)

Copyright
=========

This document has been placed in the public domain.
