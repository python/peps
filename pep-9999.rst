PEP: 9999
Title: Making the buffer protocol accessible in Python
Author: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: <date created on, in dd-mmm-yyyy format>
Python-Version: 3.12
Post-History: <REQUIRED: dates, in dd-mmm-yyyy format, and corresponding links to PEP discussion threads>


Abstract
========

This PEP proposes a mechanism to inspect in Python whether a type implements
the C-level buffer protocol.


Motivation
==========

The CPython C API provides a versatile mechanism for accessing the
underlying memory of an object, the buffer protocol. Functions that
accept binary data are usually written to accept any object implementing
the buffer protocol. For example, there are about 130 functions in
CPython using the Argument Clinic ``Py_buffer`` type, which accepts
the buffer protocol.

Currently, there is no way to inspect in Python whether an object
implements the buffer protocol. Relatedly, the static type system
does not provide a type annotation to represent the protocol.
This is a common problem when type annotating code that accepts
generic buffers.


Rationale
=========

Current options
---------------

There are two current workarounds for annotating buffer types in
the type system, but neither is adequate.

First, the current workaround for buffer types in typeshed is a type alias
that lists well-known buffer types in the standard library, such as
``bytes``, ``bytearray``, ``memoryview``, and ``array.array``. This
approach works for the standard library, but it does not work for
third-party buffer types.

Second, the documentation for ``typing.ByteString`` currently states:

   This type represents the types ``bytes``, ``bytearray``, and
   ``memoryview`` of byte sequences.

   As a shorthand for this type, ``bytes`` can be used to annotate
   arguments of any of the types mentioned above.

Although this sentence has been in the documentation since 2015,
the use of ``bytes`` to include these other types is not specified
in any of the typing PEPs. However, this mechanism has a number of
problems. It does not include all possible buffer types, and it
makes the ``bytes`` type ambiguous in type annotations. After all,
there are many operations that are valid on ``bytes`` objects, but
not on ``memoryview`` objects, and it is perfectly possible for
a function to accept ``bytes`` but not ``memoryview`` objects.

Kinds of buffers
----------------

The C buffer protocol supports many options, affecting strides,
contiguity, and support for writing to the buffer. Some of these
options would be useful in the type system. For example, typeshed
currently provides separate type aliases for writable and read-only
buffers.

However, in the C buffer protocol, these options cannot be
queried directly on the type object. The only way to figure out
whether an object supports a writable buffer is to actually
ask for the buffer. For some types, such as ``memoryview``,
whether the buffer is writable depends on the exact object:
some are read-only and others are not. As such, I propose to
support only whether a type implements the buffer protocol at
all, not whether it supports more specific options such as
writable buffers.

Specification
=============

types.Buffer
------------

A new class ``types.Buffer`` will be added. It cannot be instantiated or
subclassed, but supports the ``__instancecheck__`` and
``__subclasscheck__`` hooks.  In CPython, these will check for the presence of the
``bf_getbuffer`` slot in the type object:

.. code-block:: pycon

   >>> from types import Buffer
   >>> isinstance(b"xy", Buffer)
   True
   >>> issubclass(bytes, Buffer)
   True
   >>> issubclass(memoryview, Buffer)
   True
   >>> isinstance("xy", Buffer)
   False
   >>> issubclass(str, Buffer)
   False

The new class can also be used in type annotations:

.. code-block:: python

   def need_buffer(b: Buffer) -> memoryview:
       return memoryview(b)

   need_buffer(b"xy")  # ok
   need_buffer("xy")  # rejected by static type checkers

Usage in stubs
--------------

For static typing purposes, types defined in C extensions usually
require stub files, as described in :pep:`484`. In stub files,
``types.Buffer`` may be used as a base class to indicate that a
class implements the buffer protocol.

For example, ``bytes`` may be declared as follows in a stub:

.. code-block:: python

   class bytes(types.Buffer, Sequence[int]):
       def decode(self, ...): ...
       ...

Static type checkers should not give any special treatment to
this class.

Equivalent for older Python versions
------------------------------------

New typing features are usually backported to older Python versions
in the ``typing_extensions`` package. Because the buffer protocol
is accessible only in C, ``types.Buffer`` cannot be implemented
in a pure Python package. As a temporary workaround, a
``typing_extensions.Buffer`` ABC will be provided on Python versions
that do not have ``types.Buffer`` available. For the benefit of
static type checkers, ``typing_extensions.Buffer`` can be used as
a base class in stubs to mark types as supporting the buffer protocol.
For runtime uses, the ``ABC.register`` API can be used to register
buffer classes with ``typing_extensions.Buffer``.


No special meaning for ``bytes``
--------------------------------

The documentation for ``typing.ByteString`` currently states:

   This type represents the types ``bytes``, ``bytearray``, and
   ``memoryview`` of byte sequences.
 
   As a shorthand for this type, ``bytes`` can be used to annotate
   arguments of any of the types mentioned above.

The behavior in the second paragraph was not specified in :pep:`484`
or any subsequent PEP. We propose to remove it from the documentation.
With ``types.Buffer`` available as an alternative, there is no good
reason to allow ``bytes`` as a shorthand.
Type checkers that implement this behavior should deprecate and
eventually remove it.


Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

None.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.

.. notes
.. https://github.com/python/cpython/commit/2a19d956ab92fc9084a105cc11292cb0438b322f (added ByteString verbiage)
.. https://github.com/python/typing/issues/593
.. https://github.com/python/cpython/issues/71688 (proposed Buffer ABC)
.. https://github.com/python/mypy/issues/12643 (user report sad about current bytes behavior)
