PEP: 9999
Title: Implementing Sentinel Values
Author: Tal Einat <tal@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 22-May-2021
Post-History: 22-May-2021


Abstract
========

Unique placeholder values, widely known as "sentinel values", are useful in
Python programs for several things, such as default values for function
arguments where ``None`` is a valid input value.  These cases are common
enough for several idioms for implementing such "sentinels" to have arisen over
the years, but uncommon enough that there hasn't been a clear need for
standardization.

However, the common implementations suffer from several drawbacks, which are
significant enough to justify considering choosing a recommended implementation
which avoids those drawbacks.

This PEP suggests supplying a recommended way to define sentinel values, to be
used in the stdlib and made publicly available as part of the stdlib.  Changing
all existing sentinels in the stdlib to be implemented this way is not deemed
necessary, and whether to do so is left to the discretion of each maintainer.


Motivation
==========

In May 2021, a question was brought up on the python-dev mailing list
[#python-dev-thread]_
about how to better implement a sentinel value for
``traceback.print_exception``.  The existing implementation used the
following common idiom:

::

    _sentinel = object()

However, this object has an overly verbose repr, causing the function's
signature to be overly long and hard to read, as seen e.g. when calling
``help()``:

::

    >>> help(traceback.print_exception)
    Help on function print_exception in module traceback:

    print_exception(exc, /, value=<object object at
    0x000002825DF09650>, tb=<object object at 0x000002825DF09650>,
    limit=None, file=None, chain=True)

Additionally, two additional drawbacks of many existing sentinels were brought
up in the discussion:

1. Not having a distinct type, hence it being impossible to define a strict
   type signature for a function where the sentinel is a default value
2. Incorrect behavior after being copied or unpickled, due to a separate
   instance being created and thus comparisons using ``is`` failing

In the ensuing discussion, Victor Stinner supplied a list of currently used
sentinel values in the Python standard library [#list-of-sentinels-in-stdlib]_.
This showed that the need for sentinels is fairly common, that there are
various implementation methods used even within the stdlib, and that many of
these suffer from at least one of the aforementioned drawbacks.

The discussion did not lead to any clear consensus on whether a standard
implementation method is needed or desirable, whether the drawbacks mentioned
are significant, nor which kind of implementation would be good. A poll was
created on discuss.python.org [#poll]_ to get a clearer sense of the
community's opinions. As of this writing (May 21st 2021) the poll's results
are not conclusive, with 41% of voters voting for "Consistent use of a new,
dedicated sentinel factory / class / meta-class, also made publicly available
in the stdlib", but 41% also voting for "The status-quo is fine / thereâ€™s no
need for consistency in this".

With such mixed opinions, this PEP was created to facilitate making a decision
on the subject.


Rationale
=========

The criteria guiding the chosen implementation were:

1. The sentinel objects should behave as expected by a sentinel object: When
   compared using the ``is`` operator, it should always be considered identical
   to itself but never to any other object.
2. It should be simple to define as many distinct sentinel values as needed.
3. The sentinel objects should have a clear and short repr.
4. The sentinel objects should each have a distinct type, usable in type
   annotations.
5. The sentinel objects should behave correctly after copying and/or
   unpickling.
6. If possible, avoid inspecting the stack frame in order to find the name
   of the module where the sentinel is defined.
7. More generally, the implementation should be as simple as possible,
   avoiding any "magic" behavior and not relying on any fragile or
   implementation-specific features.

After researching existing idioms and implementations, and going through many
different possible implementations, a simple and straightforward implementation
was written which meets all of these criteria
(see `Reference Implementation`_).


Specification
=============

A new ``sentinel`` class decorator will be added to the *<to be decided...>*
module.  It will be used as following:

::

    @sentinel(repr='<NotGiven>')
    class NotGivenType: pass
    NotGiven = NotGivenType()


The suggested repr for a sentinel named ``NotGiven`` is ``<NotGiven>``. This
is short and clear, and thus good when shown in function signatures.


Reference Implementation
========================

The suggested implementation is simple and straightforward:

::

    def sentinel(repr):
        """Class decorator for defining sentinel values.

        Usage:

        @sentinel(repr='<NotGiven>')
        class NotGivenType: pass
        NotGiven = NotGivenType()
        """
        # Bail if mistakenly used without providing a repr.
        assert isinstance(repr, str)

        def inner(cls):
            cls.__repr__ = lambda self: repr
            instance = cls()
            cls.__new__ = lambda cls: instance
            return cls
        return inner

This is equivalent to using the following idiom (but less error-prone and
easier to remember):

::

    class NotGivenType:
        def __repr__(self):
            return '<NotGiven>'
    NotGiven = NotGivenType()
    NotGivenType.__new__ = lambda cls: NotGiven


Rejected Ideas
==============


Use ``NotGiven = object()``
---------------------------

This suffers from all of the drawbacks mentioned in the `Rationale`_ section.


Add a single new sentinel value, e.g. ``MISSING`` or ``Sentinel``
-----------------------------------------------------------------

Since such a value could be used for various things in various places, one
could not always be confident that it would never be a valid value in some use
cases.  On the other hand, a dedicated and distinct sentinel value can be used
with confidence without needing to consider potential edge-cases.

Additionally, it is useful to be able to provide a meaningful name and repr
for a sentinel value, specific to the context where it is used.

Finally, this was a very unpopular option in the poll, with only 12% of
the votes voting for it.


Use the existing ``Ellipsis`` sentinel value
--------------------------------------------

This is not the original intended use of Ellipsis, though it has become
increasingly common to use it to define empty class or function blocks instead
of using ``pass``.

Also, similar to a potential new single sentinel value, ``Ellipsis`` can't be
as confidently used in all cases, unlike a dedicated, distinct value.


Use a single-valued enum
------------------------

The suggested idiom is:

::

    class NotGivenType(Enum):
        NotGiven = 'NotGiven'
    NotGiven = NotGivenType.NotGiven

Besides the excessive repetition, the repr is overly long:
``<NotGivenType.NotGiven: 'NotGiven'>``.  A shorter repr can be defined, at
the expense of a bit more code and yet more repetition.

Finally, this option was the least popular among the nine options in the poll
[#poll]_, being the only option to receive no votes.


A sentinel factory function
---------------------------

The interface would be something like: ``NotGiven = make_sentinel('NotGiven')``

In order for things like pickling and copying to work as expected, this
requires some fragile code to inspect the stack frame in order to figure out
which module the function is called from.  Additionally, making the sentinel's
type available in the module namespace requires more fragile, "magical" code.
Such implementations all turned out harder to write, read and maintain.
Finally, the basic tools needed are not supported by all implementations of
Python.

While this was not deemed out of the question, as similar methods are already
used by ``namedtuple``, ``enum.Enum`` and by the ``logging`` module, it was
preferred to avoid them if possible, and a much simpler alternative was found.


Define a recommended "standard" idiom, without supplying an implementation
--------------------------------------------------------------------------

Most common exiting idioms have significant drawbacks.

The idiom which is equivalent to the suggested reference implementation is a
bit long and fragile for something that would be recommended to be widely
used.

Finally, in the poll on this subject [#poll]_, recommending an idiom very
similar to the one equivalent to the suggested implementation was voted for
by only 25% of the voters.  Other options for recommending an idiom received
even less votes.


Open Issues
===========

* To which module should the new ``sentinel`` class decorator be added?
* Perhaps the "sentinel factory" implementation is better, since using it is
  much simpler?  The drawback may not be significant considering that
  inspecting the stack frame to find the name of a module a function was
  called from is already done by at least 3 prominent tools in the stdlib


References
==========

.. [#python-dev-thread] Python-Dev mailing list: `The repr of a sentinel <https://mail.python.org/archives/list/python-dev@python.org/thread/ZLVPD2OISI7M4POMTR2FCQTE6TPMPTO3/>`_
.. [#list-of-sentinels-in-stdlib] Python-Dev mailing list: `"The stdlib contains tons of sentinels" <https://mail.python.org/archives/list/python-dev@python.org/message/JBYXQH3NV3YBF7P2HLHB5CD6V3GVTY55/>`_
.. [#poll] discuss.python.org Poll: `Sentinel Values in the Stdlib <https://discuss.python.org/t/sentinel-values-in-the-stdlib/8810/>`_
.. [4] `bpo-44123: Make function parameter sentinel values true singletons <https://bugs.python.org/issue44123>`_
.. [5] `The "sentinels" package on PyPI <https://pypi.org/project/sentinels/>`_
.. [6] `The "sentinel" package on PyPI <https://pypi.org/project/sentinel/>`_


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

