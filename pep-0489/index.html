
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 489 – Multi-phase extension module initialization | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0489/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 489 – Multi-phase extension module initialization | peps.python.org'>
    <meta property="og:description" content="This PEP proposes a redesign of the way in which built-in and extension modules interact with the import machinery. This was last revised for Python 3.0 in PEP 3121, but did not solve all problems at the time. The goal is to solve import-related problem...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0489/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes a redesign of the way in which built-in and extension modules interact with the import machinery. This was last revised for Python 3.0 in PEP 3121, but did not solve all problems at the time. The goal is to solve import-related problem...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 489</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 489 – Multi-phase extension module initialization</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Petr Viktorin &lt;encukou&#32;&#97;t&#32;gmail.com&gt;,
Stefan Behnel &lt;stefan_ml&#32;&#97;t&#32;behnel.de&gt;,
Alyssa Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">BDFL-Delegate<span class="colon">:</span></dt>
<dd class="field-even">Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/import-sig/">Import-SIG list</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">11-Aug-2013</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.5</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even">23-Aug-2013, 20-Feb-2015, 16-Apr-2015, 07-May-2015, 18-May-2015</dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-May/140108.html">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#the-current-process">The current process</a></li>
<li><a class="reference internal" href="#the-proposal">The proposal</a><ul>
<li><a class="reference internal" href="#pseudo-code-overview">Pseudo-code Overview</a></li>
<li><a class="reference internal" href="#module-creation-phase">Module Creation Phase</a><ul>
<li><a class="reference internal" href="#the-py-mod-create-slot">The Py_mod_create slot</a></li>
<li><a class="reference internal" href="#post-creation-steps">Post-creation steps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-execution-phase">Module Execution Phase</a><ul>
<li><a class="reference internal" href="#pre-execution-steps">Pre-Execution steps</a></li>
<li><a class="reference internal" href="#the-py-mod-exec-slot">The Py_mod_exec slot</a></li>
</ul>
</li>
<li><a class="reference internal" href="#legacy-init">Legacy Init</a></li>
<li><a class="reference internal" href="#built-in-modules">Built-In modules</a></li>
<li><a class="reference internal" href="#subinterpreters-and-interpreter-reloading">Subinterpreters and Interpreter Reloading</a></li>
<li><a class="reference internal" href="#functions-incompatible-with-multi-phase-initialization">Functions incompatible with multi-phase initialization</a></li>
<li><a class="reference internal" href="#module-state-and-c-level-callbacks">Module state and C-level callbacks</a></li>
<li><a class="reference internal" href="#new-functions">New Functions</a></li>
<li><a class="reference internal" href="#export-hook-name">Export Hook Name</a></li>
<li><a class="reference internal" href="#module-reloading">Module Reloading</a></li>
<li><a class="reference internal" href="#multiple-modules-in-one-library">Multiple modules in one library</a></li>
<li><a class="reference internal" href="#testing-and-initial-implementations">Testing and initial implementations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-api-changes-and-additions">Summary of API Changes and Additions</a><ul>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-future-extensions">Possible Future Extensions</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#previous-approaches">Previous Approaches</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<div class="pep-banner canonical-doc sticky-banner admonition important">
<p class="admonition-title">Important</p>
<p>This PEP is a historical document. The up-to-date, canonical documentation can now be found at <a class="reference external" href="https://docs.python.org/3.13/c-api/module.html#initializing-modules" title="(in Python v3.13)"><span>Initializing C modules</span></a>.
For Python 3.14+, see <a class="reference external" href="https://docs.python.org/3/c-api/extension-modules.html#extension-modules" title="(in Python v3.14)"><span>Defining extension modules</span></a>
and <a class="reference external" href="https://docs.python.org/3/c-api/module.html#pymoduledef" title="(in Python v3.14)"><span>Module definitions</span></a>.</p>
<p class="close-button">×</p>
<p>See <a class="pep reference internal" href="../pep-0001/" title="PEP 1 – PEP Purpose and Guidelines">PEP 1</a> for how to propose changes.</p>
</div>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes a redesign of the way in which built-in and extension modules
interact with the import machinery. This was last revised for Python 3.0 in PEP
3121, but did not solve all problems at the time. The goal is to solve
import-related problems by bringing extension modules closer to the way Python
modules behave; specifically to hook into the ModuleSpec-based loading
mechanism introduced in <a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a>.</p>
<p>This proposal draws inspiration from <code class="docutils literal notranslate"><span class="pre">PyType_Spec</span></code> of <a class="pep reference internal" href="../pep-0384/" title="PEP 384 – Defining a Stable ABI">PEP 384</a> to allow extension
authors to only define features they need, and to allow future additions
to extension module declarations.</p>
<p>Extensions modules are created in a two-step process, fitting better into
the ModuleSpec architecture, with parallels to <code class="docutils literal notranslate"><span class="pre">__new__</span></code> and <code class="docutils literal notranslate"><span class="pre">__init__</span></code> of classes.</p>
<p>Extension modules can safely store arbitrary C-level per-module state in
the module that is covered by normal garbage collection and supports
reloading and sub-interpreters.
Extension authors are encouraged to take these issues into account
when using the new API.</p>
<p>The proposal also allows extension modules with non-ASCII names.</p>
<p>Not all problems tackled in <a class="pep reference internal" href="../pep-3121/" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a> are solved in this proposal.
In particular, problems with run-time module lookup (<code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code>)
are left to a future PEP.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Python modules and extension modules are not being set up in the same way.
For Python modules, the module object is created and set up first, then the
module code is being executed (<a class="pep reference internal" href="../pep-0302/" title="PEP 302 – New Import Hooks">PEP 302</a>).
A ModuleSpec object (<a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a>) is used to hold information about the module,
and passed to the relevant hooks.</p>
<p>For extensions (i.e. shared libraries) and built-in modules, the module
init function is executed straight away and does both the creation and
initialization. The initialization function is not passed the ModuleSpec,
or any information it contains, such as the <code class="docutils literal notranslate"><span class="pre">__file__</span></code> or fully-qualified
name. This hinders relative imports and resource loading.</p>
<p>In Py3, modules are also not being added to sys.modules, which means that a
(potentially transitive) re-import of the module will really try to re-import
it and thus run into an infinite loop when it executes the module init function
again. Without access to the fully-qualified module name, it is not trivial to
correctly add the module to sys.modules either.
This is specifically a problem for Cython generated modules, for which it’s
not uncommon that the module init code has the same level of complexity as
that of any ‘regular’ Python module. Also, the lack of <code class="docutils literal notranslate"><span class="pre">__file__</span></code> and <code class="docutils literal notranslate"><span class="pre">__name__</span></code>
information hinders the compilation of “<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>” modules, i.e. packages,
especially when relative imports are being used at module init time.</p>
<p>Furthermore, the majority of currently existing extension modules has
problems with sub-interpreter support and/or interpreter reloading, and, while
it is possible with the current infrastructure to support these
features, it is neither easy nor efficient.
Addressing these issues was the goal of <a class="pep reference internal" href="../pep-3121/" title="PEP 3121 – Extension Module Initialization and Finalization">PEP 3121</a>, but many extensions,
including some in the standard library, took the least-effort approach
to porting to Python 3, leaving these issues unresolved.
This PEP keeps backwards compatibility, which should reduce pressure and give
extension authors adequate time to consider these issues when porting.</p>
</section>
<section id="the-current-process">
<h2><a class="toc-backref" href="#the-current-process" role="doc-backlink">The current process</a></h2>
<p>Currently, extension and built-in modules export an initialization function
named “<code class="docutils literal notranslate"><span class="pre">PyInit_modulename</span></code>”, named after the file name of the shared library.
This function is executed by the import machinery and must return a fully
initialized module object.
The function receives no arguments, so it has no way of knowing about its
import context.</p>
<p>During its execution, the module init function creates a module object
based on a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object. It then continues to initialize it by adding
attributes to the module dict, creating types, etc.</p>
<p>In the back, the shared library loader keeps a note of the fully qualified
module name of the last module that it loaded, and when a module gets
created that has a matching name, this global variable is used to determine
the fully qualified name of the module object. This is not entirely safe as it
relies on the module init function creating its own module object first,
but this assumption usually holds in practice.</p>
</section>
<section id="the-proposal">
<h2><a class="toc-backref" href="#the-proposal" role="doc-backlink">The proposal</a></h2>
<p>The initialization function (<code class="docutils literal notranslate"><span class="pre">PyInit_modulename</span></code>) will be allowed to return
a pointer to a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object. The import machinery will be in charge
of constructing the module object, calling hooks provided in the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>
in the relevant phases of initialization (as described below).</p>
<p>This multi-phase initialization is an additional possibility. Single-phase
initialization, the current practice of returning a fully initialized module
object, will still be accepted, so existing code will work unchanged,
including binary compatibility.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure will be changed to contain a list of slots,
similarly to <a class="pep reference internal" href="../pep-0384/" title="PEP 384 – Defining a Stable ABI">PEP 384</a>’s <code class="docutils literal notranslate"><span class="pre">PyType_Spec</span></code> for types.
To keep binary compatibility, and avoid needing to introduce a new structure
(which would introduce additional supporting functions and per-module storage),
the currently unused <em>m_reload</em> pointer of <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> will be changed to
hold the slots. The structures are defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">slot</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyModuleDef</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyModuleDef_Base</span><span class="w"> </span><span class="n">m_base</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">m_name</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">m_doc</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">m_size</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="o">*</span><span class="n">m_methods</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="o">*</span><span class="n">m_slots</span><span class="p">;</span><span class="w">  </span><span class="cm">/* changed from `inquiry m_reload;` */</span>
<span class="w">    </span><span class="n">traverseproc</span><span class="w"> </span><span class="n">m_traverse</span><span class="p">;</span>
<span class="w">    </span><span class="n">inquiry</span><span class="w"> </span><span class="n">m_clear</span><span class="p">;</span>
<span class="w">    </span><span class="n">freefunc</span><span class="w"> </span><span class="n">m_free</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="p">;</span>
</pre></div>
</div>
<p>The <em>m_slots</em> member must be either NULL, or point to an array of
<code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code> structures, terminated by a slot with id set to 0
(i.e. <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">NULL}</span></code>).</p>
<p>To specify a slot, a unique slot ID must be provided.
New Python versions may introduce new slot IDs, but slot IDs will never be
recycled. Slots may get deprecated, but will continue to be supported
throughout Python 3.x.</p>
<p>A slot’s value pointer may not be NULL, unless specified otherwise in the
slot’s documentation.</p>
<p>The following slots are currently available, and described later:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code></li>
</ul>
<p>Unknown slot IDs will cause the import to fail with SystemError.</p>
<p>When using multi-phase initialization, the <em>m_name</em> field of <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> will
not be used during importing; the module name will be taken from the ModuleSpec.</p>
<p>Before it is returned from PyInit_*, the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object must be initialized
using the newly added <code class="docutils literal notranslate"><span class="pre">PyModuleDef_Init</span></code> function. This sets the object type
(which cannot be done statically on certain compilers), refcount, and internal
bookkeeping data (<em>m_index</em>).
For example, an extension module “example” would be exported as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="w"> </span><span class="n">example_def</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{...}</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="n">PyInit_example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyModuleDef_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">example_def</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object must be available for the lifetime of the module created
from it – usually, it will be declared statically.</p>
<section id="pseudo-code-overview">
<h3><a class="toc-backref" href="#pseudo-code-overview" role="doc-backlink">Pseudo-code Overview</a></h3>
<p>Here is an overview of how the modified importers will operate.
Details such as logging or handling of errors and invalid states
are left out, and C code is presented with a concise Python-like syntax.</p>
<p>The framework that calls the importers is explained in
<a class="pep reference internal" href="../pep-0451/#how-loading-will-work" title="PEP 451 – A ModuleSpec Type for the Import System § How Loading Will Work">PEP 451</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">importlib/_bootstrap.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BuiltinImporter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">_imp</span><span class="o">.</span><span class="n">create_builtin</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">exec_dynamic</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># use a backwards compatibility shim</span>
        <span class="n">_load_module_shim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">importlib/_bootstrap_external.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ExtensionFileLoader</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">_imp</span><span class="o">.</span><span class="n">create_dynamic</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">exec_dynamic</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># use a backwards compatibility shim</span>
        <span class="n">_load_module_shim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Python/import.c</span></code> (the <code class="docutils literal notranslate"><span class="pre">_imp</span></code> module):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">create_dynamic</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span>

    <span class="c1"># Find an already loaded module that used single-phase init.</span>
    <span class="c1"># For multi-phase initialization, mod is NULL, so a new module</span>
    <span class="c1"># is always created.</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">_PyImport_FindExtensionObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mod</span>

    <span class="k">return</span> <span class="n">_PyImport_LoadDynamicModuleWithSpec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">exec_dynamic</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
        <span class="c1"># non-modules are skipped -- PyModule_GetDef fails on them</span>
        <span class="k">return</span>

    <span class="k">def</span><span class="w"> </span><span class="o">=</span> <span class="n">PyModule_GetDef</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">NULL</span><span class="p">:</span>
        <span class="n">PyModule_ExecDef</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">def</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">create_builtin</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># Find an already loaded module that used single-phase init.</span>
    <span class="c1"># For multi-phase initialization, mod is NULL, so a new module</span>
    <span class="c1"># is always created.</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">_PyImport_FindExtensionObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mod</span>

    <span class="k">for</span> <span class="n">initname</span><span class="p">,</span> <span class="n">initfunc</span> <span class="ow">in</span> <span class="n">PyImport_Inittab</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">initname</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">initfunc</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PyModuleDef</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="o">=</span> <span class="n">m</span>
                <span class="k">return</span> <span class="n">PyModule_FromDefAndSpec</span><span class="p">(</span><span class="n">def</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fall back to single-phase initialization</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">_PyImport_FixupExtensionObject</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Python/importdl.c</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_PyImport_LoadDynamicModuleWithSpec</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span>
    <span class="n">package</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

    <span class="c1"># see the &quot;Non-ASCII module names&quot; section for export_hook_name</span>
    <span class="n">hook_name</span> <span class="o">=</span> <span class="n">export_hook_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># call platform-specific function for loading exported function</span>
    <span class="c1"># from shared library</span>
    <span class="n">exportfunc</span> <span class="o">=</span> <span class="n">_find_shared_funcptr</span><span class="p">(</span><span class="n">hook_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">exportfunc</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PyModuleDef</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">PyModule_FromDefAndSpec</span><span class="p">(</span><span class="n">def</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>

    <span class="n">module</span> <span class="o">=</span> <span class="n">m</span>

    <span class="c1"># fall back to single-phase initialization</span>
    <span class="o">....</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Objects/moduleobject.c</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">PyModule_FromDefAndSpec</span><span class="p">(</span><span class="n">def</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span>
    <span class="n">create</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">def</span><span class="o">.</span><span class="n">m_slots</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="o">==</span> <span class="n">Py_mod_create</span><span class="p">:</span>
            <span class="n">create</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">def</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_New</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
        <span class="n">m</span><span class="o">.</span><span class="n">md_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">m</span><span class="o">.</span><span class="n">md_def</span> <span class="o">=</span> <span class="k">def</span>

<span class="w">    </span><span class="nf">if</span> <span class="n">def</span><span class="o">.</span><span class="n">m_methods</span><span class="p">:</span>
        <span class="n">PyModule_AddFunctions</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">def</span><span class="o">.</span><span class="n">m_methods</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">def</span><span class="o">.</span><span class="n">m_doc</span><span class="p">:</span>
        <span class="n">PyModule_SetDocString</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">def</span><span class="o">.</span><span class="n">m_doc</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">PyModule_ExecDef</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">def</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">module_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">module</span><span class="o">.</span><span class="n">md_state</span> <span class="ow">is</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="c1"># allocate a block of zeroed-out memory</span>
            <span class="n">module</span><span class="o">.</span><span class="n">md_state</span> <span class="o">=</span> <span class="n">_alloc</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">md_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">def</span><span class="o">.</span><span class="n">m_slots</span> <span class="ow">is</span> <span class="n">NULL</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">def</span><span class="o">.</span><span class="n">m_slots</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="o">==</span> <span class="n">Py_mod_exec</span><span class="p">:</span>
            <span class="n">value</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="module-creation-phase">
<h3><a class="toc-backref" href="#module-creation-phase" role="doc-backlink">Module Creation Phase</a></h3>
<p>Creation of the module object – that is, the implementation of
<code class="docutils literal notranslate"><span class="pre">ExecutionLoader.create_module</span></code> – is governed by the <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> slot.</p>
<section id="the-py-mod-create-slot">
<h4><a class="toc-backref" href="#the-py-mod-create-slot" role="doc-backlink">The Py_mod_create slot</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> slot is used to support custom module subclasses.
The value pointer must point to a function with the following signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">PyModuleCreateFunction</span><span class="p">)(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">spec</span><span class="p">,</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="w"> </span><span class="o">*</span><span class="n">def</span><span class="p">)</span>
</pre></div>
</div>
<p>The function receives a ModuleSpec instance, as defined in <a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a>,
and the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure.
It should return a new module object, or set an error
and return NULL.</p>
<p>This function is not responsible for setting import-related attributes
specified in <a class="pep reference internal" href="../pep-0451/#attributes" title="PEP 451 – A ModuleSpec Type for the Import System § Attributes">PEP 451</a> (such as <code class="docutils literal notranslate"><span class="pre">__name__</span></code> or
<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>) on the new module.</p>
<p>There is no requirement for the returned object to be an instance of
<code class="docutils literal notranslate"><span class="pre">types.ModuleType</span></code>. Any type can be used, as long as it supports setting and
getting attributes, including at least the import-related attributes.
However, only <code class="docutils literal notranslate"><span class="pre">ModuleType</span></code> instances support module-specific functionality
such as per-module state and processing of execution slots.
If something other than a <code class="docutils literal notranslate"><span class="pre">ModuleType</span></code> subclass is returned, no execution slots
may be defined; if any are, a <code class="docutils literal notranslate"><span class="pre">SystemError</span></code> is raised.</p>
<p>Note that when this function is called, the module’s entry in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>
is not populated yet. Attempting to import the same module again
(possibly transitively), may lead to an infinite loop.
Extension authors are advised to keep <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> minimal, an in particular
to not call user code from it.</p>
<p>Multiple <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> slots may not be specified. If they are, import
will fail with <code class="docutils literal notranslate"><span class="pre">SystemError</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> is not specified, the import machinery will create a normal
module object using <code class="docutils literal notranslate"><span class="pre">PyModule_New</span></code>. The name is taken from <em>spec</em>.</p>
</section>
<section id="post-creation-steps">
<h4><a class="toc-backref" href="#post-creation-steps" role="doc-backlink">Post-creation steps</a></h4>
<p>If the <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> function returns an instance of <code class="docutils literal notranslate"><span class="pre">types.ModuleType</span></code>
or a subclass (or if a <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> slot is not present), the import
machinery will associate the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> with the module.
This also makes the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> accessible to execution phase, the
<code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code> function, and garbage collection routines (traverse,
clear, free).</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> function does not return a module subclass, then <em>m_size</em>
must be 0, and <em>m_traverse</em>, <em>m_clear</em> and <em>m_free</em> must all be NULL.
Otherwise, <code class="docutils literal notranslate"><span class="pre">SystemError</span></code> is raised.</p>
<p>Additionally, initial attributes specified in the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> are set on the
module object, regardless of its type:</p>
<ul class="simple">
<li>The docstring is set from <em>m_doc</em>, if non-NULL.</li>
<li>The module’s functions are initialized from <em>m_methods</em>, if any.</li>
</ul>
</section>
</section>
<section id="module-execution-phase">
<h3><a class="toc-backref" href="#module-execution-phase" role="doc-backlink">Module Execution Phase</a></h3>
<p>Module execution – that is, the implementation of
<code class="docutils literal notranslate"><span class="pre">ExecutionLoader.exec_module</span></code> – is governed by “execution slots”.
This PEP only adds one, <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code>, but others may be added in the future.</p>
<p>The execution phase is done on the <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> associated with the module
object. For objects that are not a subclass of <code class="docutils literal notranslate"><span class="pre">PyModule_Type</span></code> (for which
<code class="docutils literal notranslate"><span class="pre">PyModule_GetDef</span></code> would fail), the execution phase is skipped.</p>
<p>Execution slots may be specified multiple times, and are processed in the order
they appear in the slots array.
When using the default import machinery, they are processed after
import-related attributes specified in <a class="pep reference internal" href="../pep-0451/#attributes" title="PEP 451 – A ModuleSpec Type for the Import System § Attributes">PEP 451</a>
(such as <code class="docutils literal notranslate"><span class="pre">__name__</span></code> or <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>) are set and the module is added
to <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<section id="pre-execution-steps">
<h4><a class="toc-backref" href="#pre-execution-steps" role="doc-backlink">Pre-Execution steps</a></h4>
<p>Before processing the execution slots, per-module state is allocated for the
module. From this point on, per-module state is accessible through
<code class="docutils literal notranslate"><span class="pre">PyModule_GetState</span></code>.</p>
</section>
<section id="the-py-mod-exec-slot">
<h4><a class="toc-backref" href="#the-py-mod-exec-slot" role="doc-backlink">The Py_mod_exec slot</a></h4>
<p>The entry in this slot must point to a function with the following signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">PyModuleExecFunction</span><span class="p">)(</span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
<p>It will be called to initialize a module. Usually, this amounts to
setting the module’s initial attributes.
The “module” argument receives the module object to initialize.</p>
<p>The function must return <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, or, on error, set an exception and
return <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">PyModuleExec</span></code> replaces the module’s entry in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>, the new object
will be used and returned by importlib machinery after all execution slots
are processed. This is a feature of the import machinery itself.
The slots themselves are all processed using the module returned from the
creation phase; <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> is not consulted during the execution phase.
(Note that for extension modules, implementing <code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code> is usually
a better solution for using custom module objects.)</p>
</section>
</section>
<section id="legacy-init">
<h3><a class="toc-backref" href="#legacy-init" role="doc-backlink">Legacy Init</a></h3>
<p>The backwards-compatible single-phase initialization continues to be supported.
In this scheme, the <code class="docutils literal notranslate"><span class="pre">PyInit</span></code> function returns a fully initialized module rather
than a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object.
In this case, the <code class="docutils literal notranslate"><span class="pre">PyInit</span></code> hook implements the creation phase, and the execution
phase is a no-op.</p>
<p>Modules that need to work unchanged on older versions of Python should stick to
single-phase initialization, because the benefits it brings can’t be
back-ported.
Here is an example of a module that supports multi-phase initialization,
and falls back to single-phase when compiled for an older version of CPython.
It is included mainly as an illustration of the changes needed to enable
multi-phase init:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Python.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">spam_exec</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyModule_AddStringConstant</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;food&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef Py_mod_exec</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef_Slot</span><span class="w"> </span><span class="n">spam_slots</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="n">Py_mod_exec</span><span class="p">,</span><span class="w"> </span><span class="n">spam_exec</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="w"> </span><span class="n">spam_def</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span><span class="w">                      </span><span class="cm">/* m_base */</span>
<span class="w">    </span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w">                                     </span><span class="cm">/* m_name */</span>
<span class="w">    </span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;Utilities for cooking spam&quot;</span><span class="p">),</span><span class="w">    </span><span class="cm">/* m_doc */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                                          </span><span class="cm">/* m_size */</span>
<span class="w">    </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                       </span><span class="cm">/* m_methods */</span>
<span class="cp">#ifdef Py_mod_exec</span>
<span class="w">    </span><span class="n">spam_slots</span><span class="p">,</span><span class="w">                                 </span><span class="cm">/* m_slots */</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="nb">NULL</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                       </span><span class="cm">/* m_traverse */</span>
<span class="w">    </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                       </span><span class="cm">/* m_clear */</span>
<span class="w">    </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                                       </span><span class="cm">/* m_free */</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_spam</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef Py_mod_exec</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyModuleDef_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spam_def</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">;</span>
<span class="w">    </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spam_def</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">module</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">spam_exec</span><span class="p">(</span><span class="n">module</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">module</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="built-in-modules">
<h3><a class="toc-backref" href="#built-in-modules" role="doc-backlink">Built-In modules</a></h3>
<p>Any extension module can be used as a built-in module by linking it into
the executable, and including it in the inittab (either at runtime with
<code class="docutils literal notranslate"><span class="pre">PyImport_AppendInittab</span></code>, or at configuration time, using tools like <em>freeze</em>).</p>
<p>To keep this possibility, all changes to extension module loading introduced
in this PEP will also apply to built-in modules.
The only exception is non-ASCII module names, explained below.</p>
</section>
<section id="subinterpreters-and-interpreter-reloading">
<h3><a class="toc-backref" href="#subinterpreters-and-interpreter-reloading" role="doc-backlink">Subinterpreters and Interpreter Reloading</a></h3>
<p>Extensions using the new initialization scheme are expected to support
subinterpreters and multiple <code class="docutils literal notranslate"><span class="pre">Py_Initialize</span></code>/<code class="docutils literal notranslate"><span class="pre">Py_Finalize</span></code> cycles correctly,
avoiding the issues mentioned in Python documentation <a class="footnote-reference brackets" href="#subinterpreter-docs" id="id1">[6]</a>.
The mechanism is designed to make this easy, but care is still required
on the part of the extension author.
No user-defined functions, methods, or instances may leak to different
interpreters.
To achieve this, all module-level state should be kept in either the module
dict, or in the module object’s storage reachable by <code class="docutils literal notranslate"><span class="pre">PyModule_GetState</span></code>.
A simple rule of thumb is: Do not define any static data, except built-in types
with no mutable or user-settable class attributes.</p>
</section>
<section id="functions-incompatible-with-multi-phase-initialization">
<h3><a class="toc-backref" href="#functions-incompatible-with-multi-phase-initialization" role="doc-backlink">Functions incompatible with multi-phase initialization</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PyModule_Create</span></code> function will fail when used on a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> structure
with a non-NULL <em>m_slots</em> pointer.
The function doesn’t have access to the ModuleSpec object necessary for
multi-phase initialization.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> function will return NULL, and <code class="docutils literal notranslate"><span class="pre">PyState_AddModule</span></code>
and <code class="docutils literal notranslate"><span class="pre">PyState_RemoveModule</span></code> will also fail on modules with non-NULL <em>m_slots</em>.
PyState registration is disabled because multiple module objects may be created
from the same <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>.</p>
</section>
<section id="module-state-and-c-level-callbacks">
<h3><a class="toc-backref" href="#module-state-and-c-level-callbacks" role="doc-backlink">Module state and C-level callbacks</a></h3>
<p>Due to the unavailability of <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code>, any function that needs access
to module-level state (including functions, classes or exceptions defined at
the module level) must receive a reference to the module object (or the
particular object it needs), either directly or indirectly.
This is currently difficult in two situations:</p>
<ul class="simple">
<li>Methods of classes, which receive a reference to the class, but not to
the class’s module</li>
<li>Libraries with C-level callbacks, unless the callbacks can receive custom
data set at callback registration</li>
</ul>
<p>Fixing these cases is outside of the scope of this PEP, but will be needed for
the new mechanism to be useful to all modules. Proper fixes have been discussed
on the import-sig mailing list <a class="footnote-reference brackets" href="#findmodule-discussion" id="id2">[5]</a>.</p>
<p>As a rule of thumb, modules that rely on <code class="docutils literal notranslate"><span class="pre">PyState_FindModule</span></code> are, at the moment,
not good candidates for porting to the new mechanism.</p>
</section>
<section id="new-functions">
<h3><a class="toc-backref" href="#new-functions" role="doc-backlink">New Functions</a></h3>
<p>A new function and macro implementing the module creation phase will be added.
These are similar to <code class="docutils literal notranslate"><span class="pre">PyModule_Create</span></code> and <code class="docutils literal notranslate"><span class="pre">PyModule_Create2</span></code>, except they
take an additional ModuleSpec argument, and handle module definitions with
non-NULL slots:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PyModule_FromDefAndSpec</span><span class="p">(</span><span class="n">PyModuleDef</span><span class="w"> </span><span class="o">*</span><span class="n">def</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PyModule_FromDefAndSpec2</span><span class="p">(</span><span class="n">PyModuleDef</span><span class="w"> </span><span class="o">*</span><span class="n">def</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">spec</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">module_api_version</span><span class="p">)</span>
</pre></div>
</div>
<p>A new function implementing the module execution phase will be added.
This allocates per-module state (if not allocated already), and <em>always</em>
processes execution slots. The import machinery calls this method when
a module is executed, unless the module is being reloaded:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyAPI_FUNC</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">PyModule_ExecDef</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">PyModuleDef</span><span class="w"> </span><span class="o">*</span><span class="n">def</span><span class="p">)</span>
</pre></div>
</div>
<p>Another function will be introduced to initialize a <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> object.
This idempotent function fills in the type, refcount, and module index.
It returns its argument cast to <code class="docutils literal notranslate"><span class="pre">PyObject*</span></code>, so it can be returned directly
from a <code class="docutils literal notranslate"><span class="pre">PyInit</span></code> function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">PyModuleDef_Init</span><span class="p">(</span><span class="n">PyModuleDef</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>Additionally, two helpers will be added for setting the docstring and
methods on a module:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">PyModule_SetDocString</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">PyModule_AddFunctions</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="export-hook-name">
<h3><a class="toc-backref" href="#export-hook-name" role="doc-backlink">Export Hook Name</a></h3>
<p>As portable C identifiers are limited to ASCII, module names
must be encoded to form the PyInit hook name.</p>
<p>For ASCII module names, the import hook is named
<code class="docutils literal notranslate"><span class="pre">PyInit_&lt;modulename&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;modulename&gt;</span></code> is the name of the module.</p>
<p>For module names containing non-ASCII characters, the import hook is named
<code class="docutils literal notranslate"><span class="pre">PyInitU_&lt;encodedname&gt;</span></code>, where the name is encoded using CPython’s
“punycode” encoding (<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3492.html"><strong>Punycode</strong></a> with a lowercase suffix),
with hyphens (“-”) replaced by underscores (“_”).</p>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">export_hook_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;U_&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;punycode&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;PyInit&#39;</span> <span class="o">+</span> <span class="n">suffix</span>
</pre></div>
</div>
<p>Examples:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head">Module name</th>
<th class="head">Init hook name</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td>spam</td>
<td><code class="docutils literal notranslate"><span class="pre">PyInit_spam</span></code></td>
</tr>
<tr class="row-odd"><td>lančmít</td>
<td><code class="docutils literal notranslate"><span class="pre">PyInitU_lanmt_2sa6t</span></code></td>
</tr>
<tr class="row-even"><td>スパム</td>
<td><code class="docutils literal notranslate"><span class="pre">PyInitU_zck5b2b</span></code></td>
</tr>
</tbody>
</table>
<p>For modules with non-ASCII names, single-phase initialization is not supported.</p>
<p>In the initial implementation of this PEP, built-in modules with non-ASCII
names will not be supported.</p>
</section>
<section id="module-reloading">
<h3><a class="toc-backref" href="#module-reloading" role="doc-backlink">Module Reloading</a></h3>
<p>Reloading an extension module using <code class="docutils literal notranslate"><span class="pre">importlib.reload()</span></code> will continue to
have no effect, except re-setting import-related attributes.</p>
<p>Due to limitations in shared library loading (both dlopen on POSIX and
<code class="docutils literal notranslate"><span class="pre">LoadModuleEx</span></code> on Windows), it is not generally possible to load
a modified library after it has changed on disk.</p>
<p>Use cases for reloading other than trying out a new version of the module
are too rare to require all module authors to keep reloading in mind.
If reload-like functionality is needed, authors can export a dedicated
function for it.</p>
</section>
<section id="multiple-modules-in-one-library">
<h3><a class="toc-backref" href="#multiple-modules-in-one-library" role="doc-backlink">Multiple modules in one library</a></h3>
<p>To support multiple Python modules in one shared library, the library can
export additional PyInit* symbols besides the one that corresponds
to the library’s filename.</p>
<p>Note that this mechanism can currently only be used to <em>load</em> extra modules,
but not to <em>find</em> them. (This is a limitation of the loader mechanism,
which this PEP does not try to modify.)
To work around the lack of a suitable finder, code like the following
can be used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.machinery</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">ExtensionFileLoader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_loader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
<p>On platforms that support symbolic links, these may be used to install one
library under multiple names, exposing all exported modules to normal
import machinery.</p>
</section>
<section id="testing-and-initial-implementations">
<h3><a class="toc-backref" href="#testing-and-initial-implementations" role="doc-backlink">Testing and initial implementations</a></h3>
<p>For testing, a new built-in module <code class="docutils literal notranslate"><span class="pre">_testmultiphase</span></code> will be created.
The library will export several additional modules using the mechanism
described in “Multiple modules in one library”.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">_testcapi</span></code> module will be unchanged, and will use single-phase
initialization indefinitely (or until it is no longer supported).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">array</span></code> and <code class="docutils literal notranslate"><span class="pre">xx*</span></code> modules will be converted to use multi-phase
initialization as part of the initial implementation.</p>
</section>
</section>
<section id="summary-of-api-changes-and-additions">
<h2><a class="toc-backref" href="#summary-of-api-changes-and-additions" role="doc-backlink">Summary of API Changes and Additions</a></h2>
<p>New functions:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec</span></code> (macro)</li>
<li><code class="docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec2</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">PyModule_ExecDef</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">PyModule_SetDocString</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">PyModule_AddFunctions</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">PyModuleDef_Init</span></code></li>
</ul>
<p>New macros:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_create</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code></li>
</ul>
<p>New types:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyModuleDef_Type</span></code> will be exposed</li>
</ul>
<p>New structures:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PyModuleDef_Slot</span></code></li>
</ul>
<p>Other changes:</p>
<p><code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_reload</span></code> changes to <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_slots</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">BuiltinImporter</span></code> and <code class="docutils literal notranslate"><span class="pre">ExtensionFileLoader</span></code> will now implement
<code class="docutils literal notranslate"><span class="pre">create_module</span></code> and <code class="docutils literal notranslate"><span class="pre">exec_module</span></code>.</p>
<p>The internal <code class="docutils literal notranslate"><span class="pre">_imp</span></code> module will have backwards incompatible changes:
<code class="docutils literal notranslate"><span class="pre">create_builtin</span></code>, <code class="docutils literal notranslate"><span class="pre">create_dynamic</span></code>, and <code class="docutils literal notranslate"><span class="pre">exec_dynamic</span></code> will be added;
<code class="docutils literal notranslate"><span class="pre">init_builtin</span></code>, <code class="docutils literal notranslate"><span class="pre">load_dynamic</span></code> will be removed.</p>
<p>The undocumented functions <code class="docutils literal notranslate"><span class="pre">imp.load_dynamic</span></code> and <code class="docutils literal notranslate"><span class="pre">imp.init_builtin</span></code> will
be replaced by backwards-compatible shims.</p>
<section id="backwards-compatibility">
<h3><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h3>
<p>Existing modules will continue to be source- and binary-compatible with new
versions of Python.
Modules that use multi-phase initialization will not be compatible with
versions of Python that do not implement this PEP.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">init_builtin</span></code> and <code class="docutils literal notranslate"><span class="pre">load_dynamic</span></code> will be removed from
the <code class="docutils literal notranslate"><span class="pre">_imp</span></code> module (but not from the <code class="docutils literal notranslate"><span class="pre">imp</span></code> module).</p>
<p>All changed loaders (<code class="docutils literal notranslate"><span class="pre">BuiltinImporter</span></code> and <code class="docutils literal notranslate"><span class="pre">ExtensionFileLoader</span></code>) will
remain backwards-compatible; the <code class="docutils literal notranslate"><span class="pre">load_module</span></code> method will be replaced by
a shim.</p>
<p>Internal functions of Python/import.c and Python/importdl.c will be removed.
(Specifically, these are <code class="docutils literal notranslate"><span class="pre">_PyImport_GetDynLoadFunc</span></code>,
<code class="docutils literal notranslate"><span class="pre">_PyImport_GetDynLoadWindows</span></code>, and <code class="docutils literal notranslate"><span class="pre">_PyImport_LoadDynamicModule</span></code>.)</p>
</section>
</section>
<section id="possible-future-extensions">
<h2><a class="toc-backref" href="#possible-future-extensions" role="doc-backlink">Possible Future Extensions</a></h2>
<p>The slots mechanism, inspired by <code class="docutils literal notranslate"><span class="pre">PyType_Slot</span></code> from <a class="pep reference internal" href="../pep-0384/" title="PEP 384 – Defining a Stable ABI">PEP 384</a>,
allows later extensions.</p>
<p>Some extension modules exports many constants; for example <code class="docutils literal notranslate"><span class="pre">_ssl</span></code> has
a long list of calls in the form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyModule_AddIntConstant</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SSL_ERROR_ZERO_RETURN&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">PY_SSL_ERROR_ZERO_RETURN</span><span class="p">);</span>
</pre></div>
</div>
<p>Converting this to a declarative list, similar to <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code>,
would reduce boilerplate, and provide free error-checking which
is often missing.</p>
<p>String constants and types can be handled similarly.
(Note that non-default bases for types cannot be portably specified
statically; this case would need a <code class="docutils literal notranslate"><span class="pre">Py_mod_exec</span></code> function that runs
before the slots are added. The free error-checking would still be
beneficial, though.)</p>
<p>Another possibility is providing a “<code class="docutils literal notranslate"><span class="pre">main</span></code>” function that would be run
when the module is given to Python’s <strong class="program">-m</strong> switch.
For this to work, the <code class="docutils literal notranslate"><span class="pre">runpy</span></code> module will need to be modified to take
advantage of ModuleSpec-based loading introduced in <a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a>.
Also, it will be necessary to add a mechanism for setting up a module
according to slots it wasn’t originally defined with.</p>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>Work-in-progress implementation is available in a GitHub repository <a class="footnote-reference brackets" href="#gh-repo" id="id3">[3]</a>;
a patchset is at <a class="footnote-reference brackets" href="#gh-patch" id="id4">[4]</a>.</p>
</section>
<section id="previous-approaches">
<h2><a class="toc-backref" href="#previous-approaches" role="doc-backlink">Previous Approaches</a></h2>
<p>Stefan Behnel’s initial proto-PEP <a class="footnote-reference brackets" href="#stefans-protopep" id="id5">[1]</a>
had a “<code class="docutils literal notranslate"><span class="pre">PyInit_modulename</span></code>” hook that would create a module class,
whose <code class="docutils literal notranslate"><span class="pre">__init__</span></code> would be then called to create the module.
This proposal did not correspond to the (then nonexistent) <a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a>,
where module creation and initialization is broken into distinct steps.
It also did not support loading an extension into pre-existing module objects.</p>
<p>Alyssa (Nick) Coghlan proposed “<code class="docutils literal notranslate"><span class="pre">Create</span></code>” and “<code class="docutils literal notranslate"><span class="pre">Exec</span></code>” hooks, and wrote a prototype
implementation <a class="footnote-reference brackets" href="#alyssas-prototype" id="id6">[2]</a>.
At this time <a class="pep reference internal" href="../pep-0451/" title="PEP 451 – A ModuleSpec Type for the Import System">PEP 451</a> was still not implemented, so the prototype
does not use ModuleSpec.</p>
<p>The original version of this PEP used <code class="docutils literal notranslate"><span class="pre">Create</span></code> and <code class="docutils literal notranslate"><span class="pre">Exec</span></code> hooks, and allowed
loading into arbitrary pre-constructed objects with <code class="docutils literal notranslate"><span class="pre">Exec</span></code> hook.
The proposal made extension module initialization closer to how Python modules
are initialized, but it was later recognized that this isn’t an important goal.
The current PEP describes a simpler solution.</p>
<p>A further iteration used a “<code class="docutils literal notranslate"><span class="pre">PyModuleExport</span></code>” hook as an alternative to <code class="docutils literal notranslate"><span class="pre">PyInit</span></code>,
where <code class="docutils literal notranslate"><span class="pre">PyInit</span></code> was used for existing scheme, and <code class="docutils literal notranslate"><span class="pre">PyModuleExport</span></code> for multi-phase.
However, not being able to determine the hook name based on module name
complicated automatic generation of <code class="docutils literal notranslate"><span class="pre">PyImport_Inittab</span></code> by tools like freeze.
Keeping only the <code class="docutils literal notranslate"><span class="pre">PyInit</span></code> hook name, even if it’s not entirely appropriate for
exporting a definition, yielded a much simpler solution.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="stefans-protopep" role="doc-footnote">
<dt class="label" id="stefans-protopep">[<a href="#id5">1</a>]</dt>
<dd><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-August/128087.html">https://mail.python.org/pipermail/python-dev/2013-August/128087.html</a></aside>
<aside class="footnote brackets" id="alyssas-prototype" role="doc-footnote">
<dt class="label" id="alyssas-prototype">[<a href="#id6">2</a>]</dt>
<dd><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-August/128101.html">https://mail.python.org/pipermail/python-dev/2013-August/128101.html</a></aside>
<aside class="footnote brackets" id="gh-repo" role="doc-footnote">
<dt class="label" id="gh-repo">[<a href="#id3">3</a>]</dt>
<dd><a class="reference external" href="https://github.com/encukou/cpython/commits/pep489">https://github.com/encukou/cpython/commits/pep489</a></aside>
<aside class="footnote brackets" id="gh-patch" role="doc-footnote">
<dt class="label" id="gh-patch">[<a href="#id4">4</a>]</dt>
<dd><a class="reference external" href="https://github.com/encukou/cpython/compare/master...encukou:pep489.patch">https://github.com/encukou/cpython/compare/master…encukou:pep489.patch</a></aside>
<aside class="footnote brackets" id="findmodule-discussion" role="doc-footnote">
<dt class="label" id="findmodule-discussion">[<a href="#id2">5</a>]</dt>
<dd><a class="reference external" href="https://mail.python.org/pipermail/import-sig/2015-April/000959.html">https://mail.python.org/pipermail/import-sig/2015-April/000959.html</a></aside>
<aside class="footnote brackets" id="subinterpreter-docs" role="doc-footnote">
<dt class="label" id="subinterpreter-docs">[<a href="#id1">6</a>]</dt>
<dd><a class="reference external" href="https://docs.python.org/3/c-api/init.html#sub-interpreter-support">https://docs.python.org/3/c-api/init.html#sub-interpreter-support</a></aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0489.rst">https://github.com/python/peps/blob/main/peps/pep-0489.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0489.rst">2025-10-07 15:05:23 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#the-current-process">The current process</a></li>
<li><a class="reference internal" href="#the-proposal">The proposal</a><ul>
<li><a class="reference internal" href="#pseudo-code-overview">Pseudo-code Overview</a></li>
<li><a class="reference internal" href="#module-creation-phase">Module Creation Phase</a><ul>
<li><a class="reference internal" href="#the-py-mod-create-slot">The Py_mod_create slot</a></li>
<li><a class="reference internal" href="#post-creation-steps">Post-creation steps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-execution-phase">Module Execution Phase</a><ul>
<li><a class="reference internal" href="#pre-execution-steps">Pre-Execution steps</a></li>
<li><a class="reference internal" href="#the-py-mod-exec-slot">The Py_mod_exec slot</a></li>
</ul>
</li>
<li><a class="reference internal" href="#legacy-init">Legacy Init</a></li>
<li><a class="reference internal" href="#built-in-modules">Built-In modules</a></li>
<li><a class="reference internal" href="#subinterpreters-and-interpreter-reloading">Subinterpreters and Interpreter Reloading</a></li>
<li><a class="reference internal" href="#functions-incompatible-with-multi-phase-initialization">Functions incompatible with multi-phase initialization</a></li>
<li><a class="reference internal" href="#module-state-and-c-level-callbacks">Module state and C-level callbacks</a></li>
<li><a class="reference internal" href="#new-functions">New Functions</a></li>
<li><a class="reference internal" href="#export-hook-name">Export Hook Name</a></li>
<li><a class="reference internal" href="#module-reloading">Module Reloading</a></li>
<li><a class="reference internal" href="#multiple-modules-in-one-library">Multiple modules in one library</a></li>
<li><a class="reference internal" href="#testing-and-initial-implementations">Testing and initial implementations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-api-changes-and-additions">Summary of API Changes and Additions</a><ul>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-future-extensions">Possible Future Extensions</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#previous-approaches">Previous Approaches</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0489.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>