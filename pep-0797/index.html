
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 797 – Shared Object Proxies | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0797/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 797 – Shared Object Proxies | peps.python.org'>
    <meta property="og:description" content="This PEP introduces a new share() function to the concurrent.interpreters module, which allows any arbitrary object to be shared across interpreters using an object proxy, at the cost of being less efficient to concurrently access across multiple interp...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0797/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP introduces a new share() function to the concurrent.interpreters module, which allows any arbitrary object to be shared across interpreters using an object proxy, at the cost of being less efficient to concurrently access across multiple interp...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 797</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 797 – Shared Object Proxies" data-pagefind-weight="10" class="visually-hidden">PEP 797 – Shared Object Proxies</span>
            <section id="pep-content">
<h1 class="page-title">PEP 797 – Shared Object Proxies</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Peter Bierma &lt;peter&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/105709">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">08-Aug-2025</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.15</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/97306" title="Discourse thread">01-Jul-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/105709" title="Discourse thread">13-Jan-2026</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#many-objects-cannot-be-shared-between-subinterpreters">Many Objects Cannot be Shared Between Subinterpreters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#a-fallback-for-object-sharing">A Fallback for Object Sharing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#interpreter-switching">Interpreter Switching</a></li>
<li><a class="reference internal" href="#method-proxying">Method Proxying</a></li>
<li><a class="reference internal" href="#multithreaded-scaling">Multithreaded Scaling</a></li>
<li><a class="reference internal" href="#proxy-copying">Proxy Copying</a></li>
<li><a class="reference internal" href="#thread-local-state">Thread-local State</a></li>
<li><a class="reference internal" href="#memory-management">Memory Management</a><ul>
<li><a class="reference internal" href="#interpreter-lifetimes">Interpreter Lifetimes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#directly-sharing-proxy-objects">Directly Sharing Proxy Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces a new <a class="reference internal" href="#concurrent.interpreters.share" title="concurrent.interpreters.share"><code class="xref py py-func docutils literal notranslate"><span class="pre">share()</span></code></a> function to
the <a class="reference external" href="https://docs.python.org/3/library/concurrent.interpreters.html#module-concurrent.interpreters" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.interpreters</span></code></a> module, which allows any arbitrary object
to be shared across interpreters using an object proxy, at the cost of being
less efficient to concurrently access across multiple interpreters.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;spanish_inquisition.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">unshareable</span><span class="p">:</span>
    <span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">unshareable</span><span class="p">)</span>
    <span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
    <span class="n">interp</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="s2">&quot;file.write(&#39;I didn&#39;t expect the Spanish Inquisition&#39;)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="terminology">
<h2><a class="toc-backref" href="#terminology" role="doc-backlink">Terminology</a></h2>
<p>This PEP uses the term “share”, “sharing”, and “shareable” to refer to objects
that are <em>natively</em> shareable between interpreters. This differs from <a class="pep reference internal" href="../pep-0734/" title="PEP 734 – Multiple Interpreters in the Stdlib">PEP 734</a>,
which uses these terms to also describe an object that supports the <a class="reference external" href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>
module.</p>
<p>In addition to the new <a class="reference internal" href="#concurrent.interpreters.SharedObjectProxy" title="concurrent.interpreters.SharedObjectProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code></a> type,
the list of natively shareable objects can be found in <a class="reference external" href="https://docs.python.org/3/library/concurrent.interpreters.html#interp-object-sharing" title="(in Python v3.14)"><span class="xref std std-ref">the documentation</span></a>.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<section id="many-objects-cannot-be-shared-between-subinterpreters">
<h3><a class="toc-backref" href="#many-objects-cannot-be-shared-between-subinterpreters" role="doc-backlink">Many Objects Cannot be Shared Between Subinterpreters</a></h3>
<p>In Python 3.14, the new <a class="reference external" href="https://docs.python.org/3/library/concurrent.interpreters.html#module-concurrent.interpreters" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.interpreters</span></code></a> module can be used to
create multiple interpreters in a single Python process. This works well for
code without shared state, but since one of the primary applications of
subinterpreters is to bypass the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" title="(in Python v3.14)"><span class="xref std std-term">global interpreter lock</span></a>, it is
fairly common for programs to require highly-complex data structures that are
not easily shareable. In turn, this damages the practicality of
subinterpreters for concurrency.</p>
<p>As of writing, subinterpreters can only share <a class="reference external" href="https://docs.python.org/3/library/concurrent.interpreters.html#interp-object-sharing" title="(in Python v3.14)"><span class="xref std std-ref">a handful of types</span></a> natively, relying on the <a class="reference external" href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> module
for other types. This can be very limited, as many types of objects cannot be
serialized with <code class="docutils literal notranslate"><span class="pre">pickle</span></code> (such as file objects returned by <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.14)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>).
Additionally, serialization can be a very expensive operation, which is not
ideal for multithreaded applications.</p>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<section id="a-fallback-for-object-sharing">
<h3><a class="toc-backref" href="#a-fallback-for-object-sharing" role="doc-backlink">A Fallback for Object Sharing</a></h3>
<p>A shared object proxy is designed to be a fallback for sharing an object
between interpreters. A shared object proxy should only be used as
a last-resort for highly complex objects that cannot be serialized or shared
in any other way.</p>
<p>This means that even if this PEP is accepted, there is still benefit in
implementing other methods to share objects between interpreters.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="concurrent.interpreters.share">
<span class="sig-prename descclassname"><span class="pre">concurrent.interpreters.</span></span><span class="sig-name descname"><span class="pre">share</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd>Ensure <em>obj</em> is natively shareable.<p>If <em>obj</em> is natively shareable, this function does not create a proxy and
simply returns <em>obj</em>. Otherwise, <em>obj</em> is wrapped in an instance of
<a class="reference internal" href="#concurrent.interpreters.SharedObjectProxy" title="concurrent.interpreters.SharedObjectProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code></a> and returned.</p>
<p>If <em>obj</em> has a <a class="reference internal" href="#object.__share__" title="object.__share__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__share__()</span></code></a> method, the default behavior of
this function is overridden; the object’s <code class="docutils literal notranslate"><span class="pre">__share__</span></code> method will be
called to convert <em>obj</em> into a natively shareable version of itself, which
will be returned by this function. If the object returned by <code class="docutils literal notranslate"><span class="pre">__share__</span></code>
is not natively shareable, this function raises an exception.</p>
<p>The behavior of this function is roughly equivalent to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">share</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_is_natively_shareable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__share__&quot;</span><span class="p">):</span>
        <span class="n">shareable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__share__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_natively_shareable</span><span class="p">(</span><span class="n">shareable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__share__() returned unshareable object: </span><span class="si">{</span><span class="n">shareable</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shareable</span>

    <span class="k">return</span> <span class="n">SharedObjectProxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="concurrent.interpreters.SharedObjectProxy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">concurrent.interpreters.</span></span><span class="sig-name descname"><span class="pre">SharedObjectProxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd>A proxy type that allows access to an object across multiple interpreters.
Instances of this object are natively shareable between subinterpreters.<p>Unlike <a class="reference internal" href="#concurrent.interpreters.share" title="concurrent.interpreters.share"><code class="xref py py-func docutils literal notranslate"><span class="pre">share()</span></code></a>, <em>obj</em> will always be wrapped,
even if it is natively shareable already or already a <code class="docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code>
instance. The object’s <a class="reference internal" href="#object.__share__" title="object.__share__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__share__()</span></code></a> method is not invoked if
it is available. Thus, prefer using <code class="docutils literal notranslate"><span class="pre">share</span></code> where possible.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="object.__share__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__share__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd>Return a natively shareable version of the current object. This includes
shared object proxies, as they are also natively shareable. Objects composed
of shared object proxies are also allowed, such as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> whose
elements are <a class="reference internal" href="#concurrent.interpreters.SharedObjectProxy" title="concurrent.interpreters.SharedObjectProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code></a> instances.</dd></dl>

<section id="interpreter-switching">
<h3><a class="toc-backref" href="#interpreter-switching" role="doc-backlink">Interpreter Switching</a></h3>
<p>When interacting with the wrapped object, the proxy will switch to the
interpreter in which the object was created. This must happen for any access
to the object, such as accessing attributes. To visualize, <code class="docutils literal notranslate"><span class="pre">foo</span></code> in the
following code is only ever called in the main interpreter, despite being
accessed in subinterpreters through a proxy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span> <span class="o">==</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">get_main</span><span class="p">()</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
<span class="n">interp</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="s2">&quot;foo()&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="method-proxying">
<h3><a class="toc-backref" href="#method-proxying" role="doc-backlink">Method Proxying</a></h3>
<p>Methods on a shared object proxy will switch to their owning interpreter when
accessed. In addition, any arguments passed to the method are implicitly called
with <a class="reference internal" href="#concurrent.interpreters.share" title="concurrent.interpreters.share"><code class="xref py py-func docutils literal notranslate"><span class="pre">share()</span></code></a> to ensure they are shareable (only
types that are not natively shareable are wrapped in a proxy). The same happens
to the return value of the method.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">__add__</span></code> method on an object proxy is roughly equivalent
to the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">switch_interpreter</span><span class="p">():</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">share</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">share</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="multithreaded-scaling">
<h3><a class="toc-backref" href="#multithreaded-scaling" role="doc-backlink">Multithreaded Scaling</a></h3>
<p>To switch to a wrapped object’s interpreter, an object proxy must swap the
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> of the current thread, which will in turn wait
on the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-GIL" title="(in Python v3.14)"><span class="xref std std-term">GIL</span></a> of the target interpreter, if it is enabled. This means that
a shared object proxy will experience contention when accessed concurrently,
but is still useful for multicore threading, since other threads in the
interpreter are free to execute while waiting on the GIL of the target
interpreter.</p>
<p>As an example, imagine that multiple interpreters want to write to a log through
a proxy for the main interpreter, but don’t want to constantly wait on the log.
By accessing the proxy in a separate thread for each interpreter, the thread
performing the computation can still execute while accessing the proxy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="k">def</span><span class="w"> </span><span class="nf">write_log</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">write_log</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">Queue</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># By performing this in a separate thread, &#39;execute&#39; can still run</span>
    <span class="c1"># while the log is being accessed by the main interpreter.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_queue_loop</span><span class="p">():</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">write_log</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">log_queue_loop</span><span class="p">)</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">**</span> <span class="n">i</span>
        <span class="n">log</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Completed an iteration: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">write_log</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="n">interp</span><span class="o">.</span><span class="n">call_in_thread</span><span class="p">(</span><span class="n">execute</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="proxy-copying">
<h3><a class="toc-backref" href="#proxy-copying" role="doc-backlink">Proxy Copying</a></h3>
<p>Contrary to what one might think, a shared object proxy itself can only be used
in one interpreter, because the proxy’s reference count is not thread-safe
(and thus cannot be accessed from multiple interpreters). Instead, when crossing
an interpreter boundary, a new proxy is created for the target interpreter that
wraps the same object as the original proxy.</p>
<p>For example, in the following code, there are two proxies created, not just one.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">foo</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="c1"># The proxy crosses an interpreter boundary here. &#39;proxy&#39; is *not* directly</span>
<span class="c1"># send to &#39;interp&#39;. Instead, a new proxy is created for &#39;interp&#39;, and the</span>
<span class="c1"># reference to &#39;foo&#39; is merely copied. Thus, both interpreters have their</span>
<span class="c1"># own proxy that are wrapping the same object.</span>
<span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">proxy</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="thread-local-state">
<h3><a class="toc-backref" href="#thread-local-state" role="doc-backlink">Thread-local State</a></h3>
<p>Accessing an object proxy will retain information stored on the current
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread state</span></a>, such as thread-local variables stored by
<a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.local" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> and context variables stored by <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.
This allows the following case to work correctly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">local</span>

<span class="n">thread_local</span> <span class="o">=</span> <span class="n">local</span><span class="p">()</span>
<span class="n">thread_local</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">thread_local</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
<span class="n">interp</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="s2">&quot;foo()&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to retain thread-local data when accessing an object proxy, each
thread will have to keep track of the last used thread state for
each interpreter. In C, this behavior looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error checking has been omitted for brevity</span>
<span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">tstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_New</span><span class="p">(</span><span class="n">interp</span><span class="p">);</span>

<span class="c1">// By swapping the current thread state to &#39;interp&#39;, &#39;tstate&#39; will be</span>
<span class="c1">// associated with &#39;interp&#39; for the current thread. That means that accessing</span>
<span class="c1">// a shared object proxy will use &#39;tstate&#39; instead of creating its own</span>
<span class="c1">// thread state.</span>
<span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>

<span class="c1">// &#39;save&#39; is now the most recently used thread state, so shared object</span>
<span class="c1">// proxies in this thread will use it instead of &#39;tstate&#39; when accessing</span>
<span class="c1">// &#39;interp&#39;.</span>
<span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="n">save</span><span class="p">);</span>
</pre></div>
</div>
<p>In the event that no thread state exists for an interpreter in a given thread,
a shared object proxy will create its own thread state that will be owned by
the interpreter (meaning it will not be destroyed until interpreter
finalization), which will persist across all shared object proxy accesses in
the thread. In other words, a shared object proxy ensures that thread local
variables and similar state will not disappear.</p>
</section>
<section id="memory-management">
<h3><a class="toc-backref" href="#memory-management" role="doc-backlink">Memory Management</a></h3>
<p>All proxy objects hold a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-strong-reference" title="(in Python v3.14)"><span class="xref std std-term">strong reference</span></a> to the object that they
wrap. As such, destruction of a shared object proxy may trigger destruction
of the wrapped object if the proxy holds the last reference to it, even if
the proxy belongs to a different interpreter. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">foo</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">proxy</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
<span class="k">del</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">foo</span>

<span class="c1"># &#39;foo&#39; is still alive at this point, because the proxy in &#39;interp&#39; still</span>
<span class="c1"># holds a reference to it. Destruction of &#39;interp&#39; will then trigger the</span>
<span class="c1"># destruction of &#39;proxy&#39;, and subsequently the destruction of &#39;foo&#39;.</span>
<span class="n">interp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Shared object proxies support the garbage collector protocol, but will only
traverse the object that they wrap if the garbage collection is occurring
in the wrapped object’s interpreter. To visualize:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="nb">object</span><span class="p">())</span>

<span class="c1"># This prints out [&lt;object object at 0x...&gt;], because the object is owned</span>
<span class="c1"># by this interpreter.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="n">proxy</span><span class="p">))</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">interp</span><span class="o">.</span><span class="n">prepare_main</span><span class="p">(</span><span class="n">proxy</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>

<span class="c1"># This prints out [], because the wrapepd object must be invisible to this</span>
<span class="c1"># interpreter.</span>
<span class="n">interp</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="s2">&quot;import gc; print(gc.get_referents(proxy))&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="interpreter-lifetimes">
<h4><a class="toc-backref" href="#interpreter-lifetimes" role="doc-backlink">Interpreter Lifetimes</a></h4>
<p>When an interpreter is destroyed, shared object proxies wrapping objects
owned by that interpreter may still exist elsewhere. To prevent this
from causing crashes, an interpreter will invalidate all proxies pointing
to any object it owns by overwriting the proxy’s wrapped object with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>To demonstrate, the following snippet first prints out <code class="docutils literal notranslate"><span class="pre">Alive</span></code>, and then
<code class="docutils literal notranslate"><span class="pre">None</span></code> after deleting the interpreter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test</span><span class="p">():</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpreters</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Test</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Alive&quot;</span>

    <span class="k">return</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">share</span><span class="p">(</span><span class="n">Test</span><span class="p">())</span>

<span class="n">interp</span> <span class="o">=</span> <span class="n">interpreters</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">wrapped</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span>  <span class="c1"># Alive</span>
<span class="n">interp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span>  <span class="c1"># None</span>
</pre></div>
</div>
<p>Note that the proxy is not physically replaced (<code class="docutils literal notranslate"><span class="pre">wrapped</span></code> in the above example
is still a <code class="docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code> instance), but instead has its wrapped object
replaced with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</section>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>This PEP has no known backwards compatibility issues.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>This PEP has no known security implications.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>New APIs and important information about how to use them will be added to the
<a class="reference external" href="https://docs.python.org/3/library/concurrent.interpreters.html#module-concurrent.interpreters" title="(in Python v3.14)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.interpreters</span></code></a> documentation.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The reference implementation of this PEP can be found
<a class="reference external" href="https://github.com/python/cpython/compare/main...ZeroIntensity:cpython:shared-object-proxy">here</a>.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="directly-sharing-proxy-objects">
<h3><a class="toc-backref" href="#directly-sharing-proxy-objects" role="doc-backlink">Directly Sharing Proxy Objects</a></h3>
<p>The initial revision of this proposal took an approach where an instance of
<a class="reference internal" href="#concurrent.interpreters.SharedObjectProxy" title="concurrent.interpreters.SharedObjectProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedObjectProxy</span></code></a> was <a class="reference external" href="https://docs.python.org/3/glossary.html#term-immortal" title="(in Python v3.14)"><span class="xref std std-term">immortal</span></a>. This
allowed proxy objects to be directly shared across interpreters, because their
reference count was thread-safe (since it never changed due to immortality).</p>
<p>This proved to make the implementation significantly more complicated, and
also ended up with a lot of edge cases that would have been a burden on
CPython maintainers.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>This PEP would not have been possible without discussion and feedback from
Eric Snow, Petr Viktorin, Kirill Podoprigora, Adam Turner, and Yury Selivanov.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0797.rst">https://github.com/python/peps/blob/main/peps/pep-0797.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0797.rst">2026-01-20 15:51:18 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#many-objects-cannot-be-shared-between-subinterpreters">Many Objects Cannot be Shared Between Subinterpreters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#a-fallback-for-object-sharing">A Fallback for Object Sharing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#concurrent.interpreters.share"><code class="docutils literal notranslate"><span class="pre">concurrent.interpreters.share()</span></code></a></li>
<li><a class="reference internal" href="#concurrent.interpreters.SharedObjectProxy"><code class="docutils literal notranslate"><span class="pre">concurrent.interpreters.SharedObjectProxy</span></code></a></li>
<li><a class="reference internal" href="#object.__share__"><code class="docutils literal notranslate"><span class="pre">object.__share__()</span></code></a></li>
<li><a class="reference internal" href="#interpreter-switching">Interpreter Switching</a></li>
<li><a class="reference internal" href="#method-proxying">Method Proxying</a></li>
<li><a class="reference internal" href="#multithreaded-scaling">Multithreaded Scaling</a></li>
<li><a class="reference internal" href="#proxy-copying">Proxy Copying</a></li>
<li><a class="reference internal" href="#thread-local-state">Thread-local State</a></li>
<li><a class="reference internal" href="#memory-management">Memory Management</a><ul>
<li><a class="reference internal" href="#interpreter-lifetimes">Interpreter Lifetimes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#directly-sharing-proxy-objects">Directly Sharing Proxy Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0797.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>