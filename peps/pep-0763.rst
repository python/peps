PEP: 763
Title: Classes & protocols: Read-only attributes
Author: <REQUIRED: list of authors' real names and optionally, email addrs>
Sponsor: Carl Meyer <carl@oddbird.net>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Created: 11-Oct-2024
Python-Version: 3.?


Abstract
========

:pep:`705` introduced the :external+py3.13:data:`typing.ReadOnly` type qualifier
to allow defining read-only :class:`typing.TypedDict` items.

This PEP proposes expanding the scope of ``ReadOnly`` to class and protocol
attributes, as a single concise way to mark them read-only. Some parity changes
are also made to :class:`typing.Final`.

Akin to :pep:`705`, it makes no Python grammar changes. Correct usage of
read-only attributes is intended to be enforced only by static type checkers.


Motivation
==========

Python type system lacks a single concise way to mark an attribute read-only.
This feature is common in other object-oriented languages (such as `C# <https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly>`_),
and is useful for restricting attribute mutation at a type checker level, as well
as defining a broad interface for structural subtyping.

.. _classes:

Classes
-------

There are 3 major ways of achieving read-only attributes, honored by type checkers:

* annotating the attribute with :data:`typing.Final`::

    class Foo:
        number: Final[int]

        def __init__(self, number: int) -> None:
            self.number = number


    class Bar:
        def __init__(self, number: int) -> None:
            self.number: Final = number

  - Supported by :mod:`dataclasses` (since `typing#1669 <https://github.com/python/typing/pull/1669>`_).
  - Overriding ``number`` is not possible - the specification of ``Final``
    imposes the name cannot be overridden in subclasses.

* read-only proxy via ``@property``::

    class Foo:
        _number: int

        def __init__(self, number: int) -> None:
            self._number = number

        @property
        def number(self) -> int:
            return self._number

  - Overriding ``number`` is possible. *Type checkers disagree about the specific rules*. [#overriding_property]_
  - Read-only at runtime. [#runtime]_
  - Requires extra boilerplate.
  - Supported by :mod:`dataclasses`, but does not compose well - the synthesized
    ``__init__`` and ``__repr__`` will use ``_number`` as the parameter/attribute name.

* using a "freezing" mechanism, such as :func:`dataclasses.dataclass` or :class:`typing.NamedTuple`::

    @dataclass(frozen=True)
    class Foo:
        number: int


    class Bar(NamedTuple):
        number: int

  - Overriding ``number`` is possible in the ``@dataclass`` case.
  - Read-only at runtime. [#runtime]_
  - No per-attribute control - these mechanisms apply to the whole class.
  - Frozen dataclasses incur some runtime overhead.
  - ``NamedTuple`` is still a ``tuple``. Most classes do not need to inherit
    indexing, iteration, or concatenation.

.. _protocols:

Protocols
---------

Paraphrasing `this post <https://github.com/python/typing/discussions/1525>`_,
there is no way of defining a :class:`~typing.Protocol`, such that the only
requirements to satisfy are:

1. ``hasattr(obj, name)``
2. ``isinstance(obj.name, T)`` [#invalid_typevar]_

The above are satisfiable at runtime by all of the following:

1. an object with an attribute ``name: T``,
2. a class with a class variable ``name: ClassVar[T]``, [#invalid_typevar]_
3. an instance of the class above,
4. an object with a ``@property`` ``def name(self) -> T``,
5. an object with a custom descriptor, such as :func:`functools.cached_property`.

Note that the attribute being marked ``Final`` or the property defining a setter
do not impact this.

The most common practice is to define such a protocol with a ``@property``::

    class HasName[T](Protocol):
        @property
        def name(self) -> T: ...

Type checkers special-case this definition, such that objects with plain attributes
are assignable to the type. However, instances with class variables and descriptors
other than ``property`` are rejected.

Covering the extra possibilities induces a great amount of boilerplate, involving
creation of an abstract descriptor protocol, possibly also accounting for
class and instance level overloads.
Worse yet, all of that is multiplied for each additional read-only attribute.


Rationale
=========

These problems can be resolved by an attribute-level type qualifier. ``ReadOnly``
has been chosen for this role, as its name conveys the intent well, and the newly
proposed changes complement its semantics defined in :pep:`705`.

A class with a read-only instance attribute can be now defined as such::

    from typing import ReadOnly


    class Member:
        id: ReadOnly[int]

        def __init__(self, id: int) -> None:
            self.id = id

...and a protocol as described in :ref:`protocols` is now just::

    from typing import Protocol, ReadOnly


    class HasName(Protocol):
        name: ReadOnly[str]


    def greet(obj: HasName, /) -> str:
        return f"Hello, {obj.name}!"

* A subclass of ``Member`` can redefine ``id`` as a ``property`` or writable
  attribute, while staying compatible with the base class.
* The ``HasName`` protocol can be implemented by any mechanism allowing for ``.name`` access.
* The ``greet`` function can now accept a wide variety of compatible objects,
  while being explicit about no modifications being done to the input.


Specification
=============

The :external+py3.13:data:`typing.ReadOnly` type qualifier becomes a valid annotation
for attributes of classes and protocols.

It remains invalid in annotations of global and local variables, as in those contexts
it would have the same meaning as using ``Final``.

Syntax
------

``ReadOnly`` can be used at class-level or within ``__init__`` to declare
an attribute read-only:

.. code-block:: python

    class Base:
        id: ReadOnly[int]

        def __init__(self, id: int, rate: float) -> None:
            self.id = id
            self.rate: ReadOnly = rate

The explicit type in ``ReadOnly[<type>]`` can be omitted if an initializing value
is assigned to the attribute. A type checker should apply its usual type inference
rules to determine the type of ``rate``.

In contexts where an attribute is already implied to be read-only, like in the
frozen :ref:`classes`, it should be valid to explicitly declare it ``ReadOnly``:

.. code-block:: python

    @dataclass(frozen=True)
    class Point:
        x: ReadOnly[int]
        y: ReadOnly[int]

Initialization
--------------

Assignment to a ``ReadOnly`` attribute can only occur as a part of the declaration,
or within ``__init__`` of the same class. There is no restriction to how many
times the attribute can be assigned to in those contexts. Example:

.. code-block:: python

    from collections import abc
    from typing import ReadOnly


    class Band:
        name: str
        songs: ReadOnly[list[str]]

        def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -> None:
            self.name = name
            self.songs = []

            if songs is not None:
                # multiple assignments during initialization are fine
                self.songs = list(songs)

        def clear(self) -> None:
            # error: assignment to read-only "songs" outside initialization
            self.songs = []


    band = Band(name="Boa", songs=["Duvet"])
    band.name = "Emma"  # ok: "name" is not read-only
    band.songs = []  # error: "songs" is read-only
    band.songs.append("Twilight")  # ok: list is mutable

Classes which do not define `__slots__ <https://docs.python.org/3/reference/datamodel.html#object.__slots__>`_
retain the ability to initialize a read-only attribute both at declaration and
within ``__init__``:

.. code-block:: python

    class Foo:
        number: ReadOnly[int] = 0

        def __init__(self, number: int | None = None) -> None:
            if number is not None:
                self.number = number

Type checkers should warn on attributes declared ``ReadOnly`` which may be left
uninitialized after ``__init__`` exits, unless the class is a protocol or an ABC::

    class Foo:
        id: ReadOnly[int]    # error: "id" is not initialized on all code paths
        name: ReadOnly[str]  # error: "name" is never initialized

        def __init__(self) -> None:
            if random.random() > 0.5:
                self.id = 123

This rule stems from the fact the body of the class declaring the attribute is
the only place able to initialize it, in contrast to non-read-only attributes,
which could be initialized outside of the class body.

Subtyping
---------

Read-only attributes are covariant. This has a few subtyping implications.
Borrowing from :pep:`PEP 705 <705#inheritance>`:

* Read-only attributes can be redeclared as writable attributes, descriptors
  and class variables::

    @dataclass
    class HasTitle:
        title: ReadOnly[str]


    @dataclass
    class Game(HasTitle):
        title: str
        year: int


    game = Game(title="DOOM", year=1993)
    game.year = 1994
    game.title = "DOOM II"  # ok: attribute is not read-only


    class TitleProxy(HasTitle):
        @functools.cached_property
        def title(self) -> str: ...


    class SharedTitle(HasTitle):
        title: ClassVar[str] = "Still Grey"

* If a read-only attribute is not redeclared, it remains read-only::

    @dataclass
    class Game(HasTitle):
        year: int


    game = Game(title="DOOM", year=1993)
    game.title = "DOOM II"  # error: attribute is read-only

* Subtypes can narrow the type of read-only attributes::

    class GameCollection(Protocol):
        games: ReadOnly[abc.Collection[Game]]


    @dataclass
    class GameSeries(GameCollection):
        name: str
        games: ReadOnly[list[Game]]  # ok: list[Game] is assignable to Collection[Game]

* In nominal subclasses of protocols and ABCs, a read-only attribute should be
  considered abstract, unless it is initialized::

    class MyBase(abc.ABC):
        foo: ReadOnly[int]
        bar: ReadOnly[str] = "abc"
        baz: ReadOnly[float]

        def __init__(self, baz: float) -> None:
            self.baz = baz

        @abstractmethod
        def do_something(self) -> None: ...


    @final
    class MySubclass(MyBase):
        # error: MySubclass does not override "foo"

        def do_something(self) -> None:
            print(self.foo, self.bar, self.baz)

* In a protocol attribute declaration, ``name: ReadOnly[T]`` indicates that a structural
  subtype must support ``.name`` access, and the returned value is compatible with ``T``::

    class HasName(Protocol):
        name: ReadOnly[str]


    class NamedAttr:
        name: str

    class NamedProp:
        @property
        def name(self) -> str: ...

    class NamedClassVar:
        name: ClassVar[str]

    class NamedDescriptor:
        @cached_property
        def name(self) -> str: ...

    # all of the following are ok
    has_name: HasName
    has_name = NamedAttr()
    has_name = NamedProp()
    has_name = NamedClassVar
    has_name = NamedClassVar()
    has_name = NamedDescriptor()


Changes to ``Final``
--------------------

.. TODO
    - deletability
    - final in protocols?
    - interaction of Final and ReadOnly - once parity changes are done, the
      following shouldn't be true:
      ``ReadOnly`` cannot be combined with ``Final``, as the two qualifiers differ in
      initialization rules, leading to ambiguity and/or significance of ordering.
    - section on "Type consistency"?

Interaction with other special types
------------------------------------

``ReadOnly`` can be used with ``ClassVar`` and ``Annotated`` in any nesting order:

.. code-block:: python

    class Foo:
        foo: ClassVar[ReadOnly[str]] = "foo"
        bar: Annotated[ReadOnly[int], Gt(0)]

.. code-block:: python

    class Foo:
        foo: ReadOnly[ClassVar[str]] = "foo"
        bar: ReadOnly[Annotated[int, Gt(0)]]

This is consistent with the interaction of ``ReadOnly`` and :class:`typing.TypedDict`
defined in :pep:`705`.

``ClassVar`` excludes read-only attributes from being assignable to within
initialization methods.


Backwards Compatibility
=======================

This PEP introduces new contexts where ``ReadOnly`` is valid. Programs inspecting
those places will have to change to support it. This is expected to mainly affect type checkers.

However, caution is advised while using the backported ``typing_extensions.ReadOnly``
in older versions of Python. Mechanisms inspecting annotations may behave incorrectly
when encountering ``ReadOnly``; in particular, the ``@dataclass`` decorator
which `looks for <https://docs.python.org/3/library/dataclasses.html#class-variables>`_
``ClassVar`` will incorrectly treat ``ReadOnly[ClassVar[...]]`` as an instance attribute.


Security Implications
=====================

There are no known security consequences arising from this PEP.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Rejected ideas
==============

Assignment in ``__post_init__``
-------------------------------

An earlier version of this PEP specified that assignment to read-only attributes
may also be permitted within methods augmenting initialization, such as
dataclasses' `__post_init__ <https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__>`_
or attrs' `initialization hooks <https://www.attrs.org/en/stable/init.html#hooking-yourself-into-initialization>`_.
This has been set aside for now, as defining rules regarding inclusion of
such methods has proven difficult.


Footnotes
=========

.. [#overriding_property]
    Pyright in strict mode disallows non-property overrides.
    Mypy does not impose this restriction and allows an override with a plain attribute.
    `[Pyright playground] <https://pyright-play.net/?strict=true&code=MYGwhgzhAEBiD28BcBYAUNT0D6A7ArgLYBGApgE5LQCWuALuultACakBmO2t1d22ACgikQ7ADTQCJClVp0AlNAC0APmgA5eLlKoMzLMNEA6PETLloAXklmKjPZgACAB3LxnFOgE8mWNpylzIRF2RVUael19LHJSOnxyXGhDdhNAuzR7UEgYACEwcgEEeHkorHTKCIY0IA>`_
    `[mypy playground] <https://mypy-play.net/?mypy=latest&python=3.12&flags=strict&gist=6f860a865c5d13cce07d6cbb08b9fb85>`_

.. [#runtime]
    This PEP focuses solely on the type-checking behavior. Nevertheless, it should
    be desirable the name is read-only at runtime.

.. [#invalid_typevar]
    The implied type variable is not valid in this context. It has been used here
    for ease of demonstration.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
