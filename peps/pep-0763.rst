PEP: 763
Title: Classes & protocols: Read-only attributes
Author: <REQUIRED: list of authors' real names and optionally, email addrs>
Sponsor: <real name of sponsor>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Created: 11-Oct-2024
Python-Version: 3.?


Abstract
========

:pep:`705` introduced the :external+py3.13:data:`typing.ReadOnly` type qualifier
to allow defining read-only :class:`typing.TypedDict` items.

This PEP proposes expanding the scope of ``ReadOnly`` to class and protocol
attributes, as a single concise way to mark them read-only.
Akin to :pep:`705`, it makes no Python grammar changes. Correct usage of
read-only attributes is intended to be enforced only by static type checkers.


Motivation
==========

Python type system lacks a single concise way to mark an attribute read-only.
This feature is common in other object-oriented languages (such as C#), and is
useful for restricting attribute mutation at a typechecker level, as well as defining
a very wide interface for structural subtyping.

Classes
-------

There are 3 major ways of achieving read-only attributes, honored by typecheckers:

* annotating the attribute with :class:`~typing.Final`::

      class Foo:
          number: Final[int]

          def __init__(self, number: int) -> None:
              self.number = number

  - Supported by :mod:`dataclasses` [#final_in_dataclasses]_.
  - Overriding ``number`` is not possible - the specification of ``Final``
    imposes the name cannot be overridden in subclasses.

* read-only proxy via ``@property``::

      class Foo:
          _number: int

          def __init__(self, number: int) -> None:
              self._number = number

          @property
          def number(self) -> int:
              return self._number

  - Prevents runtime mutation.
  - Overriding ``number`` is possible. `Pyright rejects <pyright_playground_>`_ non-``@property`` overrides.
  - Requires extra boilerplate.
  - Supported by :mod:`dataclasses`, but does not compose well - the synthesized ``__init__`` and ``__repr__`` will use ``_number`` as the parameter/attribute name.

* using a "freezing" mechanism, such as :func:`~dataclasses.dataclass` or :class:`~typing.NamedTuple`::

      @dataclass(frozen=True)
      class Foo:
          number: int


      class Bar(NamedTuple):
          number: int

  - Overriding ``number`` is possible in the ``@dataclass`` case.
  - Prevents runtime mutation.
  - No per-attribute control - these methods apply to the whole class.
  - Frozen dataclasses incur some runtime overhead.

Protocols
---------

There is no way of defining a :class:`~typing.Protocol`, such that the only requirements to satisfy are:

1. ``hasattr(obj, name)``
2. ``isinstance(obj.name, T)``

The above are satisfiable at runtime by all of the following, regardless of whether the names support mutation:

1. an object with an attribute ``name: T``,
2. a class with a class variable ``name: ClassVar[T]``,
3. an instance of the class above,
4. an object with a ``@property`` ``def name(self) -> T``,
5. an object with a ``__get__`` descriptor, such as :func:`functools.cached_property`.

The most common practice is to define such a protocol with a ``@property``::

    class HasName[T](Protocol):
        @property
        def name(self) -> T: ...

Typecheckers special-case this definition, such that objects with plain attributes
are assignable to the type. However, instances with class variables and descriptors other than ``property`` are rejected.

Covering the extra possibilities involves writing a great amount of repetitive boilerplate,
which gets multiplied for each additional attribute.


Rationale
=========

[Describe why particular design decisions were made.]


Specification
=============

[Describe the syntax and semantics of any new language feature.]


Backwards Compatibility
=======================

This PEP introduces new contexts where ``ReadOnly`` is valid. Programs that inspect those places will have to change to support it.
This is expected to mainly affect type checkers.


Security Implications
=====================

There are no known security consequences arising from this PEP.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


Footnotes
=========

.. [#final_in_dataclasses] Final and dataclass interaction has been clarified in https://github.com/python/typing/pull/1669

.. _pyright_playground: https://pyright-play.net/?strict=true&code=MYGwhgzhAEBiD28BcBYAUNT0D6A7ArgLYBGApgE5LQCWuALuultACakBmO2t1d22ACgikQ7ADTQCJClVp0AlNAC0APmgA5eLlKoMzLMNEA6PETLloAXklmKjPZgACAB3LxnFOgE8mWNpylzIRF2RVUael19LHJSOnxyXGhDdhNAuzR7UEgYACEwcgEEeHkorHTKCIY0IA


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
