PEP: 763
Title: Classes & protocols: Read-only attributes
Author: <REQUIRED: list of authors' real names and optionally, email addrs>
Sponsor: <real name of sponsor>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Created: 11-Oct-2024
Python-Version: 3.?


Abstract
========

:pep:`705` introduced the :external+py3.13:data:`typing.ReadOnly` type qualifier
to allow defining read-only :class:`typing.TypedDict` items.

This PEP proposes expanding the scope of ``ReadOnly`` to class and protocol
attributes, as a single concise way to mark them read-only.
Akin to :pep:`705`, it makes no Python grammar changes. Correct usage of
read-only attributes is intended to be enforced only by static type checkers.


Motivation
==========

Python type system lacks a single concise way to mark an attribute read-only.
This feature is common in other object-oriented languages (such as `C# <https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly>`_),
and is useful for restricting attribute mutation at a type checker level, as well
as defining a broad interface for structural subtyping.

Classes
-------

There are 3 major ways of achieving read-only attributes, honored by type checkers:

* annotating the attribute with :data:`typing.Final`::

    class Foo:
        number: Final[int]

        def __init__(self, number: int) -> None:
            self.number = number


    class Bar:
        def __init__(self, number: int) -> None:
            self.number: Final = number

  - Supported by :mod:`dataclasses` (since `typing#1669 <https://github.com/python/typing/pull/1669>`_).
  - Overriding ``number`` is not possible - the specification of ``Final``
    imposes the name cannot be overridden in subclasses.

* read-only proxy via ``@property``::

    class Foo:
        _number: int

        def __init__(self, number: int) -> None:
            self._number = number

        @property
        def number(self) -> int:
            return self._number

  - Overriding ``number`` is possible. *Type checkers disagree about the specific rules*. [#overriding_property]_
  - Read-only at runtime. [#runtime]_
  - Requires extra boilerplate.
  - Supported by :mod:`dataclasses`, but does not compose well - the synthesized
    ``__init__`` and ``__repr__`` will use ``_number`` as the parameter/attribute name.

* using a "freezing" mechanism, such as :func:`dataclasses.dataclass` or :class:`typing.NamedTuple`::

    @dataclass(frozen=True)
    class Foo:
        number: int


    class Bar(NamedTuple):
        number: int

  - Overriding ``number`` is possible in the ``@dataclass`` case.
  - Read-only at runtime. [#runtime]_
  - No per-attribute control - these methods apply to the whole class.
  - Frozen dataclasses incur some runtime overhead.
  - Not all classes qualify to be a ``NamedTuple``.

.. _protocols:

Protocols
---------

Paraphrasing `this post <https://github.com/python/typing/discussions/1525>`_,
there is no way of defining a :class:`~typing.Protocol`, such that the only requirements to satisfy are:

1. ``hasattr(obj, name)``
2. ``isinstance(obj.name, T)`` [#invalid_typevar]_ 

The above are satisfiable at runtime by all of the following:

1. an object with an attribute ``name: T``,
2. a class with a class variable ``name: ClassVar[T]``, [#invalid_typevar]_
3. an instance of the class above,
4. an object with a ``@property`` ``def name(self) -> T``,
5. an object with a custom descriptor, such as :func:`functools.cached_property`.

The most common practice is to define such a protocol with a ``@property``::

    class HasName[T](Protocol):
        @property
        def name(self) -> T: ...

Type checkers special-case this definition, such that objects with plain attributes
are assignable to the type. However, instances with class variables and descriptors
other than ``property`` are rejected.

Covering the extra possibilities induces a great amount of boilerplate, involving
creation of an abstract descriptor protocol, possibly also accounting for
class vs instance level overloads.
Worse yet, all of that is multiplied for each additional read-only attribute.


Rationale
=========

This problem can be resolved by an attribute-level type qualifier. ``ReadOnly``
has been chosen for this role, as its name conveys the intent well, and the newly
proposed changes complement its semantics defined in :pep:`705`.

A class with a read-only instance attribute can be now defined as such::

    from typing import ReadOnly

    class Member:
        id: ReadOnly[int]

        def __init__(self, id: int) -> None:
            self.id = id

...and a protocol as described in :ref:`protocols` is now just::

    from typing import Protocol, ReadOnly

    class HasName(Protocol):
        name: ReadOnly[str]

    def greet(obj: HasName, /) -> str:
        return f"Hello, {obj.name}!"

A subclass of ``Member`` can redefine ``id`` as a ``property`` or writable
attribute, while staying compatible with the base class.

The ``HasName`` protocol can be implemented by any mechanism allowing for ``.name`` access.

The ``greet`` function can now accept a wide variety of compatible objects,
while being explicit about no modifications being done to the input.


Specification
=============

The :external+py3.13:data:`typing.ReadOnly` type qualifier becomes a valid annotation
for attributes of classes and protocols.

Classes
-------

In a class attribute declaration, ``ReadOnly`` indicates that assignment to the
attribute can only occur as a part of the declaration, or within a set of
initializing methods in the same class::

    from collections import abc
    from typing import ReadOnly


    class Band:
        name: str
        songs: ReadOnly[list[str]]

        def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -> None:
            self.name = name
            self.songs = []

            if songs is not None:
                # multiple assignments during initialization are fine
                self.songs = list(songs)

        def clear(self) -> None:
            self.songs = []  # Type check error: "songs" is read only


    band = Band("Boa", ["Duvet"])
    band.name = "Emma"  # Ok: "name" is not read-only
    band.songs = []  # Type check error: "songs" is read-only
    band.songs.append("Twilight")  # Ok: list is mutable

The set of initializing methods consists of ``__new__`` and ``__init__``.
However, type checkers may permit assignment in additional `special methods <https://docs.python.org/3/glossary.html#term-special-method>`_
to facilitate 3rd party mechanisms such as dataclasses' `__post_init__ <https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__>`_.
It should be non-ambiguous that those methods are not called outside initialization.

A read-only attribute with an initializer remains assignable to during initialization::

    class Foo:
        number: ReadOnly[int] = 0

        def __init__(self, number: int | None = None) -> None:
            if number is not None:
               self.number = number

Note that this cannot be used in a class defining ``__slots__``, as slots prohibit
the existence of class-level and instance-level attributes of same name.

Protocols
---------

In a protocol attribute declaration, ``name: ReadOnly[T]`` indicates that a structural
subtype must support ``.name`` access, and the returned value is compatible with ``T``.

Interaction with other special types
------------------------------------

``ReadOnly`` can be used with ``ClassVar`` and ``Annotated`` in any nesting order:

.. code-block:: python

    class Foo:
        foo: ClassVar[ReadOnly[str]] = "foo"
        bar: Annotated[ReadOnly[int], Gt(0)]

.. code-block:: python

    class Foo:
        foo: ReadOnly[ClassVar[str]] = "foo"
        bar: ReadOnly[Annotated[int, Gt(0)]]

This is consistent with the interaction of ``ReadOnly`` and :class:`typing.TypedDict`
defined in :pep:`705`.

The combination of ``ReadOnly`` and ``ClassVar`` imposes the attribute must be
initialized in the class scope, as there are no other valid initialization scopes.

``ReadOnly`` cannot be combined with ``Final``, as the two qualifiers define incompatible
initialization rules, leading to ambiguity and/or significance of ordering.


Backwards Compatibility
=======================

This PEP introduces new contexts where ``ReadOnly`` is valid. Programs inspecting
those places will have to change to support it. This is expected to mainly affect type checkers.

However, caution is advised while using the backported ``typing_extensions.ReadOnly``
in older versions of Python, especially in conjunction with other type qualifiers;
not all nesting orderings might be treated equal. In particular, the ``@dataclass``
decorator which looks for ``ClassVar`` will incorrectly treat
``ReadOnly[ClassVar[...]]`` as an instance attribute.


Security Implications
=====================

There are no known security consequences arising from this PEP.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Footnotes
=========

.. [#overriding_property]
    Pyright in strict mode disallows non-property overrides.
    Mypy does not impose this restriction and allows an override with a plain attribute.
    `[Pyright playground] <https://pyright-play.net/?strict=true&code=MYGwhgzhAEBiD28BcBYAUNT0D6A7ArgLYBGApgE5LQCWuALuultACakBmO2t1d22ACgikQ7ADTQCJClVp0AlNAC0APmgA5eLlKoMzLMNEA6PETLloAXklmKjPZgACAB3LxnFOgE8mWNpylzIRF2RVUael19LHJSOnxyXGhDdhNAuzR7UEgYACEwcgEEeHkorHTKCIY0IA>`_
    `[mypy playground] <https://mypy-play.net/?mypy=latest&python=3.12&flags=strict&gist=6f860a865c5d13cce07d6cbb08b9fb85>`_

.. [#runtime]
    This PEP focuses solely on the type-checking behavior. Nevertheless, it should
    be desirable the name is read-only at runtime.

.. [#invalid_typevar]
    The implied type variable is not valid in this context. It has been used here
    for ease of demonstration.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
