PEP: 763
Title: Classes & protocols: Read-only attributes
Author: <REQUIRED: list of authors' real names and optionally, email addrs>
Sponsor: <real name of sponsor>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Created: 11-Oct-2024
Python-Version: 3.?


Abstract
========

:pep:`705` introduced the :external+py3.13:data:`typing.ReadOnly` type qualifier
to allow defining read-only :class:`typing.TypedDict` items.

This PEP proposes expanding the scope of ``ReadOnly`` to class and protocol
attributes, as a single concise way to mark them read-only.
Akin to :pep:`705`, it makes no Python grammar changes. Correct usage of
read-only attributes is intended to be enforced only by static type checkers.


Motivation
==========

Python type system lacks a single concise way to mark an attribute read-only.
This feature is common in other object-oriented languages (such as C#), and is
useful for restricting attribute mutation at a type checker level, as well as
defining a broad interface for structural subtyping.

Classes
-------

There are 3 major ways of achieving read-only attributes, honored by type checkers:

* annotating the attribute with :data:`typing.Final`::

      class Foo:
          number: Final[int]

          def __init__(self, number: int) -> None:
              self.number = number


      class Bar:
          def __init__(self, number: int) -> None:
              self.number: Final = number

  - Supported by :mod:`dataclasses` (since `typing#1669 <https://github.com/python/typing/pull/1669>`_).
  - Overriding ``number`` is not possible - the specification of ``Final``
    imposes the name cannot be overridden in subclasses.

* read-only proxy via ``@property``::

      class Foo:
          _number: int

          def __init__(self, number: int) -> None:
              self._number = number

          @property
          def number(self) -> int:
              return self._number

  - Overriding ``number`` is possible. *Type checkers disagree about the specific rules*. [#overriding_property]_
  - Read-only at runtime. [#runtime]_
  - Requires extra boilerplate.
  - Supported by :mod:`dataclasses`, but does not compose well - the synthesized
    ``__init__`` and ``__repr__`` will use ``_number`` as the parameter/attribute name.

* using a "freezing" mechanism, such as :func:`dataclasses.dataclass` or :class:`typing.NamedTuple`::

      @dataclass(frozen=True)
      class Foo:
          number: int


      class Bar(NamedTuple):
          number: int

  - Overriding ``number`` is possible in the ``@dataclass`` case.
  - Read-only at runtime. [#runtime]_
  - No per-attribute control - these methods apply to the whole class.
  - Frozen dataclasses incur some runtime overhead.
  - Not all classes qualify to be a ``NamedTuple``.

Protocols
---------

Paraphrasing `this post <https://github.com/python/typing/discussions/1525>`_,
there is no way of defining a :class:`~typing.Protocol`, such that the only requirements to satisfy are:

1. ``hasattr(obj, name)``
2. ``isinstance(obj.name, T)`` [#invalid_typevar]_ 

The above are satisfiable at runtime by all of the following:

1. an object with an attribute ``name: T``,
2. a class with a class variable ``name: ClassVar[T]``, [#invalid_typevar]_
3. an instance of the class above,
4. an object with a ``@property`` ``def name(self) -> T``,
5. an object with a custom descriptor, such as :func:`functools.cached_property`.

The most common practice is to define such a protocol with a ``@property``::

    class HasName[T](Protocol):
        @property
        def name(self) -> T: ...

Type checkers special-case this definition, such that objects with plain attributes
are assignable to the type. However, instances with class variables and descriptors
other than ``property`` are rejected.

Covering the extra possibilities induces a great amount of boilerplate, involving
creation of an abstract descriptor protocol, possibly also accounting for
class vs instance level overloads.
Worse yet, all of that is multiplied for each additional read-only attribute.


Rationale
=========

[Describe why particular design decisions were made.]


Specification
=============

[Describe the syntax and semantics of any new language feature.]


Backwards Compatibility
=======================

This PEP introduces new contexts where ``ReadOnly`` is valid. Programs inspecting
those places will have to change to support it. This is expected to mainly affect type checkers.

However, caution is advised while using the backported ``typing_extensions.ReadOnly``
in older versions of Python, especially in conjunction with other type qualifiers;
not all nesting orderings might be treated equal. In particular, the ``@dataclass``
decorator which looks for ``ClassVar`` will incorrectly treat
``ReadOnly[ClassVar[...]]`` as an instance attribute.


Security Implications
=====================

There are no known security consequences arising from this PEP.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Footnotes
=========

.. [#overriding_property]
    Pyright in strict mode disallows non-property overrides.
    Mypy does not impose this restriction and allows an override with a plain attribute.
    `[Pyright playground] <https://pyright-play.net/?strict=true&code=MYGwhgzhAEBiD28BcBYAUNT0D6A7ArgLYBGApgE5LQCWuALuultACakBmO2t1d22ACgikQ7ADTQCJClVp0AlNAC0APmgA5eLlKoMzLMNEA6PETLloAXklmKjPZgACAB3LxnFOgE8mWNpylzIRF2RVUael19LHJSOnxyXGhDdhNAuzR7UEgYACEwcgEEeHkorHTKCIY0IA>`_
    `[mypy playground] <https://mypy-play.net/?mypy=latest&python=3.12&flags=strict&gist=6f860a865c5d13cce07d6cbb08b9fb85>`_

.. [#runtime]
    This PEP focuses solely on the type-checking behavior. Nevertheless, it should
    be desirable the name is read-only at runtime.

.. [#invalid_typevar]
    The implied type variable is not valid in this context. It has been used here
    for ease of demonstration.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
