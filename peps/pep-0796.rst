PEP: 796
Title: Host-relocatable virtual environments
Author: Richard Levasseur <richardlev@gmail.com>
Discussions-To: TODO
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 06-26-2025
Python-Version: 3.15
Sponsor: TODO
Post-History: `DD-MM-YYYY <https://url-to-pep-discussion>`__

.. highlight:: rst


Abstract
========

This PEP describes how a Python virtual environment can be configured
to allow copying it as-is to different hosts and still have a functioning
virtual environment. Making this work consists of two main pieces:

* Using a relative path for `home` in `pyvenv.cfg`, which Python canonicalizes
  at runtime.
* Having package installers recognize a host-relocatable venv and generate
  appropriate outputs, e.g. script wrappers.


Motivation
==========

There are two main motivations for allowing relative paths in `pyvenv.cfg`
and thus enabling host-relocatable virtual environments.

First, it is currently proscribed that the `home` value in `pyvenv.cfg` be an
absolute path. The behavior of relative paths is unspecified.
While techniques exist to work around this for every other
sub-part of a virtual environment, the one remaining part without a teneable
solution is how the Python runtime itself finds `PYTHONHOME`. This is because,
currently, the startup process requires absolute paths be used for the `home`
key in `pyvenv.cfg`. If a relative path is used, behavior is unspecified
(currently, it is relative to the process's current working directory, making
it untenable to use).

This requirement is overly proscriptive and restrictive because, given a known
anchor point, it's easy to tranform a relative path to an absolute path and
still retain predictable and reliable behavior. Thus, the absolute path
requirement should be relaxed and relative path behavior allowed and defined.

Second, virtual environments are the standard way for running Python
applications. This means ...

* The closer the dev environment is to the non-dev environment, the more reliable
  software one can get.
* The closer the dev and non-dev envs are, the easier it is to reproduce issues.
* The simpler the process is to re-create the environment, the more reliable
  software one can get.
* The simpler the process is to re-create the environment, the faster the process
  can be.

By making it trivial to copy a virtual environment from one host to another,
it avoids these categories of problems. Additionally, the development tools
to create a virtual environment and install its dependencies aren't needed
on the host that intends to run the program.

Rationale
=========


Python Runtime Changes
======================

The Python runtime itself *almost* already supports host-relocating virtual
environment and the only change needed is to define how it resolves relative
paths for `home` in `pyvenv.cfg`.

Today, relative paths resolve relative to the process's current working
directory. Because CWD isn't knowable in advance, it makes relative paths today
effective impossible.

Instead, the paths should be relative to the location of the `pyvenv.cfg` file.
This file is chosen as the anchor point because the tool that creates the file
also has to know where the Python runtime is, so can easily calculate the
correct relative path. For tools that read the `pyvenv.cfg`, it is also easy
to simple join the directory name of where `pyvenv.cfg` was found with the
path in the config file. When a person reads the config file, they can do
similar, which is a lower cognitive burden and helps avoids the question of
"relative to what?"

This change is only a couple of lines in the start up code. Specifically, when
parsing the `pyvenv.cfg` file and finding the `home` value, it just needs to
be checked if it's already absolute. If not, then join to the directory name
of the `pyvenv.cfg` file. The code alredy knows the directory and has helpers
already present for checking if a path is absolute and joining two paths.

A proof of concept for this is at TODO-link to code

Virtual Environment Tool Changes
================================

Venv tools should accept a `--relative` flag. When set, they generate a
`pyvenv.cfg` file with a `home` key that is a relative path to the relevant
Python installation.

TODO: or `--relocatable`? This is the term uv uses. However, discussion points
out that "relocatable" is a big ambiguous insofar as absolute paths allow
arbitrary relocation *on a host*, while relative paths allow relocation
_between_ hosts.


Package Installer Changes
=========================

Package installers must be aware of when a relative virtual environment has
been defined so they can avoid using absolute paths. The two main places
absolute paths occur today are:

1. `bin/` scripts, where shebangs are rewritten.
2. `site-packages` symlinks.

Instead, they should create relative symlinks pointing to the actual
installation directory for packages.


Relocating a Venv to Another Host
=================================

Copying the venv to another host is simple: copy the venv directory itself, the
relative location `home` points to, and preserve the relative directory
structures.

In practice, this typically means copying a parent directory of the virtual
environment, which contains the runtime, installations of dependencies, and
the group of virtual environments to relocate.

Backwards Compatibility
=======================

Because relative paths for `home` aren't usable in practice, and their
behavior undocumented and unspecified, there shouldn't be any backward
compatibility concerns.


How to Teach This
=================

Teaching this should be simple: if you use a relative path in `pyvenv.cfg`,
then it's relative to the directory containing the `pyvenv.cfg` file. This
is simple to explain and understand.


Reference Implementation
========================

TODO link to rickeylev/cpython branch for runtime changes

TODO link to rules_python and rules_py implementation of relative venvs


Open Issues
===========


Footnotes
=========

* PBS
* rules_python
* rules_py
* uv venv relocatable


Rejected Ideas
=====================

Relative to virtual env root
----------------------------

Having the `home` value in `pyvenv.cfg` relative to the virtual environments
root directory would work just as well, but this idea is rejected because it
requires additional effort to compute the virtual env root.

Unspecified `home` means to dynamically compute home
----------------------------------------------------

Today, if a `pyvenv.cfg` file doesn't set `home`, the runtime will try to
dynamically compute it by checking if the current executable (which is typicall
the venv's `bin/python3` symlink) is a symlink and, if so, use where that
points as `PYTHONHOME`.

This behavior is undesirable for a couple reasons:

1. It presents platform-specific issues, namely with Windows. Windows does
   support symlinks, but not by default, and it can require special
   permissions to do so.
2. It _requires_ that a symlink be used, which precludes using otherwise
   equivalent mechanisms for creating an executable (e.g. a wrapper script,
   hard links, etc).

In general, symlinks work best when they aren't special cased by consumers.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
