PEP: 796
Title: Host-relocatable virtual environments
Author: Richard Levasseur <richardlev@gmail.com>
Discussions-To: TODO
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 06-26-2025
Python-Version: 3.15
Sponsor: TODO
Post-History: `DD-MM-YYYY <https://url-to-pep-discussion>`__

.. highlight:: rst


Abstract
========

This PEP describes how a Python virtual environment can be configured
to allow copying it as-is to different hosts and still have a functioning
virtual environment. Making this work consists of two main pieces:

* Using a relative path for `home` in `pyvenv.cfg`, which Python canonicalizes
  at runtime.
* Having package installers recognize a host-relocatable venv and generate
  appropriate outputs, e.g. script wrappers.


Rationale
=========

There are two primary rationales for host-relocatable virtual environments.

First, it is currently proscribed that the `home` value in `pyvenv.cfg` be an
absolute path. The behavior of relative paths is unspecified. This requirement
is overly proscriptive and restrictive because, given a known anchor point,
it's easy to tranform a relative path to absolute path and still retain
predictable and reliable behavior. Thus, the absolute path requirement should
be relaxed and relative path behavior allowed and defined.

Second, virtual environments are the standard way for running Python
applications. This means ...

* The closer the dev environment is to the non-dev environment, the more reliable
  software one can get.
* The closer the dev and non-dev envs are, the easier it is to reproduce issues.
* The simpler the process is to re-create the environment, the more reliable
  software one can get.
* The simpler the process is to re-create the environment, the faster the process
  can be.

By making it trivial to copy a virtual environment from one host to another,
it avoids these categories of problems.

Another use case it enables it for multiple virtual environments to share
a Python interpreter. This allows a group of independent applications to have
different third party dependency closures, while benefiting from a shared
runtime.

Python Runtime Changes
======================

The Python runtime itself *almost* already supports host-relocating virtual
environment and the only change needed is to define how it resolves relative
paths for `home` in `pyvenv.cfg`.

Today, relative paths resolve relative to the process's current working
directory. Because CWD isn't knowable in advance, it makes relative paths today
effective impossible.

Instead, the paths should be relative to the location of the `pyvenv.cfg` file.
This file is chosen as the anchor point because the tool that creates the file
also has to know where the Python runtime is, so can easily calculate the
correct relative path. For tools that read the `pyvenv.cfg`, it is also easy
to simple join the directory name of where `pyvenv.cfg` was found with the
path in the config file. When a person reads the config file, they can do
similar, which is a lower cognitive burden and helps avoids the question of
"relative to what?"

This change is only a couple of lines in the start up code. Specifically, when
parsing the `pyvenv.cfg` file and finding the `home` value, it just needs to
be checked if it's already absolute. If not, then join to the directory name
of the `pyvenv.cfg` file. The code alredy knows the directory and has helpers
already present for checking if a path is absolute and joining two paths.

The core change in the Python runtime is to define how it finds it's
For the most part, the Python runtime itself is already


Virtual Environment Tool Changes
================================

Venv tools should accept a `--relative` flag. When set, they generate
`pyvenv.cfg` file with a `home` key that is a relative path to the relevant
Python installation.

TODO: or `--relocatable`? This is the term uv uses. However, discussion points
out that "relocatable" is a big ambiguous insofar as absolute paths allow
arbitrary relocation *on a host*, while relative paths allow relocation
_between_ hosts.




Package Installer Changes
=========================

Backwards Compatibility
=======================

Because relative paths for `home` aren't usable in practice, and their
behavior undocumented and unspecified, there shouldn't be any backward
compatibility concerns.


How to Teach This
=================

Teaching this should be simple: if you use a relative path in `pyvenv.cfg`,
then it's relative to the directory containing the `pyvenv.cfg` file. This
is simple to explain and understand.


Reference Implementation
========================

TODO link to rickeylev/cpython branch for runtime changes

TODO link to rules_python and rules_py implementation of relative venvs


Open Issues
===========


Footnotes
=========


Rejected Ideas
=====================

Relative to virtual env root
----------------------------

Having the `home` value in `pyvenv.cfg` relative to the virtual environments
root directory would work just as well, but this idea is rejected because it
requires additional effort to compute the virtual env root.

Unspecified `home` means to dynamically compute home
----------------------------------------------------

Today, if a `pyvenv.cfg` file doesn't set `home`, the runtime will try to
dynamically compute it by checking if the current executable (which is typicall
the venv's `bin/python3` symlink) is a symlink and, if so, use where that
points as `PYTHONHOME`.

This behavior is undesirable for a couple reasons:

1. It presents platform-specific issues, namely with Windows. Windows does
   support symlinks, but not by default, and it can require special
   permissions to do so.
2. It _requires_ that a symlink be used, which precludes using otherwise
   equivalent mechanisms for creating an executable (e.g. a wrapper script,
   hard links, etc).

In general, symlinks work best when they aren't special cased by consumers.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
