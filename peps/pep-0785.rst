PEP: 785
Title: ``ExceptionGroup.leaf_exceptions()`` and ``except*`` chaining
Author: Zac Hatfield-Dodds <zac@zhd.dev>
Sponsor: Gregory P. Smith <greg@krypto.org>
Discussions-To: https://discuss.python.org/t/88244
Status: Draft
Type: Standards Track
Created: 08-Apr-2025
Python-Version: 3.15
Post-History:
  `13-Apr-2025 <https://discuss.python.org/t/88244>`__,

Abstract
========

As :pep:`654` :class:`ExceptionGroup` has come into widespread use across the
Python community, some common but awkward patterns have emerged. We therefore
propose:

- a new :meth:`!BaseExceptionGroup.leaf_exceptions` method, returning a list
  of (exception, full_traceback) pairs consisting of each non-group exception
  and a traceback composited from any intermediate groups.

- a narrow language change: if an exception is raised inside an ``except*``
  block, and that exception is (by identity) part of the group, do not attach
  the group as ``.__context__``.

We expect this to enable more concise expression of error handling logic in
many medium-complexity cases. Without them, exception-group handlers will
continue to discard intermediate tracebacks and mis-handle ``__context__``
exceptions, to the detriment of anyone debugging async code.


Motivation
==========

As exception groups come into widespread use, library authors and end users
often write code to process or respond to individual leaf exceptions, for
example when implementing middleware, error logging, or response handlers in
a web framework.

In April 2025, `searching GitHub`__ [#naming]_ found four implementations of
:meth:`!leaf_exceptions` by various names in the first sixty hits, of which
none handle tracebacks.\ [#numbers]_  The same search found thirteen cases
where :meth:`!.leaf_exceptions` could be used.  In August, `searching`__
for ``leaf_exceptions`` identified a total of five distinct implementations,
none of which handled tracebacks, and three cases of copying an early
reference implementation from this PEP.  We therefore believe that providing
a method on the :class:`BaseException` type with proper traceback preservation
will improve error-handling and debugging experiences across the ecosystem.

__ https://github.com/search?q=%2Ffor+%5Cw%2B+in+%5Beg%5D%5Cw*%5C.exceptions%3A%2F+language%3APython&type=code

__ https://github.com/search?q=%2Fdef+.*leaf_exceptions.*%5C%28%2F+language%3APython&type=code

When Python raises an exception, it automatically sets ``__context__`` to
track what was being handled at the time. This normally provides valuable
debugging information. However, with ``except*``, this behavior can create
a problem.  Consider this example middleware, which unwraps a single-exception
group:

.. code-block:: python

    except* HTTPException as group:
        (exc, tb), *rest = group.leaf_exceptions()
        if not rest:
            raise exc.with_traceback(tb)
        raise

In this case, the implicit ``exc.__context__ = group`` discards the original
context of the error, which may contain crucial information to understand why
the exception was raised. In many production apps it also causes tracebacks
to balloon from hundreds of lines to as many as `hundreds of thousands of
lines`__ - a volume which makes understanding errors far more difficult than
it should be.

__ https://github.com/python-trio/trio/issues/2001#issuecomment-931928509

We believe that this behavior is almost always unintentional and undesired
when raising a subgroup or leaf from inside an ``except*`` statement, and
therefore propose that in this narrow case Python should not automatically
attach the active exception as ``__context__``.  In cases where tracking the
full group is desirable, ``raise leaf from group`` is easy and explicit.


Specification
=============

:meth:`!BaseExceptionGroup.leaf_exceptions`
-------------------------------------------

A new method ``.leaf_exceptions()`` will be added to ``BaseExceptionGroup``,
with the following signature:

.. code-block:: python

    def leaf_exceptions(self) -> list[tuple[BaseException, TracebackType]]: ...

Each traceback is constructed by concatenating the tracebacks of the
corresponding leaf exception with those of each enclosing group in turn.

While exception groups are typically tree-structured, it is possible to
construct an ``ExceptionGroup`` where two child groups both contain a shared
grandchild exception; and with a custom subclass of ``ExceptionGroup`` you
can even form cycles.  The ``.leaf_exceptions()`` method will therefore
track already-seen objects by identity, traversing each subgroup once and
outputting each leaf exception once.


``except*`` changes to ``.__context__`` handling
------------------------------------------------

The language change is fairly simple: if an exception is raised inside an
``except*`` block, and that exception is (by identity) part of the group,
do not attach the group as ``.__context__``.  Similar semantics can be
implemented using an unwieldy try/finally:

.. code-block:: python

    except* FooError as group:
        try:
            ...  # current body of except* goes here
        finally:
            exc = sys.exception()
            queue = [group]
            seen_ids = set()
            while queue:
                part = queue.pop(0)
                if id(part) in seen_ids:
                    continue
                seen_ids.add(id(part))
                if exc is part:
                    if exc.__cause__ is part.__cause__:
                        continue  # leave `raise x from y` untouched
                    exc.__context__ = part.__context__
                    break
                if isinstance(exc, BaseExceptionGroup):
                    queue.extend(exc.exceptions)

This example implementation is careful to check for re-raised subgroups in
addition to re-raised leaf exceptions, without following cycles.
Checking by identity means that there is at most one match, and thus iteration
order is unimportant - though the tendency of end-user code to re-raise the
first rather than a later subgroup offers a small performance advantage.


Backwards Compatibility
=======================

Adding a new method to a built-in class, especially one as widely used as
``BaseException``, can have substantial impacts. However, `GitHub search`__
shows zero user-defined ``.leaf_exceptions(`` methods.  Any such methods
in private code will shadow the new method proposed in the PEP, and are
therefore backwards-compatible at runtime.

__ https://github.com/search?q=%2F%5C.leaf_exceptions%5C%28%2F+language%3APython&type=code

Our proposed change to ``except*`` does not affect a bare ``raise`` statement,
nor ``raise exc from cause`` - only ``raise exc``.  In cases where the current
behavior is desired, which we expect is very rare, users can
``raise exc from group`` or even ``exc.__context__ = group; raise exc`` for
a truly exact match.


How to Teach This
=================

Working with exception groups is an intermediate-to-advanced topic, unlikely
to arise for beginning programmers. We therefore suggest teaching this topic
via documentation, and via just-in-time feedback from static analysis tools.
In intermediate classes, we recommend teaching ``.leaf_exceptions()`` together
with the ``.split()`` and ``.subgroup()`` methods, emphasizing a preference
for the latter.

Both the API reference and the existing `ExceptionGroup tutorial`__
should be updated to demonstrate and explain the new method. The tutorial
might include examples of common patterns where ``.leaf_exceptions()`` helps
simplify error handling logic.

__ https://docs.python.org/3/tutorial/errors.html#raising-and-handling-multiple-unrelated-exceptions

We have also designed lint rules for inclusion in ``flake8-async`` which
suggest using ``.split()``, ``.subgroup()``, or ``.leaf_exceptions()`` when
iterating over ``group.exceptions`` or re-raising a leaf exception.

We recommend mentioning the ``except*``-``__context__`` behavior in the
reference documentation for BaseException, but not in the error-handling
tutorial.


Reference Implementation
========================

While the methods on built-in exceptions will be implemented in C if this PEP
is accepted, we hope that the following Python implementation will be useful
on older versions of Python, and can demonstrate the intended semantics.

We have found these helper functions quite useful when working with
:class:`ExceptionGroup`\ s in a large production codebase.

A ``leaf_exceptions()`` helper function
---------------------------------------

.. code-block:: python

    from types import TracebackType


    def leaf_exceptions(self) -> list[tuple[BaseException, TracebackType | None]]:
        """
        Return a list of (leaf_exception, full_traceback) pairs.

        'Leaf' exceptions are the non-group exceptions contained inside an
        exception group, its subgroups, and so on.  The 'full traceback' is
        constructed by concatenating the traceback of the leaf exception
        with that of each containing group in turn.  Tracebacks are returned
        separately because :meth:`BaseException.with_traceback` mutates the
        exception in-place, which is undesirable if e.g. you may raise the
        group unchanged.

        Each distinct leaf exception will be included, or group traversed,
        only once - even if it appears in multiple subgroups or a cycle.
        """
        queue: list[tuple[BaseException, TracebackType | None]] = [(self, None)]
        seen_ids: set[object] = set()
        result: list[tuple[BaseException, TracebackType | None]] = []
        while queue:
            exc, parent_tb = queue.pop()
            if id(exc) in seen_ids:
                continue
            seen_ids.add(id(exc))
            tb = _combine_tracebacks(parent_tb, exc.__traceback__)
            if isinstance(exc, BaseExceptionGroup):
                queue.extend((e, tb) for e in exc.exceptions[::-1])
            else:
                result.append((exc, tb))
        return result


    def _combine_tracebacks(
        tb1: TracebackType | None,
        tb2: TracebackType | None,
    ) -> TracebackType | None:
        """
        Combine two tracebacks, putting tb1 frames before tb2 frames.

        If either is None, return the other.
        """
        if tb1 is None:
            return tb2
        if tb2 is None:
            return tb1

        # Convert tb1 to a list of frames
        frames = []
        current = tb1
        while current is not None:
            frames.append((current.tb_frame, current.tb_lasti, current.tb_lineno))
            current = current.tb_next

        # Create a new traceback starting with tb2
        new_tb = tb2

        # Add frames from tb1 to the beginning (in reverse order)
        for frame, lasti, lineno in reversed(frames):
            new_tb = TracebackType(
                tb_next=new_tb, tb_frame=frame, tb_lasti=lasti, tb_lineno=lineno
            )

        return new_tb


A ``preserve_context()`` context manager
----------------------------------------

A change to the semantics of ``except*`` cannot be backported in Python
(although see the Specification section for illustration).  We hope this
simpler helper function will meet the same needs on older Python versions.

.. code-block:: python

    @contextlib.contextmanager
    def preserve_context(exc):
        ctx = exc.__context__
        try:
            yield exc
        finally:
            # assert sys.exception() is exc  # optional sanity-check
            exc.__context__ = ctx

    try:
        ...
    except* Exception as group:
        with preserve_context(group.exceptions[0]) as exc:
            raise exc


Rejected Ideas
==============

Add utility functions instead of methods
----------------------------------------

Rather than adding methods to exceptions, we could provide utility functions
like the reference implementations above.
There are however several reasons to prefer methods: there's no obvious place
where helper functions should live, they take exactly one argument which must
be an instance of ``BaseException``, and methods are both more convenient and
more discoverable.


Add ``BaseException.as_group()`` (or group methods)
---------------------------------------------------

Our survey of ``ExceptionGroup``-related error handling code also observed
many cases of duplicated logic to handle both a bare exception, and the same
kind of exception inside a group (often incorrectly, motivating
``.leaf_exceptions()``).

We briefly `proposed <https://github.com/python/cpython/issues/125825>`__
adding ``.split(...)`` and ``.subgroup(...)`` methods to all exceptions,
before considering ``.leaf_exceptions()`` made us feel this was too clumsy.
As a cleaner alternative, we sketched out an ``.as_group()`` method:

.. code-block:: python

    def as_group(self):
        if not isinstance(self, BaseExceptionGroup):
            return BaseExceptionGroup("", [self])
        return self

However, applying this method to refactor existing code was a negligible
improvement over writing the trivial inline version. We also hope that many
current uses for such a method will be addressed by ``except*`` as older
Python versions reach end of life.

We recommend documenting a "convert to group" recipe for de-duplicated error
handling, instead of adding group-related methods to ``BaseException``.


Add a ``with e.preserve_context(): raise e`` context manager
------------------------------------------------------------

Every case we identified in existing code was better addressed by the small
language change in the current version of this PEP.  While a language change
is in some sense a bigger deal than adding a method, we argue that there is
a substantial advantage in that handling this without user intervention
prevents many possible mistakes, whether misuse or lack-of-use.


Add ``e.raise_with_preserved_context()`` instead of a context manager
---------------------------------------------------------------------

We preferred the context-manager form because it allows ``raise ... from ...``
if the user wishes to (re)set the ``__cause__``, and is overall somewhat
less magical and tempting to use in cases where it would not be appropriate.
We could be argued around though, if others prefer this form.


Preserve additional attributes
------------------------------

We decided against preserving the ``__cause__`` and ``__suppress_context__``
attributes, because they are not changed by re-raising the exception, and we
prefer to support ``raise exc from None`` or ``raise exc from cause_exc``
together with ``with exc.preserve_context():``.

Similarly, we considered preserving the ``__traceback__`` attribute, and
decided against because the additional ``raise ...`` statement may be an
important clue when understanding some error. If end users wish to pop a
frame from the traceback, they can do with a separate context manager.


Footnotes
=========

.. [#numbers]
    From the first sixty `GitHub search results
    <https://github.com/search?q=%2Ffor+%5Cw%2B+in+%5Beg%5D%5Cw*%5C.exceptions%3A%2F+language%3APython&type=code>`__
    for ``for \w+ in [eg]\w*\.exceptions:``, we find:

    * Four functions implementing ``leaf_exceptions()`` semantics, none of
      which preserve tracebacks:
      (`one <https://github.com/nonebot/nonebot2/blob/570bd9587af99dd01a7d5421d3105d8a8e2aba32/nonebot/utils.py#L259-L266>`__,
      `two <https://github.com/HypothesisWorks/hypothesis/blob/7c49f2daf602bc4e51161b6c0bc21720d64de9eb/hypothesis-python/src/hypothesis/core.py#L763-L770>`__,
      `three <https://github.com/BCG-X-Official/pytools/blob/9d6d37280b72724bd64f69fe7c98d687cbfa5317/src/pytools/asyncio/_asyncio.py#L269-L280>`__,
      `four <https://github.com/M-o-a-T/moat/blob/ae174b0947288364f3ae580cb05522624f4f6f39/moat/util/exc.py#L10-L18>`__)

    * Six handlers which raise the first exception in a group, discarding
      any subsequent errors; these would benefit from both proposed methods.
      (`one <https://github.com/Lancetnik/FastDepends/blob/239cd1a58028782a676934f7d420fbecf5cb6851/fast_depends/core/model.py#L488-L490>`__,
      `two <https://github.com/estuary/connectors/blob/677824209290c0a107e63d5e2fccda7c8388101e/source-hubspot-native/source_hubspot_native/buffer_ordered.py#L108-L111>`__,
      `three <https://github.com/MobileTeleSystems/data-rentgen/blob/7525f7ecafe5994a6eb712d9e66b8612f31436ef/data_rentgen/consumer/__init__.py#L65-L67>`__,
      `four <https://github.com/ljmf00/simbabuild/blob/ac7e0999563b3a1b13f4e445a99285ea71d4c7ab/simbabuild/builder_async.py#L22-L24>`__,
      `five <https://github.com/maxjo020418/BAScraper/blob/cd5c2ef24f45f66e7f0fb26570c2c1529706a93f/BAScraper/BAScraper_async.py#L170-L174>`__,
      `six <https://github.com/sobolevn/faststream/blob/0d6c9ee6b7703efab04387c51c72876e25ad91a7/faststream/app.py#L54-L56>`__)

    * Seven cases which mishandle nested exception groups, and would thus
      benefit from ``leaf_exceptions()``. We were surprised to note that only
      one of these cases could straightforwardly be replaced by use of an
      ``except*`` clause or ``.subgroup()`` method.
      (`one <https://github.com/vertexproject/synapse/blob/ed8148abb857d4445d727768d4c57f4f11b0d20a/synapse/lib/stormlib/iters.py#L82-L88>`__,
      `two <https://github.com/mhdzumair/MediaFusion/blob/ff906378f32fb8419ef06c6f1610c08946dfaeee/scrapers/base_scraper.py#L375-L386>`__,
      `three <https://github.com/SonySemiconductorSolutions/local-console/blob/51f5af806336e169d3dd9b9f8094a29618189f5e/local-console/src/local_console/commands/server.py#L61-L67>`__,
      `four <https://github.com/SonySemiconductorSolutions/local-console/blob/51f5af806336e169d3dd9b9f8094a29618189f5e/local-console/src/local_console/commands/broker.py#L66-L69>`__,
      `five <https://github.com/HexHive/Tango/blob/5c8472d1679068daf0f041dbbda21e05281b10a3/tango/fuzzer.py#L143-L160>`__,
      `six <https://github.com/PaLora16/ExceptionsGroupsValidators/blob/41152a86eec695168fdec74653694658ddc788fc/main.py#L39-L44>`__,
      `seven <https://github.com/reactive-python/reactpy/blob/178fc05de7756f7402ed2ee1e990af0bdad42d9e/src/reactpy/backend/starlette.py#L164-L170>`__)

    indicating that more than a quarter of *all* hits for this fairly general
    search would benefit from the methods proposed in this PEP.

.. [#naming]
    The name ``leaf_exceptions()`` was `first proposed`__ in an early
    precursor to :pep:`654`. If the prototype had matched ``except*``
    in wrapping bare exceptions in a group, we might even have included
    a ``.leaf_exceptions()`` method in that earlier PEP!

__ https://github.com/python-trio/exceptiongroup/pull/13


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license,
whichever is more permissive.
