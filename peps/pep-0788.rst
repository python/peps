PEP: 788
Title: Reimagining Native Threads
Author: Peter Bierma <zintensitydev@gmail.com>
Sponsor: Victor Stinner <vstinner@python.org>
Discussions-To: https://discuss.python.org/t/89863
Status: Draft
Type: Standards Track
Created: 23-Apr-2025
Python-Version: 3.15
Post-History: `10-Mar-2025 <https://discuss.python.org/t/83959>`__,
              `27-Apr-2025 <https://discuss.python.org/t/89863>`__,


Abstract
========

In Python, threads are able to interact with an interpreter (e.g., invoke the
bytecode loop) through an :term:`attached thread state`. On with-GIL builds,
only one thread can hold an attached thread state at once, which means that
the thread holds the :term:`GIL`. On free-threaded builds, there can be
infinitely many thread states attached, allowing for parallelism (because
multiple threads can invoke the interpreter at once).

With that in mind, attachment of thread states is a bit problematic in the C API.
The C API currently provides two ways to acquire and attach a thread state for
an interpreter:

- :c:func:`PyGILState_Ensure` & :c:func:`PyGILState_Release`.
- :c:func:`PyThreadState_New` & :c:func:`PyThreadState_Swap` (significantly
  less common).

The former, ``PyGILState``, are the most common way to do this and have been
the standard for over twenty years (:pep:`311`), but have a number of issues
that have arisen over time:

- Subinterpreters tend to have trouble with them, because in threads that
  haven't ever had an attached thread state, :c:func:`PyGILState_Ensure`
  will assume that the main interpreter was requested. This makes it
  impossible for the thread to interact with the subinterpreter!
- The phrase "GIL" is confusing for developers of free-threaded
  extensions, because there's no GIL there, right? Even on free-threaded
  builds, threads still needs a thread state to interact with the interpreter,
  it's just that they don't have to wait on one-another to do so. These days,
  the important thing that :c:func:`PyGILState_Ensure` does is get attach a
  thread state, and acquiring the GIL is somewhat incidental.

The other option, :c:func:`PyThreadState_New` and :c:func:`PyThreadState_Swap`,
do solve those issues, but come with an additional problem with how thread state
attachment works in the C API (that ``PyGILState`` also includes): if the
thread is not the main thread, then the interpreter will randomly hang the
thread during attachment if it starts finalizing. This can be frustrating,
especially if there was some additional work to be done alongside invoking
Python.

This PEP intends to solve these issues by providing :c:func:`PyThreadState_Ensure`
and :c:func:`PyThreadState_Ensure` as replacements for the existing functions,
accompanied by some interpreter reference counting APIs that let thread states
be acquired and attached in a thread-safe and predictable manner.

Terminology
===========

Interpreters
------------

In this proposal, "interpreter" refers to a singular, isolated interpreter
(see :pep:`684`), with its own :c:type:`PyInterpreterState` pointer (referred
to as an "interpreter-state"). Interpreter *does not* refer to the entirety
of a Python process.

The "current interpreter" refers to the interpreter by the interpreter-state
pointer on an :term:`attached thread state`.

Finalization vs Shutdown
------------------------

Throughout this PEP, the terms "finalization" and "shutdown" are used in
reference to what an interpreter does at the end of its lifetime, either
because the program is closing or because :c:func:`Py_EndInterpreter` was
called. There's a subtle difference between the two terms, as used in this
PEP:

- "Finalization" refers to an interpreter getting ready to "shut down", in
  which it runs garbage collections, cleans up threads, and deletes
  per-interpreter state. This should not be confused with *runtime*
  finalization, where process-wide state is also cleaned up, but be aware
  that the main interpreter is finalized alongside the runtime.
- "Shutdown" (or "shut down", as a verb) refers to the interpreter being
  finished, after finalization has already happened. For example, shutdown
  for a subinterpreter entails the interpreter's state structure being
  deallocated.

Native and Python Threads
-------------------------

This PEP refers to a thread created using the C API as a "native thread",
also sometimes referred to as a "non-Python created thread", where a "Python
created" is a thread created by the :mod:`threading` module.

Native threads are typically created by :c:func:`PyGILState_Ensure`, but more
technically, it refers to any thread with a :term:`thread state` created using
the C API.

Motivation
==========

Native Threads Always Hang During Finalization
----------------------------------------------

Many codebases might need to call Python code in highly-asynchronous
situations where the desired interpreter
(:ref:`typically the main interpreter <pep-788-subinterpreters-gilstate>`)
could be finalizing or deleted, but want to continue running code after the
invoking the interpreter. This desire has been
`brought up by users <https://discuss.python.org/t/78850/>`_.
For example, a callback that wants to call Python code might be invoked when:

- A kernel has finished running on a GPU.
- A network packet was received.
- A thread has quit, and a native library is executing static finalizers of
  thread local storage.

Generally, this pattern would look something like this:

.. code-block:: c

    static void
    some_callback(void *closure)
    {
        /* Do some work */
        /* ... */

        PyGILState_STATE gstate = PyGILState_Ensure();
        /* Invoke the C API to do some computation */
        PyGILState_Release(gstate);

        /* ... */
    }

In the current C API, any "native" thread (one not created via the
:mod:`threading` module) is considered to be "daemon", meaning that the interpreter
won't wait on that thread to finalize. Instead, the interpreter will hang the
thread when it goes to :term:`attach <attached thread state>` a :term:`thread state`,
making it unusable past that point. Attaching a thread state can happen at
any point when invoking Python, such as releasing it in-between bytecode
instructions (to yield the GIL), or when a C function exits a
:c:macro:`Py_BEGIN_ALLOW_THREADS` block. (Note that hanging the thread is
relatively new behavior; in prior versions, the thread would terminate, but
the issue is the same.)

This means that any non-Python thread may be terminated at any point, which
is severely limiting for users who want to do more than just execute Python
code in their stream of calls (for example, C++ executing finalizers in
*addition* to calling Python).

``Py_IsFinalizing`` is Insufficient
***********************************

The :ref:`docs <python:gilstate>`
currently recommend :c:func:`Py_IsFinalizing` to guard against termination of
the thread:

    Calling this function from a thread when the runtime is finalizing will
    terminate the thread, even if the thread was not created by Python. You
    can use ``Py_IsFinalizing()`` or ``sys.is_finalizing()`` to check if the
    interpreter is in process of being finalized before calling this function
    to avoid unwanted termination.

Unfortunately, this isn't correct, because of time-of-call to time-of-use
issues; the interpreter might not be finalizing during the call to
:c:func:`Py_IsFinalizing`, but it might start finalizing immediately
afterwards, which would cause the attachment of a thread state (typically via
:c:func:`PyGILState_Ensure`) to hang the thread.

Daemon Threads Can Deadlock Finalization
****************************************

When acquiring locks, it's extremely important to detach the thread state to
prevent deadlocks. This is true on both the with-GIL and free-threaded builds.

When the GIL is enabled, a deadlock can occur pretty easily when acquiring a
lock if the GIL wasn't released; thread A grabs a lock, and starts waiting on
its thread state to attach, while thread B holds the GIL and is waiting on the
lock.

On free-threaded builds, lock-ordering deadlocks are still possible
if thread A acquired the lock for object A and then object B, and then
another thread tried to acquire those locks in a reverse order. Free-threading
protects against this by releasing locks when the thread state is detached.

So, all code that needs to work with locks need to detach the thread state.
In C, this is almost always done via :c:macro:`Py_BEGIN_ALLOW_THREADS` and
:c:macro:`Py_END_ALLOW_THREADS`, in a code block that looks something like this:

.. code-block:: c

    Py_BEGIN_ALLOW_THREADS
    acquire_lock();
    Py_END_ALLOW_THREADS

Again, in a daemon thread, :c:macro:`Py_END_ALLOW_THREADS` will hang the thread
if the interpreter is finalizing. But, :c:macro:`Py_BEGIN_ALLOW_THREADS` will
*not* hang the thread; the lock will be acquired, and *then* the thread will
be hung! Once that happens, nothing can try to acquire that lock without
deadlocking. The main thread will continue to run finalizers past that point,
though. If any of those finalizers try to acquire the lock, deadlock ensues.

This affects CPython itself, and there's not much that can be done
to fix it. For example, `python/cpython#129536 <https://github.com/python/cpython/issues/129536>`_
remarks that the :mod:`ssl` module can emit a fatal error when used at
finalization, because a daemon thread got hung while holding the lock.

.. _pep-788-hanging-compat:

Finalization Behavior for ``PyGILState_Ensure`` Cannot Change
*************************************************************

There will always have to be a point in a Python program where
:c:func:`PyGILState_Ensure` can no longer attach a thread state.
If the interpreter is long dead, then Python obviously can't give a
thread a way to invoke it. :c:func:`PyGILState_Ensure` doesn't have any
meaningful way to return a failure, so it has no choice but to terminate
the thread or emit a fatal error, as noted in
`python/cpython#124622 <https://github.com/python/cpython/issues/124622>`_:

    I think a new GIL acquisition and release C API would be needed. The way
    the existing ones get used in existing C code is not amenible to suddenly
    bolting an error state onto; none of the existing C code is written that
    way. After the call they always just assume they have the GIL and can
    proceed. The API was designed as "it'll block and only return once it has
    the GIL" without any other option.

For this reason, we can't make any real changes to how :c:func:`PyGILState_Ensure`
works during finalization, because it would break existing code.

The GIL-state APIs are Buggy and Confusing
------------------------------------------

There are currently two public ways for a user to create and attach their own
:term:`thread state`; manual use of :c:func:`PyThreadState_New` & :c:func:`PyThreadState_Swap`,
and :c:func:`PyGILState_Ensure`. The latter, :c:func:`PyGILState_Ensure`,
is `significantly more common <https://grep.app/search?q=pygilstate_ensure>`_.

``PyGILState_Ensure`` Generally Crashes During Finalization
***********************************************************

At the time of writing, the current behavior of :c:func:`PyGILState_Ensure` does not
match the documentation. Instead of hanging the thread during finalization
as previously noted, it's extremely common for it to crash with a segmentation
fault. This is a `known issue <https://github.com/python/cpython/issues/124619>`_
that could be fixed in CPython, but it's definitely worth noting
here. Incidentally, acceptance and implementation of this PEP will likely fix
the existing crashes caused by :c:func:`PyGILState_Ensure`.

The Term "GIL" is Tricky for Free-threading
*******************************************

A large issue with the term "GIL" in the C API is that it is semantically
misleading. This was noted in `python/cpython#127989
<https://github.com/python/cpython/issues/127989>`_,
created by the authors of this PEP:

    The biggest issue is that for free-threading, there is no GIL, so users
    erroneously call the C API inside ``Py_BEGIN_ALLOW_THREADS`` blocks or
    omit ``PyGILState_Ensure`` in fresh threads.

Again, :c:func:`PyGILState_Ensure` gets an :term:`attached thread state`
for the thread on both with-GIL and free-threaded builds. Acquisition of the
GIL on with-GIL builds is incidental! :c:func:`PyGILState_Ensure` is very
roughly equivalent to the following:

.. code-block:: c

    PyGILState_STATE
    PyGILState_Ensure(void)
    {
        PyThreadState *existing = PyThreadState_GetUnchecked();
        if (existing == NULL) {
            // Chooses the interpreter of the last attached thread state
            // for this thread. If Python has never ran in this thread, the
            // main interpreter is used.
            PyInterpreterState *interp = guess_interpreter();
            PyThreadState *tstate = PyThreadState_New(interp);
            PyThreadState_Swap(tstate);
            return opaque_tstate_handle(tstate);
        } else {
            return opaque_tstate_handle(existing);
        }
    }

.. _pep-788-subinterpreters-gilstate:

``PyGILState_Ensure`` Doesn't Guess the Correct Interpreter
-----------------------------------------------------------

As noted in the :ref:`documentation <python:gilstate>`,
``PyGILState`` APIs aren't officially supported in subinterpreters:

    Note that the ``PyGILState_*`` functions assume there is only one global
    interpreter (created automatically by ``Py_Initialize()``). Python
    supports the creation of additional interpreters (using
    ``Py_NewInterpreter()``), but mixing multiple interpreters and the
    ``PyGILState_*`` API is unsupported.

This is because :c:func:`PyGILState_Ensure` doesn't have any way
to know which interpreter created the thread, and as such, it has to assume
that it was the main interpreter. There isn't any way to detect this at
runtime, so spurious races are bound to come up in threads created by
subinterpreters, because synchronization for the wrong interpreter will be
used on objects shared between the threads.

For example, if the thread had access to object A, which belongs to a
subinterpreter, but then called :c:func:`PyGILState_Ensure` would have an
attached thread state pointing to the main interpreter, not the subinterpreter.
This means that any GIL assumptions about the object are wrong! There isn't
any synchronization between the two GILs, so both the thread (who thinks it's
in the subinterpreter) and the main thread could try to increment the
reference count at the same time, causing a data race!

Concurrent Interpreter Deallocation Issues
------------------------------------------

The other way of creating a native thread that can invoke Python,
:c:func:`PyThreadState_New` & :c:func:`PyThreadState_Swap`, is a lot better
for supporting subinterpreters (because :c:func:`PyThreadState_New` takes an
explicit interpreter, rather than assuming that the main interpreter was
requested), but is still limited by the current hanging problems in the C API.

In addition, subinterpreters typically have a much shorter lifetime than the
main interpreter, so there's a much higher chance that an interpreter passed
to a thread will have already finished and have been deallocated. Passing that
interpreter to :c:func:`PyThreadState_New` will most likely crash the program.

Rationale
=========

So, how do we address all of this? The best way seems to be starting from
scratch and "reimagining" how to acquire and attach thread states in the C API.

As a summary, there's a few bases we want to cover in a new API:

- Require the caller to specify which interpreter they want to prevent those
  pesky problems with interpreter guessing.
- Prevent the thread from being arbitrarily bricked by calling into Python.
- Protection against deallocation on interpreters with short lifetimes.
- Backwards-compatibility with the old APIs and ideas, such as "daemonness"
  (but as opt-in).

Preventing Interpreter Shutdown with Reference Counting
-------------------------------------------------------

This PEP takes an approach where interpreters are given a reference count by
non-daemon threads that want to (or do) hold an attached thread state. When
the interpreter starts finalizing, it will until its reference count
reaches zero before proceeding to a point where threads will be hung.
Note that this *is not* the same as joining the thread; the interpreter will
only wait until the thread state has been released
(via :c:func:`PyThreadState_Release`) for all non-daemon threads. This isn't
the same as waiting for them to detach their thread state--it waits for them
to *destroy* it. Otherwise, this API wouldn't have any finalization benefits
over the existing ``PyThreadState`` functions.

So, from a thread's perspective, holding a "strong reference" to the
interpreter will effectively prevent it from finalizing, making it safe to
invoke Python without worrying about the thread being hung. The strong
reference will be held as long as thread state is "alive", even if it's
detached.

This proposal also comes with weak references to an interpreter that don't
prevent it from finalizing, but can be promoted to a strong reference once
decided that a thread state can attach. Promotion of a weak reference to a
strong reference can fail if the interpreter has already finalized, or reached
a point during finalization where it can't be guaranteed that the thread won't
hang.

If there's additional work after destroying the thread state, the thread
can continue running as normal. If that work needs to finish before the
program exits, it's still up to the user on how to join the thread, for
example by using an :mod:`atexit` handler can be used to join the thread.
Again, this PEP isn't trying to reinvent how to create or join threads!

Removing the GIL-state APIs
---------------------------

Due to the plethora of issues with ``PyGILState``, this PEP intends to do away
with them entirely. In today's C API, all ``PyGILState`` functions are
replaceable with ``PyThreadState`` counterparts that are compatibile with
subinterpreters:

- :c:func:`PyGILState_Ensure`: :c:func:`PyThreadState_Swap` & :c:func:`PyThreadState_New`
- :c:func:`PyGILState_Release`: :c:func:`PyThreadState_Clear` & :c:func:`PyThreadState_Delete`
- :c:func:`PyGILState_GetThisThreadState`: :c:func:`PyThreadState_Get`
- :c:func:`PyGILState_Check`: ``PyThreadState_GetUnchecked() != NULL``

This PEP specifies a ten-year deprecation for these functions (while remaining
in the stable ABI), mainly because it's expected that the migration will be a
little painful, because :c:func:`PyThreadState_Ensure` and
:c:func:`PyThreadState_Release` aren't drop-in replacements for
:c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release`, due to the
requirement of a specific interpreter. The exact details of this deprecation
aren't too clear, see :ref:`pep-788-deprecation`.

Specification
=============

Interpreter Reference Counting to Prevent Shutdown
--------------------------------------------------

An interpreter will keep track of a reference count managed by threads.
During finalization, the interpreter will wait until its
reference count reaches zero, and once that happens, threads can no longer
acquire a strong reference to the interpreter. The interpreter
must not hang threads until this reference count has reached zero.
Threads can hold as many references as they want, but in most cases,
a thread will have one reference at a time, typically through the
:term:`attached thread state`.

An attached thread state is made non-daemon by holding a strong reference
to the interpreter. When a non-daemon thread state is destroyed, it releases
the reference.

A weak reference to the interpreter won't prevent it from finalizing, but can
be safely accessed after the interpreter no longer supports strong references,
and even after the interpreter has been deleted. But, at that point, the weak
reference can no longer be converted to a strong reference.

Strong Interpreter References
*****************************

.. c:type:: PyInterpreterRef

   An opaque, strong reference to an interpreter.
   The interpreter will wait until a strong reference has been released
   before shutting down.

   This type is guaranteed to be pointer-sized.

.. c:function:: PyInterpreterRef PyInterpreterRef_Get(void)

    Acquire a strong reference to the current interpreter.

    This function is generally meant to be used in tandem with
    :c:func:`PyThreadState_Ensure`.

    This function cannot fail, other than with a fatal error when the caller
    doesn't hold an :term:`attached thread state`.

.. c:function:: PyInterpreterRef PyInterpreterState_AsStrong(PyInterpreterState *interp)

    Acquire a strong reference to *interp*.

    Beware: this function can cause crashes if *interp* shuts down in
    another thread! Prefer safely acquiring a reference through
    :c:func:`PyInterpreterRef_Get` where possible.

    This function will return ``0`` if *interp* has already finished waiting on
    non-daemon threads.

.. c:function:: PyInterpreterRef PyInterpreterRef_Dup(PyInterpreterRef ref)

    Duplicate a strong reference to an interpreter.

    This function is generally meant to be used in tandem with
    :c:func:`PyThreadState_Ensure`.

    This function cannot fail, and the caller doesn't need to hold an
    :term:`attached thread state`.

.. c:function:: void PyInterpreterRef_Close(PyInterpreterRef ref)

    Release a strong reference to an interpreter, allowing it to shut down
    if there are no references left.

    This function cannot fail, and the caller doesn't need to hold an
    :term:`attached thread state`.

Weak Interpreter References
***************************

.. c:type:: PyInterpreterWeakRef

    An opaque, weak reference to an interpreter.
    The interpreter will *not* wait for the reference to be
    released before shutting down.

.. c:function:: PyInterpreterWeakRef *PyInterpreterWeakRef_Get(void)

    Acquire a weak reference to the current interpreter.

    This function is generally meant to be used in tandem with
    :c:func:`PyInterpreterWeakRef_AsStrong`.

    This function cannot fail, other than with a fatal error when the caller
    doesn't hold an :term:`attached thread state`.

.. c:function:: PyInterpreterWeakRef *PyInterpreterWeakRef_Dup(PyInterpreterWeakRef wref)

    Duplicate a weak reference to *wref*.

    This function is generally meant to be used in tandem with
    :c:func:`PyInterpreterWeakRef_AsStrong`.

    This function cannot fail, and the caller doesn't need to hold an
    :term:`attached thread state`.

.. c:function:: PyInterpreterRef PyInterpreterWeakRef_AsStrong(PyInterpreterWeakRef *wref)

    Return a strong reference to an interpreter from a weak reference.

    If the interpreter no longer exists or has already finished waiting for
    non-daemon threads, then this function returns ``NULL``.

    The caller does not need to hold an :term:`attached thread state`, but is
    not safe to call in a re-entrant signal handler.

    If the caller *does* hold an :term:`attached thread state`, and that thread
    state holds a strong reference to the interpreter, then this function can
    never fail.

.. c:function:: void PyInterpreterWeakRef_Close(PyInterpreterWeakRef *wref)

    Release a weak reference, possibly deallocating it.

    This function cannot fail, and the caller doesn't need to hold an
    :term:`attached thread state`.

Daemon and Non-daemon Thread States
-----------------------------------

A non-daemon thread state is a thread state that holds a strong reference to an
interpreter. The reference is released when the thread state is deleted, either
by :c:func:`PyThreadState_Release` or a different thread state deletion
function.

For backwards compatibility, all thread states created by existing APIs,
including :c:func:`PyGILState_Ensure`, will remain daemon by default.
See :ref:`pep-788-hanging-compat`.

.. c:function:: int PyThreadState_SetDaemon(int is_daemon)

    Set the :term:`attached thread state` as non-daemon or daemon.

    The attached thread state must not be the main thread for the
    interpreter. All thread states created without
    :c:func:`PyThreadState_Ensure` are daemon by default.

    If the thread state is non-daemon, then the current interpreter will wait
    for this thread to finish before shutting down by holding a strong
    reference to the interpreter (see :c:func:`PyInterpreterRef_Get`). See also
    :attr:`threading.Thread.daemon`.

    Return zero on success, non-zero *without* an exception set on failure.
    This function can only fail when setting the thread state to non-daemon.

.. c:function:: int PyThreadState_GetDaemon(int is_daemon)

    Returns non-zero if the :term:`attached thread state` is daemon,
    and zero otherwise. See also and :c:func:`PyThreadState_SetDaemon`
    and :attr:`threading.Thread.daemon`.

    This function cannot fail, other than with a fatal error if the caller
    has no :term:`attached thread state`.

Ensuring and Releasing Thread States
------------------------------------

This proposal includes two new high-level threading APIs that intend to
replace :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release`.

.. c:function:: int PyThreadState_Ensure(PyInterpreterRef ref)

    Ensure that the thread has an :term:`attached thread state` for the
    interpreter denoted by *ref*, and thus can safely invoke that
    interpreter. It is OK to call this function if the thread already has an
    attached thread state, as long as there is a subsequent call to
    :c:func:`PyThreadState_Release` that matches this one.

    Nested calls to this function will only sometimes create a new
    :term:`thread state`. If there is no :term:`attached thread state`,
    then this function will check for the most recent attached thread
    state used by this thread. If none exists or it doesn't match *ref*,
    a new thread state is created. If it does match *ref*, it is reattached.
    If there is an :term:`attached thread state`, then a similar check occurs;
    if the interpreter matches *ref*, it is attached, and otherwise a new
    thread state is created.

    The thread state attached by this function will be reused by
    subsequent calls to :c:func:`PyGILState_Ensure` in this thread, but
    :c:func:`PyGILState_Ensure` will *not* make the thread daemon again.

    The reference to the interpreter *ref* is stolen by this function.
    Use :c:func:`PyInterpreterRef_Dup` if the reference is intended to be
    kept.

    Return zero on success, and non-zero with the old attached thread state
    restored (which may have been ``NULL``).

.. c:function:: void PyThreadState_Release()

    Release a :c:func:`PyThreadState_Ensure` call.

    The :term:`attached thread state` prior to the corresponding
    :c:func:`PyThreadState_Ensure` call is guaranteed to be restored upon
    returning. The cached thread state as used by :c:func:`PyThreadState_Ensure`
    and :c:func:`PyGILState_Ensure` will also be restored.

    This function cannot fail, but may hang the thread if the
    restored :term:`attached thread state` was daemon and the interpreter
    was finalized. If you're running in a thread where that could be an issue,
    call :c:func:`PyThreadState_SetDaemon` before :c:func:`PyThreadState_Ensure`
    at your own discretion.

``threading`` Shutdown and Behavior
-----------------------------------

An interpreter currently special-cases non-daemon threads created by
:mod:`threading` and joins them before the interpreter does any other
finalization.

:mod:`threading` will be changed to use :c:func:`PyThreadState_Ensure`, and
will rely on the interpreter's strong reference to run until completion.
:mod:`threading`-created threads will still be joined to release resources after
this has happened.

Additionally, setting :attr:`threading.Thread.daemon` should
correspond to calling :c:func:`PyThreadState_SetDaemon` in C. Otherwise,
:c:func:`PyThreadState_GetDaemon` will have incorrect results in Python
threads.

Deprecation of GIL-state APIs
-----------------------------

This PEP deprecates all of the existing ``PyGILState`` APIs in favor of the
existing and new ``PyThreadState`` APIs. Namely:

- :c:func:`PyGILState_Ensure`: use :c:func:`PyThreadState_Ensure` instead.
- :c:func:`PyGILState_Release`: use :c:func:`PyThreadState_Release` instead.
- :c:func:`PyGILState_GetThisThreadState`: use :c:func:`PyThreadState_Get` or
  :c:func:`PyThreadState_GetUnchecked` instead.
- :c:func:`PyGILState_Check`: use ``PyThreadState_GetUnchecked() != NULL``
  instead.

All of the ``PyGILState`` APIs are to be removed from the non-limited C API in
Python 3.25. They will remain available in the stable ABI for compatibility.

Backwards Compatibility
=======================

This PEP specifies a breaking change with the removal of all the
``PyGILState`` APIs from the public headers of the non-limited C API in 10
years (Python 3.25).

Security Implications
=====================

This PEP has no known security implications.

How to Teach This
=================

As with all C API functions, all the new APIs in this PEP will be documented
in the C API documentation, ideally under the :ref:`python:gilstate` section.
The existing ``PyGILState`` documentation should be updated accordingly to point
to the new APIs.

Examples
--------

These examples are here to help understand the APIs described in this PEP.
Ideally, they could be reused in the documentation.

Example: A Single-threaded Ensure
*********************************

This example shows acquiring a lock in a Python method.

If this were to be called from a daemon thread, then the interpreter could
hang the thread while reattaching the thread state, leaving us with the lock
held. Any future finalizer that wanted to acquire the lock would be deadlocked!

.. code-block:: c

    static PyObject *
    my_critical_operation(PyObject *self, PyObject *unused)
    {
        assert(PyThreadState_GetUnchecked() != NULL);
        PyInterpreterRef ref = PyInterpreterRef_Get();
        /* Temporarily make this thread non-daemon to ensure that the
           lock is released. */
        if (PyThreadState_Ensure(ref) < 0) {
            PyErr_NoMemory();
            return NULL;
        }

        Py_BEGIN_ALLOW_THREADS;
        acquire_some_lock();
        Py_END_ALLOW_THREADS;

        /* Do something while holding the lock.
           The interpreter won't finalize during this period. */
        // ...

        release_some_lock();
        PyThreadState_Release();
        Py_RETURN_NONE;
    }

Example: Transitioning From the Legacy Functions
************************************************

The following code uses the ``PyGILState`` APIs:

.. code-block:: c

    static int
    thread_func(void *arg)
    {
        PyGILState_STATE gstate = PyGILState_Ensure();
        /* It's not an issue in this example, but we just attached
           a thread state for the main interpreter. If my_method() was
           originally called in a subinterpreter, then we would be unable
           to safely interact with any objects from it. */
        if (PyRun_SimpleString("print(42)") < 0) {
            PyErr_Print();
        }
        PyGILState_Release(gstate);
        return 0;
    }

    static PyObject *
    my_method(PyObject *self, PyObject *unused)
    {
        PyThread_handle_t handle;
        PyThead_indent_t indent;

        if (PyThread_start_joinable_thread(thread_func, NULL, &ident, &handle) < 0) {
            return NULL;
        }
        Py_BEGIN_ALLOW_THREADS;
        PyThread_join_thread(handle);
        Py_END_ALLOW_THREADS;
        Py_RETURN_NONE;
    }

This is the same code, rewritten to use the new functions:

.. code-block:: c

    static int
    thread_func(void *arg)
    {
        PyInterpreterRef interp = (PyInterpreterRef)arg;
        if (PyThreadState_Ensure(interp) < 0) {
            return -1;
        }
        if (PyRun_SimpleString("print(42)") < 0) {
            PyErr_Print();
        }
        PyThreadState_Release();
        return 0;
    }

    static PyObject *
    my_method(PyObject *self, PyObject *unused)
    {
        PyThread_handle_t handle;
        PyThead_indent_t indent;

        PyInterpreterRef ref = PyInterpreterRef_Get();
        if (PyThread_start_joinable_thread(thread_func, (void *)ref, &ident, &handle) < 0) {
            PyInterpreterRef_Close(ref);
            return NULL;
        }
        Py_BEGIN_ALLOW_THREADS
        PyThread_join_thread(handle);
        Py_END_ALLOW_THREADS
        Py_RETURN_NONE;
    }


Example: A Daemon Thread
************************

Native daemon threads are still a use-case, and as such,
they can still be used with this API:

.. code-block:: c

    static int
    thread_func(void *arg)
    {
        PyInterpreterRef ref = (PyInterpreterRef)arg;
        if (PyThreadState_Ensure(ref) < 0) {
            return -1;
        }
        (void)PyThreadState_SetDaemon(1);
        if (PyRun_SimpleString("print(42)") < 0) {
            PyErr_Print();
        }
        PyThreadState_Release();
        return 0;
    }

    static PyObject *
    my_method(PyObject *self, PyObject *unused)
    {
        PyThread_handle_t handle;
        PyThead_indent_t indent;

        PyInterpreterRef ref = PyInterpreterRef_Get();
        if (PyThread_start_joinable_thread(thread_func, (void *)ref, &ident, &handle) < 0) {
            PyInterpreterRef_Close(ref);
            return NULL;
        }
        Py_RETURN_NONE;
    }

Example: An Asynchronous Callback
*********************************

In some cases, the thread might not ever start, such as in a callback.
We can't use a strong reference here, because a strong reference would
deadlock the interpreter if it's not released.

.. code-block:: c

    static int
    async_callback(void *arg)
    {
        PyInterpreterWeakRef *wref = (PyInterpreterWeakRef *)arg;
        PyInterpreterRef *ref = PyInterpreterWeakRef_AsStrong(wref);
        if (ref == NULL) {
            fputs(stderr, "Python has shut down!");
            return -1;
        }

        if (PyThreadState_Ensure(ref) < 0) {
            return -1;
        }
        if (PyRun_SimpleString("print(42)") < 0) {
            PyErr_Print();
        }
        PyThreadState_Release();
        return 0;
    }

    static PyObject *
    setup_callback(PyObject *self, PyObject *unused)
    {
        // Weak reference to the interpreter. It won't wait on the callback
        // to finalize.
        PyInterpreterWeakRef *wref = PyInterpreterWeakRef_Get();
        register_callback(async_callback, wref);

        Py_RETURN_NONE;
    }

Reference Implementation
========================

A reference implementation of this PEP can be found
at `python/cpython#133110 <https://github.com/python/cpython/pull/133110>`_.

Rejected Ideas
==============

Retrofiting the Existing Structures with Reference Counts
---------------------------------------------------------

Interpreter-State Pointers for Reference Counting
*************************************************

Originally, this PEP specified :c:func:`!PyInterpreterState_Hold`
and :c:func:`!PyInterpreterState_Release` for managing strong references
to an interpreter, alongside :c:func:`!PyInterpreterState_Lookup` which
converted interpreter IDs (weak references) to strong references.

In the end, this was rejected, primarily because it was needlessly
confusing. Interpreter states hadn't ever had a reference count prior, so
there was a lack of intuition about when and where something was a strong
reference. The ``PyInterpreterRef`` and ``PyInterpreterWeakRef`` seem a lot
clearer.

Interpreter IDs for Reference Counting
**************************************

Some iterations of this API took an ``int64_t interp_id`` parameter instead of
``PyInterpreterState *interp``, because interpreter IDs cannot be concurrently
deleted and cause use-after-free violations. The reference counting APIs in
this PEP sidestep this issue anyway, but an interpreter ID have the advantage
of requiring less magic:

-  Nearly all existing interpreter APIs already return a :c:type:`PyInterpreterState`
   pointer, not an interpreter ID. Functions like
   :c:func:`PyThreadState_GetInterpreter` would have to be accompanied by
   frustrating calls to :c:func:`PyInterpreterState_GetID`.
-  Threads typically take a ``void *arg`` parameter, not an ``int64_t arg``.
   As such, passing a reference requires much less boilerplate
   for the user, because an additional structure definition or heap allocation
   would be needed to store the interpreter ID. This is especially an issue
   on 32-bit systems, where ``void *`` is too small for an ``int64_t``.
-  To retain usability, interpreter ID APIs would still need to keep a
   reference count, otherwise the interpreter could be finalizing before
   the native thread gets a chance to attach. The problem with using an
   interpreter ID is that the reference count has to be "invisible"; it
   must be tracked elsewhere in the interpreter, likely being *more*
   complex than :c:func:`PyInterpreterRef_Get`. There's also a lack
   of intuition that a standalone integer could have such a thing as
   a reference count.

.. _pep-788-activate-deactivate-instead:

Exposing an ``Activate``/``Deactivate`` API instead of ``Ensure``/``Clear``
---------------------------------------------------------------------------

In prior discussions of this API, it was
`suggested <https://discuss.python.org/t/83959/2>`_ to provide actual
:c:type:`PyThreadState` pointers in the API in an attempt to
make the ownership and lifetime of the thread state clearer:

    More importantly though, I think this makes it clearer who owns the thread
    state - a manually created one is controlled by the code that created it,
    and once it's deleted it can't be activated again.

This was ultimately rejected for two reasons:

-  The proposed API has closer usage to
   :c:func:`PyGILState_Ensure` & :c:func:`PyGILState_Release`, which helps
   ease the transition for old codebases.
-  It's `significantly easier <https://discuss.python.org/t/83959/15>`_
   for code-generators like Cython to use, as there isn't any additional
   complexity with tracking :c:type:`PyThreadState` pointers around.

Using ``PyStatus`` for the Return Value of ``PyThreadState_Ensure``
-------------------------------------------------------------------

In prior iterations of this API, :c:func:`PyThreadState_Ensure` returned a
:c:type:`PyStatus` instead of an integer to denote failures, which had the
benefit of providing an error message.

This was rejected because it's `not clear <https://discuss.python.org/t/83959/7>`_
that an error message would be all that useful; all the conceived use-cases
for this API wouldn't really care about a message indicating why Python
can't be invoked. As such, the API would only be needlessly harder to use,
which in turn would hurt the transition from :c:func:`PyGILState_Ensure`.

In addition, :c:type:`PyStatus` isn't commonly used in the C API. A few
functions related to interpreter initialization use it (simply because they
can't raise exceptions), and :c:func:`PyThreadState_Ensure` does not fall
under that category.

Open Issues
===========

.. _pep-788-deprecation:

When Should the GIL-state APIs be Removed?
------------------------------------------

:c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` have been around
for over two decades, and it's expected that the migration will be difficult.
Currently, the plan is to remove them in 10 years (opposed to the 5 years
required by :pep:`387`), but this is subject to further discussion, as it's
unclear if that's enough (or too much) time.

In addition, it's unclear whether to remove them at all. A
:term:`soft deprecation <soft deprecated>` could reasonably fit for these
functions if it's determined that a full ``PyGILState`` removal would
be too disruptive for the ecosystem.

Should ``PyThreadState_Ensure`` Steal a Reference?
--------------------------------------------------

At the moment, :c:func:`PyThreadState_Ensure` steals a reference to the
interpreter. This is controversial, because it's not necessarily the right
default.

For now, it's staying, because in cases where a reference is supposed
to be multi-use, :c:func:`PyInterpreterRef_Dup` can be used to make up
for the stolen reference. If it didn't still a reference, there's no
opposite helper function to throw away the reference, so it's just more
boilerplate. But, this is based on the assumption that there is a general
desire for single-use interpreter references. If this doesn't prove to be
the case, and a multi-use reference is overwhelmingly more common, then it
seems reasonable to let :c:func:`PyThreadState_Ensure` form its own reference
from the one passed to it.

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
