PEP: 797
Title: Shared Object Proxies for Subinterpreters
Author: Peter Bierma <peter@python.org>
Discussions-To: Pending
Status: Draft
Type: Standards Track
Created: 08-Aug-2025
Python-Version: 3.15
Post-History: `01-Jul-2025 <https://discuss.python.org/t/97306>`__


Abstract
========

This PEP introduces a new :func:`~concurrent.interpreters.share` function to
the :mod:`concurrent.interpreters` module, which allows *any* arbitrary object
to be shared across multiple interpreters, at the cost of being less efficient
under multithreaded code while accessing it.

For example::

    from concurrent import interpreters

    with open("spanish_inquisition.txt") as unshareable:
        interp = interpreters.create()
        proxy = interpreters.share(unshareable) as proxy:
        interp.prepare_main(file=proxy)
        interp.exec("file.write('I didn't expect the Spanish Inquisition')")


Background
==========

At the C level, Python interacts with objects through their
type (:c:member:`~PyObject.ob_type`). For example, to call an object,
the interpreter will access the :c:member:`~PyTypeObject.tp_call` field on the
object's type. This is where the magic of a shared object proxy can happen.

The :c:type:`!PyTypeObject` for a shared object proxy must implement
wrapping behavior for every single field on the type object structure.
So, for ``tp_call``, an object proxy must be able to "intercept" the
call in such a way where the wrapped object's ``tp_call`` slot can be executed
without thread-safety issues. This is done by switching the
:term:`attached thread state`.

In the C API, a :term:`thread state` belongs to a certain interpreter, and by
holding an attached thread state, the thread may interact with any object
belonging to its interpreter. This is because holding an attached thread state
implies things like holding the :term:`GIL`, which make object access thread-safe.

So, with that in mind, the only thing that the object proxy has to do to call
a type slot is hold an attached thread state for the object's interpreter.
This is the fundamental idea of how a shared object proxy works: allow access
from any interpreter, but switch to the wrapped object's interpreter when a type
slot is called.

Once the attached thread state has been switched to match a wrapped object's
interpreter, arguments and the return value (if it's a ``PyObject *``) of the
slot need to be shared back to the caller. This is done by first attempting to
share them natively (for example, with ``pickle``), and then falling back to
creating a new shared object proxy if all else fails. The new proxy is given
the same context as the current proxy, meaning the newly wrapped object will
be able to be freed once the :func:`~concurrent.interpreters.share` context
is closed.

Motivation
==========

Many Objects Cannot be Shared Between Subinterpreters
-----------------------------------------------------

In Python 3.14, the new :mod:`concurrent.interpreters` module can be used to
create multiple interpreters in a single Python process. This works well for
stateless code (that is, code that doesn't need any state from a caller) and
objects that can be serialized, but it is fairly common for applications to
want to use highly-complex data structures (that cannot be serialized) with
their concurrency.

Currently, :mod:`!concurrent.interpreters` can only share
:ref:`a handful of types <interp-object-sharing>` natively, and then falls back
to the :mod:`pickle` module for other types. This can be very limited, as many
types of objects cannot be pickled. For example, file objects returned by
:func:`open` cannot be serialized through ``pickle``.

Rationale
=========

A Fallback for Object Sharing
-----------------------------

A shared object proxy is designed to be a fallback for sharing an object
between interpreters, because it does not scale well under multiple threads.
As such, this PEP does not make other mechanisms for sharing objects
(namely, serialization) obsolete. A shared object proxy should only be used as
a last-resort for highly complex objects that cannot be serialized or shared
in any other way.

Specification
=============

.. class:: concurrent.interpreters.SharedObjectProxy

    A proxy type that allows access to an object across multiple interpreters.
    This cannot be constructed from Python; instead, use the
    :func:`~concurrent.interpreters.share` function.

    When interacting with the wrapped object, the proxy will switch to the
    interpreter in which the object was created. Arguments passed to anything
    on the proxy are also wrapped in a new object proxy if the type isn't
    natively shareable (so, for example, strings would not be wrapped in an
    object proxy, but file objects would). The same goes for return values.

    An object proxy does not scale well under multiple threads; there will
    be contention on locks and the :term:`GIL` if it is enabled.


.. function:: concurrent.interpreters.share(obj)

    Wrap *obj* in a :class:`~concurrent.interpreters.SharedObjectProxy`,
    allowing it to be used in other interpreter APIs as if it were natively shareable.

    For example:

    .. code-block:: python

        from concurrent import interpreters

        with open("spanish_inquisition.txt") as unshareable:
            interp = interpreters.create()
            proxy = interpreters.share(unshareable)
            interp.prepare_main(file=proxy)
            interp.exec("file.write('I didn't expect the Spanish Inquisition')")


Backwards Compatibility
=======================

This PEP has no known backwards compatibility issues.

Security Implications
=====================

This PEP has no known backwards security implications.

How to Teach This
=================

New APIs and important information about how to use them will be added to the
:mod:`concurrent.interpreters` documentation. 

Reference Implementation
========================

The reference implementation of this PEP can be found
`here <https://github.com/python/cpython/compare/main...ZeroIntensity:cpython:shared-object-proxy>`_.

Rejected Ideas
==============

Directly Sharing Proxy Objects
------------------------------

The initial revision of this proposal took an approach where an instance of
:class:`~conccurent.interpreters.SharedObjectProxy` was :term:`immortal`. This
allowed proxy objects to be directly shared across interpreters, because their
reference count was thread-safe (since it never changed due to immortality).

This proved to make the implementation significantly more complicated, and
also ended up with a lot of edge cases that would have been a burden on
CPython maintainers.

Acknowledgements
================

This PEP would not have been possible without discussion and feedback from
Eric Snow, Petr Viktorin, and Yury Selivanov.

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
