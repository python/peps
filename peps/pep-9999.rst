PEP: 9999
Title: Classes & protocols: Read-only attributes
Author: <REQUIRED: list of authors' real names and optionally, email addrs>
Sponsor: Carl Meyer <carl@oddbird.net>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Created: 18-Nov-2024
Python-Version: 3.14


Abstract
========

:pep:`705` introduced the :external+py3.13:data:`typing.ReadOnly` type qualifier
to allow defining read-only :class:`typing.TypedDict` items.

This PEP proposes expanding the scope of ``ReadOnly`` to class and protocol
attributes, as a single concise way to mark them read-only. Some parity changes
are also made to :data:`typing.Final`.

Akin to :pep:`705`, it makes no changes to setting attributes at runtime. Correct usage of
read-only attributes is intended to be enforced only by static type checkers.


Motivation
==========

The Python type system lacks a single concise way to mark an :term:`attribute` read-only.
This feature is common in other object-oriented languages (such as `C# <https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly>`_),
and is useful for restricting attribute mutation at a type checker level, as well
as defining a broad interface for structural subtyping.

.. _classes:

Classes
-------

Today, there are three major ways of achieving read-only attributes, honored by type checkers:

* annotating the attribute with :data:`typing.Final`::

    class Foo:
        number: Final[int]

        def __init__(self, number: int) -> None:
            self.number = number


    class Bar:
        def __init__(self, number: int) -> None:
            self.number: Final = number

  - Supported by :mod:`dataclasses` (and type checkers since `typing#1669 <https://github.com/python/typing/pull/1669>`_).
  - Overriding ``number`` is not possible - the specification of ``Final``
    imposes that the name cannot be overridden in subclasses.

* read-only proxy via ``@property``::

    class Foo:
        _number: int

        def __init__(self, number: int) -> None:
            self._number = number

        @property
        def number(self) -> int:
            return self._number

  - Overriding ``number`` is possible. *Type checkers disagree about the specific rules*. [#overriding_property]_
  - Read-only at runtime. [#runtime]_
  - Requires extra boilerplate.
  - Supported by :mod:`dataclasses`, but does not compose well - the synthesized
    ``__init__`` and ``__repr__`` will use ``_number`` as the parameter/attribute name.

* using a "freezing" mechanism, such as :func:`dataclasses.dataclass` or :class:`typing.NamedTuple`::

    @dataclass(frozen=True)
    class Foo:
        number: int


    class Bar(NamedTuple):
        number: int

  - Overriding ``number`` is possible in the ``@dataclass`` case.
  - Read-only at runtime. [#runtime]_
  - No per-attribute control - these mechanisms apply to the whole class.
  - Frozen dataclasses incur some runtime overhead.
  - ``NamedTuple`` is still a ``tuple``. Most classes do not need to inherit
    indexing, iteration, or concatenation.

.. _protocols:

Protocols
---------

Paraphrasing `this post <https://github.com/python/typing/discussions/1525>`_,
there is no way of defining an attribute ``name: T`` on a :class:`~typing.Protocol`, such that the only
requirements to satisfy are:

1. ``hasattr(obj, "name")``
2. ``isinstance(obj.name, T)`` [#invalid_typevar]_

The above are satisfiable at runtime by all of the following:

1. an object with an attribute ``name: T``,
2. a class with a class variable ``name: ClassVar[T]``, [#invalid_typevar]_
3. an instance of the class above,
4. an object with a ``@property`` ``def name(self) -> T``,
5. an object with a custom descriptor, such as :func:`functools.cached_property`.

Note that the attribute being marked ``Final`` or the property defining a setter
do not impact this.

The most common practice is to define such a protocol with a ``@property``::

    class HasName(Protocol):
        @property
        def name(self) -> T: ...

Type checkers special-case this definition, such that objects with plain attributes
are assignable to the type. However, instances with class variables and descriptors
other than ``property`` are rejected.

Covering the extra possibilities induces a great amount of boilerplate, involving
creation of an abstract descriptor protocol, possibly also accounting for
class and instance level overloads.
Worse yet, all of that is multiplied for each additional read-only attribute.


Rationale
=========

These problems can be resolved by an attribute-level :external+typing:term:`type qualifier`.
``ReadOnly`` has been chosen for this role, as its name conveys the intent well,
and the newly proposed changes complement its semantics defined in :pep:`705`.

A class with a read-only instance attribute can now be defined as::

    from typing import ReadOnly


    class Member:
        def __init__(self, id: int) -> None:
            self.id: ReadOnly = id

...and the protocol described in :ref:`protocols` is now just::

    from typing import Protocol, ReadOnly


    class HasName(Protocol):
        name: ReadOnly[str]


    def greet(obj: HasName, /) -> str:
        return f"Hello, {obj.name}!"

* A subclass of ``Member`` can redefine ``.id`` as a writable attribute or a
  :term:`descriptor`. It can also :external+typing:term:`narrow` the type.
* The ``HasName`` protocol can be implemented by any mechanism allowing for ``.name`` access.
* The ``greet`` function can now accept a wide variety of compatible objects,
  while being explicit about no modifications being done to the input.


Specification
=============

The :external+py3.13:data:`typing.ReadOnly` :external+typing:term:`type qualifier`
becomes a valid annotation for :term:`attributes <attribute>` of classes and protocols.
Type checkers should error on any attempt to reassign or ``del``\ ete an attribute annotated with ``ReadOnly``.

Type checkers should also error on any attempt to delete an attribute annotated as ``Final``.
(This is not currently specified.)

Akin to ``Final``, read-only attributes do not influence the mutability of
the assigned object. Immutable ABCs and containers may be used in combination with
``ReadOnly`` to prevent mutation of such values.

Syntax
------

``ReadOnly`` can be used at class-level or within ``__init__`` to mark individual
attributes read-only:

.. code-block:: python

    class Book:
        id: ReadOnly[int]

        def __init__(self, id: int, name: str) -> None:
            self.id = id
            self.name: ReadOnly = name

The explicit type in ``ReadOnly[<type>]`` can be omitted if the declaration has
an initializing value. A type checker should apply its usual type inference
rules to determine the type of ``name``.

If an attribute is already implied to be read-only, like in frozen :ref:`classes`,
explicit declarations should be permitted and seen as equivalent, except that ``Final``
additionally forbids overriding in subclasses:

.. code-block:: python

    @dataclass(frozen=True)
    class Point:
        x: ReadOnly[int]
        y: Final[int]

Initialization
--------------

Assignment to a ``ReadOnly`` attribute can only occur as a part of the declaration,
or within ``__init__`` of the same class. There is no restriction to how many
times the attribute can be assigned to.

.. code-block:: python

    from collections import abc
    from typing import ReadOnly


    class Band:
        name: str
        songs: ReadOnly[list[str]]

        def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -> None:
            self.name = name
            self.songs = []

            if songs is not None:
                # multiple assignments during initialization are fine
                self.songs = list(songs)

        def clear(self) -> None:
            # error: assignment to read-only "songs" outside initialization
            self.songs = []


    band = Band(name="BÃ´a", songs=["Duvet"])
    band.name = "Python"  # ok: "name" is not read-only
    band.songs = []  # error: "songs" is read-only
    band.songs.append("Twilight")  # ok: list is mutable


    class SubBand(Band):
        def __init__(self) -> None:
            # error: cannot assign to a read-only attribute of base class
            self.songs = []

An initializing value at a class level can serve as a `flyweight <https://en.wikipedia.org/wiki/Flyweight_pattern>`_
default for instances:

.. code-block:: python

    class Patient:
        number: ReadOnly = 0

        def __init__(self, number: int | None = None) -> None:
            if number is not None:
                self.number = number

This feature should also be supported by ``Final`` attributes. Specifically,
``Final`` attributes initialized in a class body **should no longer** imply ``ClassVar``,
and should remain assignable to within ``__init__``.

.. note::
    Classes defining :data:`~object.__slots__` cannot make use of this feature.
    An attribute with a class-level value cannot be included in slots,
    effectively making it a class variable.
    Type checkers may warn or suggest explicitly marking the attribute as a ``ClassVar``.

Type checkers should warn on read-only attributes which may be left uninitialized
after ``__init__`` exits, except in :external+typing:term:`stubs <stub>`, protocols or ABCs::

    class Patient:
        id: ReadOnly[int]    # error: "id" is not initialized on all code paths
        name: ReadOnly[str]  # error: "name" is never initialized

        def __init__(self) -> None:
            if random.random() > 0.5:
                self.id = 123


    class HasName(Protocol):
        name: ReadOnly[str]  # ok

Subtyping
---------

Read-only attributes are covariant. This has a few subtyping implications.
Borrowing from :pep:`PEP 705 <705#inheritance>`:

* Read-only attributes can be redeclared as writable attributes, descriptors
  or class variables::

    @dataclass
    class HasTitle:
        title: ReadOnly[str]


    @dataclass
    class Game(HasTitle):
        title: str
        year: int


    game = Game(title="DOOM", year=1993)
    game.year = 1994
    game.title = "DOOM II"  # ok: attribute is not read-only


    class TitleProxy(HasTitle):
        @functools.cached_property
        def title(self) -> str: ...


    class SharedTitle(HasTitle):
        title: ClassVar[str] = "Still Grey"

* If a read-only attribute is not redeclared, it remains read-only::

    @dataclass
    class Game(HasTitle):
        year: int


    game = Game(title="DOOM", year=1993)
    game.title = "DOOM II"  # error: attribute is read-only

* Subtypes can :external+typing:term:`narrow` the type of read-only attributes::

    class GameCollection(Protocol):
        games: ReadOnly[abc.Collection[Game]]


    @dataclass
    class GameSeries(GameCollection):
        name: str
        games: ReadOnly[list[Game]]  # ok: list[Game] is assignable to Collection[Game]

* Nominal subclasses of protocols and ABCs should redeclare read-only attributes
  in order to implement them, unless the base class initializes them in some way::

    class MyBase(abc.ABC):
        foo: ReadOnly[int]
        bar: ReadOnly[str] = "abc"
        baz: ReadOnly[float]

        def __init__(self, baz: float) -> None:
            self.baz = baz

        @abstractmethod
        def pprint(self) -> None: ...


    @final
    class MySubclass(MyBase):
        # error: MySubclass does not override "foo"

        def pprint(self) -> None:
            print(self.foo, self.bar, self.baz)

* In a protocol attribute declaration, ``name: ReadOnly[T]`` indicates that a structural
  subtype must support ``.name`` access, and the returned value is assignable to ``T``::

    class HasName(Protocol):
        name: ReadOnly[str]


    class NamedAttr:
        name: str

    class NamedProp:
        @property
        def name(self) -> str: ...

    class NamedClassVar:
        name: ClassVar[str]

    class NamedDescriptor:
        @cached_property
        def name(self) -> str: ...

    # all of the following are ok
    has_name: HasName
    has_name = NamedAttr()
    has_name = NamedProp()
    has_name = NamedClassVar
    has_name = NamedClassVar()
    has_name = NamedDescriptor()

Interaction with other special types
------------------------------------

``ReadOnly`` can be used with ``ClassVar`` and ``Annotated`` in any nesting order:

.. code-block:: python

    class Foo:
        foo: ClassVar[ReadOnly[str]] = "foo"
        bar: Annotated[ReadOnly[int], Gt(0)]

.. code-block:: python

    class Foo:
        foo: ReadOnly[ClassVar[str]] = "foo"
        bar: ReadOnly[Annotated[int, Gt(0)]]

This is consistent with the interaction of ``ReadOnly`` and :class:`typing.TypedDict`
defined in :pep:`705`.

``ClassVar`` excludes read-only attributes from being assignable to within
initialization methods.

Rules of ``Final`` should take priority when combined with ``ReadOnly``. As such,
type checkers may warn on the redundancy of combining the two type qualifiers.


Backwards Compatibility
=======================

This PEP introduces new contexts where ``ReadOnly`` is valid. Programs inspecting
those places will have to change to support it. This is expected to mainly affect type checkers.

However, caution is advised while using the backported ``typing_extensions.ReadOnly``
in older versions of Python. Mechanisms inspecting annotations may behave incorrectly
when encountering ``ReadOnly``; in particular, the ``@dataclass`` decorator
which `looks for <https://docs.python.org/3/library/dataclasses.html#class-variables>`_
``ClassVar`` will incorrectly treat ``ReadOnly[ClassVar[...]]`` as an instance attribute.


Security Implications
=====================

There are no known security consequences arising from this PEP.


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Open Issues
===========

Assignment in ``__new__``
-------------------------

Immutable classes like :class:`fractions.Fraction` often do not define ``__init__``;
instead, they perform initialization in ``__new__`` or classmethods. The proposed
feature won't be useful to them. 

OTOH, allowing assignment within ``__new__`` (and/or classmethods) could open way
to non-trivial bugs:

.. code-block:: python

    class Foo:
        # fully initialized objects
        object_cache: ReadOnly[ClassVar[dict[int, Self]]] = {}

        foo: ReadOnly[int]

        def __new__(cls, foo: int) -> Self:
            if foo + 1 in cls.object_cache:
                # this instance is already initialized
                self = cls.object_cache[foo + 1]

            else:
                # this instance is not
                self = super().__new__(cls)

            # assignment to an object which has been initialized before,
            # breaking the invariant a read-only attribute can be assigned to
            # only during its initialization?
            self.foo = foo

            cls.object_cache[foo] = self
            return self

To my understanding, properly detecting this problem would require type checkers
to keep track of the "level of initialization" of an object.

This issue doesn't seem to impact ``__init__``, since it's rather uncommon to
ever rebind ``self`` within it to any other object, and type checkers could
flag the action as whole.


Extending initialization
------------------------

Mechanisms such as :func:`dataclasses.__post_init__` or attrs' `initialization hooks <https://www.attrs.org/en/stable/init.html#hooking-yourself-into-initialization>`_
augment initialization by providing a set of dunder hooks which will be called
once during instance creation. The current rules would disallow assignment in those
hooks. Specifying any single method in the PEP isn't enough, as the naming and
functionality differs between mechanisms (``__post_init__`` vs ``__attrs_post_init__``).

``ReadOnly[ClassVar[...]]`` and ``__init_subclass__``
-----------------------------------------------------

Should this be allowed?

.. code-block:: python

    class URI:
        protocol: ReadOnly[ClassVar[str]] = ""

        def __init_subclass__(cls, protocol: str = "") -> None:
            cls.foo = protocol

    class File(URI, protocol="file"): ...

``Final`` in protocols
----------------------

It's been `suggested <https://discuss.python.org/t/expanding-readonly-to-normal-classes-protocols/67359/45>`_
to clarify in this PEP whether ``Final`` should be supported by protocols.


Footnotes
=========

.. [#overriding_property]
    Pyright in strict mode disallows non-property overrides.
    Mypy does not impose this restriction and allows an override with a plain attribute.
    `[Pyright playground] <https://pyright-play.net/?strict=true&code=MYGwhgzhAEBiD28BcBYAUNT0D6A7ArgLYBGApgE5LQCWuALuultACakBmO2t1d22ACgikQ7ADTQCJClVp0AlNAC0APmgA5eLlKoMzLMNEA6PETLloAXklmKjPZgACAB3LxnFOgE8mWNpylzIRF2RVUael19LHJSOnxyXGhDdhNAuzR7UEgYACEwcgEEeHkorHTKCIY0IA>`_
    `[mypy playground] <https://mypy-play.net/?mypy=latest&python=3.12&flags=strict&gist=6f860a865c5d13cce07d6cbb08b9fb85>`_

.. [#runtime]
    This PEP focuses solely on the type-checking behavior. Nevertheless, it should
    be desirable the name is read-only at runtime.

.. [#invalid_typevar]
    The implied type variable is not valid in this context; it has been used for
    the ease of demonstration. See `ClassVar <https://typing.readthedocs.io/en/latest/spec/class-compat.html#classvar>`_.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
