PEP: 9999
Title: Hexadecimal floating point literals
Author: Sergey B Kirpichev <skirpichev@gmail.com>
Sponsor: TBD
Discussions-To: https://discuss.python.org/t/41848
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 05-Jan-2024
Python-Version: 3.13
Post-History: `25-Dec-2023 <https://discuss.python.org/t/41848>`__


Abstract
========

Add hexadecimal floating point literals (IEEE 754-2008 ยง5.12.3) and support
construction of floats from hexadecimal strings.


Motivation
==========

The Python supports only decimal floating point literals.  But underlying
hardware based floating point numbers are binary, not decimal, and conversion
to and from decimal representation is delicate: it's not obvious which binary
floating point number represent a given decimal literal.

Exact floating point representations are especially important for reproducible
results --- for instance, while testing "borderline cases" in algorithms.
Because of this, many contemporary languages (e.g. C [1]_, Go [2]_, Julia [3]_,
Java [4]_) introduce hexadecimal floating point literals [5]_ in source code.
This format also common in the numerical analysis community (see e.g. [6]_ or
the MPFR library [7]_).

Lets accept exact floating point literals (beyond simple cases like ``0.25``)
as first-class citizens in the language!  Right now the Python include support
(see [8]_) for hexadecimal floats via :external+py3.12:meth:`float.fromhex` and
:external+py3.12:meth:`float.hex` methods, which extensively used in it's test
suite (e.g. to test :mod:`math` and :mod:`random` modules).  But using the
class method to create exact floating point values much less convenient,
especially doing interactive work.

This also could be used by some projects in the python ecosystem to enhance
support for multiple precision *binary* floating-point arithmetic in CLI:
hexadecimal floating point numbers now are valid tokens and can be wrapped by
an appropriate type, e.g. ``gmpy2.mpfr``.  See the `Decimal math
<https://aroberge.github.io/ideas/docs/html/decimal_math.html>`_ example on how
it's possible with decimal floating-point numbers.


Specification
=============

The :external+py3.12:token:`~python-grammar:floatnumber` production rule in the
Python grammar should accept an additional alternative
:token:`~python-grammar:hexfloat` with the following lexical definition:

.. productionlist:: python-grammar
   hexfloat: ("0x | "0X") ["_"] (`hexdigitpart` | `hexpointfloat`) [`binexponent`]
   hexpointfloat: [`hexdigit`] `hexfraction` | `hexdigitpart` "."
   hexfraction: "." `hexdigitpart`
   digitpart: `digit` (["_"] `digit`)*
   hexdigitpart: `hexdigit` (["_"] `hexdigit`)*
   binexponent: ("p" | "P") ["+" | "-"] `digitpart`

The exponent of a hexadecimal floating point literal is written in decimal, and
it gives the power of 2 by which to multiply the coefficient.

Underscores are acceptable only between digits and after base specifier.

The :class:`float` constructor should accept string input with the
:external+py3.12:token:`~float:floatnumber` production rule, that has an
addtidional alternative :token:`~float:hexfloatnumber`:

.. productionlist:: float
   hexfloatnumber: `~python-grammar:hexinteger` | `~python-grammar:hexpointfloat` | `~python-grammar:hexfloat`

In other words, it should accept any input that is currently accepted by
:external+py3.12:meth:`float.fromhex` method (with ``0x/0X`` prefix being
mandatory), but also allow grouping digits with underscores.


Backwards Compatibility
=======================

New literal syntax introduce a clash with attribute access on hexadecimal
integer literals (e.g. ``0x1.bit_count``), which can be workarounded by putting
braces around the literal (like ``(1).bit_count()``, as it's now required for a
decimal integer).

Now this will issue a :exc:`SyntaxWarning`, which eventually become a
:exc:`SyntaxError`.


How to Teach This
=================

The "Floating point literals" [9]_ section of the Language Reference and the
documentation of the :external+py3.12:class:`float` builtin in the Library
Reference will be expanded to include new syntax rules.


Reference Implementation
========================

A feature-complete CPython implementation is available on Github:
https://github.com/skirpichev/cpython/tree/hex-floatlit


Open Issues
===========

Note also, that new capabilities of the :class:`float` constructor essentially
make the :external+py3.12:meth:`float.fromhex` method redundant (the only
difference is that it doesn't require the hexadecimal base specifier).  The
later could be considered as deprecated.

Maybe it also worth discussing support for binary floating point literals (in a
similar format as above, like the MPFR does [7]_).  (Together with some string
formatting support in this format.)  This is much less useful from the
practical point of view, but might have education value.


Footnotes
=========

.. [1] since C99, see ยง 6.4.4.2 of the ISO/IEC 9899:1999

.. [2] https://go.dev/ref/spec#Floating-point_literals

.. [3] https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers

.. [4] Java 1.5 onwards, see https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.10.2

.. [5] A hexadecimal floating point constant is just a shorthand for binary
       scientific notation, when the mantissa part is written in base-16.

.. [6] https://hal.science/hal-00128124v5

.. [7] https://www.mpfr.org/mpfr-4.2.1/mpfr.html#index-mpfr_005fstrtofr

.. [8] https://bugs.python.org/issue3008

.. [9] https://docs.python.org/3.12/reference/lexical_analysis.html#floating-point-literals


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
