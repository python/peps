PEP: 9999
Title: Limiting deletions on PyPI
Author: William Woodruff <william@yossarian.net>,
        Alexis Challande <alexis.challande@trailofbits.com>
Sponsor: Donald Stufft <donald@stufft.io>
PEP-Delegate: Donald Stufft <donald@stufft.io>
Discussions-To: TODO
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 07-Oct-2024
Post-History: `09-Jul-2022 <https://discuss.python.org/t/stop-allowing-deleting-things-from-pypi/17227>`__,
              `01-Oct-2024 <https://discuss.python.org/t/pre-pep-limiting-deletions-on-pypi/66351>`__

Abstract
========

This PEP proposes limiting user-level deletions of projects (including release-
and file-level deletions) on PyPI, in favor of the "yanking" mechanism
adopted by PyPI with :pep:`592`.

In particular, the PEP proposes a time-based deletion criterion via
which projects (and their releases and files) are protected from *deletion*
after an initial grace period of 72 hours following their creation.

This PEP does not propose changes to administrator-initiated deletions (e.g.
for moderation or security purposes).

Rationale and Motivation
========================

As observed in :pep:`592`, user-level deletion of projects on PyPI
enables a `Catch-22 <https://www.merriam-webster.com/dictionary/catch-22>`_
of dependency breakage:

    Whenever a project detects that a particular release on PyPI might be broken,
    they oftentimes will want to prevent further users from inadvertently using that
    version. However, the obvious solution of deleting the existing file from a
    repository will break users who have followed recommended practices and pinned to a
    specific version of the project.

    This leaves projects in a catch-22 situation where new projects may be pulling
    down this known broken version, but if they do anything to prevent that theyâ€™ll
    break projects that are already using it.

On a technical level, the problem of deletion is addressed by
"yanking," also specified in :pep:`592`. However, deletions continue to be
allowed on PyPI, and have caused multiple notable disruptions to the Python
ecosystem over the interceding years:

* July 2022: `atomicwrites <https://pypi.org/project/atomicwrites/>`_
  was `deleted by its maintainer <https://github.com/untitaker/python-atomicwrites/issues/61>`_
  in an attempt to remove the project's "critical" designation, without the
  maintainer realizing that project deletion would also delete all previously
  uploaded versions.

  The project was subsequently restored with the maintainer's consent,
  but at the cost of manual administrator action and extensive downstream
  breakage to projects like `pytest <https://github.com/pytest-dev/pytest/issues/10114>`_.
  As of October 2024, atomicwrites is archived but still has
  around `4.5 million monthly downloads from PyPI <https://pypistats.org/packages/atomicwrites>`_.

* June 2023: `python-sonarqube-api <https://pypi.org/project/python-sonarqube-api/>`_
  deleted all released versions prior to 2.0.2, which was both a breaking
  change version *and* was accompanied by a paid "Professional Edition".

  The project's maintainer subsequently
  `deleted conversations <https://discuss.python.org/t/stop-allowing-deleting-things-from-pypi/17227/114>`_
  and force-pushed over the tag history for `python-sonarqube-api`'s source repository,
  impeding efforts by the community to compare changes between versions
  and obtain previous, permissively-licensed versions.

* June 2024: `PySimpleGUI <https://pypi.org/project/PySimpleGUI/>`_ changed
  licenses from LGPL to a commercial license, and deleted
  `nearly all previous versions <https://discuss.python.org/t/48790/27>`_.
  This resulted in disruption for users, who (prior
  to the relicensing) were downloading PySimpleGui
  approximately 25,000 times a day. This deletion also impeded efforts
  by the community to provide "continuity" projects, as the
  permissively-licensed artifacts were no longer available for reference
  and re-uploading.

In addition to their disruptive effect on downstreams, deletions
also have deleterious effects on PyPI's sustainability as well as the overall
security of the ecosystem:

* Deletions raise the baseline support load for PyPI's administrators and
  moderators, as users mistakenly file support requests believing that PyPI
  is broken, or that the administrators themselves have removed the
  project.

* Deletions impair incident response and external analysis, making it
  difficult to distinguish "good faith" maintainer behavior from malicious
  post-exploitation track-covering.

The size and interdependency of the Python ecosystem is continuing to grow,
meaning that future deletions of projects can be reasonably assumed to
be *just as if not more* disruptive than the deletions sampled above.

Given the above, this PEP concludes that the availability of "hard" deletions
versus "soft" deletions (i.e. yanking) now presents more of a risk and detriment
to the Python ecosystem than a benefit.

Specification
=============

This PEP identifies 3 different types of deletable objects:

1. **Files**, which are individual project distributions (such as source
   distributions or wheels).

   Example: ``requests-2.32.3-py3-none-any.whl``.

2. **Versions**, which contain one or more files that share the same version.

   Example: `requests v2.32.3 <https://pypi.org/project/requests/2.32.3/>`_.

3. **Projects**, which contain one or more versions.

   Example: `requests <https://pypi.org/project/requests>`_.

This PEP proposes the following *deletion eligibility rules*:

* A **file** is considered deletable if and only if it was uploaded to
  PyPI less than 72 hours from the current time.
* A **release** is considered deletable if and only if all of its
  constituent files are deletable.
* A **project** is considered deletable if and only if all of its
  constituent releases are deletable.

These rules are intentionally "telescoping": they allow new projects to be
deleted entirely, and allow old projects to delete new files or releases,
but do not allow old projects to delete old files or releases.

This is intended to strike a balance between competing interests: brand new
projects are unlikely to have significant community uptake and thus pose a
minimal disruptive risk, while established projects (even smaller ones)
are more likely to have a "tail" of adopted versions whose communities
or maintainers are not necessarily equipped to address the sudden deletion
of a version or file.

Implementation
==============

Security Implications
=====================

This PEP does not identify any positive or negative security implications
associated with proposed approach.

Rejected Ideas
==============

Conditioning deletion on dependency relationships
-------------------------------------------------

An alternative to time-based deletion windows is deletion eligibility based on
downstream dependents. For example, a release could be considered deletable
if and only if it has fewer than ``N`` downstream dependents on PyPI,
where ``N`` could be as low as 1.

This idea is appealing, since it directly links deletion eligibility to
disruptiveness. `NPM <https://www.npmjs.com/>`_ has adopted it for this reason,
conditioning project removal on the absence of any downstream dependencies
known to the index.

Despite its appeal, this PEP identifies several disadvantages and technical
limitations that make dependency-conditioned deletion not appropriate
for PyPI:

1. *PyPI is not aware of dependency relationships.* In Python packaging,
   both project builds *and* metadata generation are frequently dynamic
   operations, involving arbitrary project-specified code. This is typified
   by source distributions containing ``setup.py`` scripts, where the execution
   of ``setup.py`` is responsible for computing the set of dependencies
   encoded in the project's metadata.

   This is in marked contrast to ecosystems like NPM and Rust's
   `crates <https://crates.io/>`_, where project *builds* can be dynamic but
   the project's metadata itself is static.

   As a result of this,
   `PyPI doesn't know your project's dependencies <https://dustingram.com/articles/2018/03/05/why-pypi-doesnt-know-dependencies/>`_,
   and is architecturally incapable of knowing them without either running
   arbitrary code (a significant security risk) or performing a long-tail
   deprecation of ``setup.py``-based builds in favor of :pep:`517` and
   :pep:`621`-style static metadata.

2. *Results in an unintuitive permissions model.* Dependency-conditioned
   deletion results in a "reversed" power relationship, where anybody
   who introduces a dependency on a project can prevent that project from
   being deleted.

   This is reasonable on face value, but can be abused to produce unexpected
   and undesirable (in the context of enabling some deletions) outcomes.
   A notable example of this is NPM's
   `everything package <https://www.npmjs.com/package/everything>`_, which
   depends on every public package on NPM (as of 30-Dec-2023) and thereby
   prevents their deletion.


Conditioning deletion on download count
---------------------------------------

TODO

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
