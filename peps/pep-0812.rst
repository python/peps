PEP: 812
Title: Immutable variables with const keyword
Author: Michael Voznesensky <mvoz@google.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 31-Oct-2025

Abstract
========

Today, python variables are wonderfully mutable - this is a super power of the language. However, in larger codebases, or more complex implementations, there is often a need to mark a variable as immutable. This is useful in two major ways, the first of which is general to programming, and not specific to python - assurances of objects staying identical for their lifetimes is a powerful hint to both the programmer, and the compiler. Potential compiler opitmizations aside, ``const`` hints ignal to programmers that the original author of the code intended this object not to change, which, like c++'s ``const`` corectness ideas, promotes safety and readability. Potential general programming benefits aside, a far more specific python "Gotcha", is mutable defaults.

This PEP proposes a ``const`` keyword that can be inserted in function arguments, defaults, and in scopes that declares an object as immutable.

Proposal
========

A ``const`` keyword that applies to functions, class attributes, and variables.

Motivation
==========

To elaborate on the cases above, consider the following code::

    def add_item_to_cart(item, cart=[]):
        """
        Adds an item to a user's cart.
        If no cart is provided, starts a new one.
        """
        cart.append(item)
        return cart

cart is evaluated *once* when the function is defined - this means that a second caller appending to the cart is going to see the first item, and so forth, - a common mistake.

Or::

    def analyze_latest_scores(current_scores):
        original_order = current_scores
        current_scores.sort(reverse=True)
        return {
            "top_score": current_scores[0],
            "first_entry": original_order[0]
        }

It looks like we are saving a snapshot of the data as it came in... but .sort() modifies the list *in-place*. Because 'original_order' is just a reference to 'current_scores', the returned "first_entry" field is will be the top score, not the first entry!

And, aside from these edge cases of mutability, just general readability and safety added to python.

What does ``const`` mean?
=========================

There are two tiers of ``const``-ness - this proposal pushes for the strictest version of it.

Less restrictive - ``const`` only forbids rebinding
---------------------------------------------------

In this variant of ``const``, we limit it to mean rebinding. It is closer spiritually to "final" in certain other languages.

.. code-block:: python

    const x = []
    x = {}  # Fails, no rebinding allowed, raises

However::

    const x = []
    x.append(1)  # Sound, allowed, as the name `x` stays the same type and object, it merely got mutated

In this case, theres not much to do with function arguments, except catch shadowing as an exception.
In this case, the mutable default problem presented above is not resolved.

More restrictive - ``const`` forbids direct mutation
----------------------------------------------------

.. code-block:: python

    const x = []
    x = {}  # Fails, no rebinding allowed, raises

And::

    const x = []
    x.append(1)  # Fails, modifying the object declared as const, illegal

And::

    class MyWidget:
        x: int

        def update(self, x):
            self.x = x

    m = MyWidget()
    m.update(1)  # 1, sound
    m.update(2)  # 2, sound
    const n = MyWidget()
    n.update(1)  # Fails, updating a const

Variables marked as ``const`` cannot be updated, and raise upon updated

Usage
=====

There are three primary uses of the ``const`` keyword proposed here:

* On function arguments
* On attributes and fields classes
* On variables

On function arguments
---------------------

An argument marked as ``const``, be it an arg or a kwarg, functions exactly as if you were to define a local variable at the top of the function as ``const``. It cannot be modified, and the object it refers to cannot be updated or written to in any way. It can only be passed to functions that also expect it as "``const``" - that is, you cannot erase ``const``ness once it is applied. It can be copied out to a non ``const`` variable, and that is the proposed analogue of ``const_cast`` here, the only way to un-``const`` something is via a copy.

Shadowing a name becomes an exception.

.. code-block:: python

    def foo(const bar, baz):
        bar = 3  # Fails, raises on shadowing
        return bar * baz

.. code-block:: python

    def boo(bat, bat):
        ...

    def foo(const bar, baz):
        boo(bar, bar)  # Fails, raises on passing bar to boo's bat, which is not `const`
        ...

On attributes and fields in classes
-----------------------------------

This makes the attribute only writable at __init__ time - or assignable with a default. It is illegal to modify a ``const`` variable after.

.. code-block:: python

    class MyWidget:
        const x: int

        def update(self, x):
            self.x = x  # Fails, always raises, x is const

On variables
------------

Mostly covered above, but either a local or global can be declared ``const``, and enforces renaming and update semantics described above.

Can only be passed functions where the argument is marked ``const``.
