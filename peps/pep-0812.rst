PEP: 812 Title: Immutable variables with const keyword Author: Michael Voznesensky <mvoz@google.com> 
Type: Standards Track

# Abstract

Today, python variables are wonderfully mutable - this is a super power of the language. However, in larger codebases, or more complex implementations, there is often a need to mark a variable as immutable. This is useful in two major ways, the first of which is general to programming, and not specific to python - assurances of objects staying identical for their lifetimes is a powerful hint to both the programmer, and the compiler. Potential compiler opitmizations aside, `const` hints ignal to programmers that the original author of the code intended this object not to change, which, like c++'s `const` corectness ideas, promotes safety and readability. Potential general programming benefits aside, a far more specific python "Gotcha", is mutable defaults.

This PEP proposes a `const` keyword that can be inserted in function arguments, defaults, and in scopes that declares an object as immutable.

# Proposal

A `const` keyword that applies to functions, class attributes, and variables. 

# Motivation

To elaborate on the cases above, consider the following code:

```
def add_item_to_cart(item, cart=[]):
    """
    Adds an item to a user's cart.
    If no cart is provided, starts a new one.
    """
    cart.append(item)
    return cart
```
cart is evaluated *once* when the function is defined - this means that a second caller appending to the cart is going to see the first item, and so forth, - a common mistake.

Or 

```
def analyze_latest_scores(current_scores):
    original_order = current_scores
    current_scores.sort(reverse=True)
    return {
        "top_score": current_scores[0],
        "first_entry": original_order[0] # Bug: This will be the top score, not the first entry
    }
```
It looks like we are saving a snapshot of the data as it came in... but .sort() modifies the list *in-place*. Because 'original_order' is just a reference to 'current_scores', the returned "first_entry" field is will be the top score, not the first entry! 

And, aside from these edge cases of mutability, just general readability and safety added to python.

# What does `const` mean?

There are two tiers of `const`-ness - this proposal pushes for the strictest version of it.

## Less restrictive - `const` only forbids rebinding

In this variant of `const`, we limit it to mean rebinding. It is closer spiritually to "final" in certain other languages.

```
`const` x = []
x = {} # Fails, no rebinding allowed, raises
```
However:
```
`const` x = []
x.append(1) # Sound, allowed, as the name `x` stays the same type and object, it merely got mutated
```
In this case, theres not much to do with function arguments, except catch shadowing as an exception.
In this case, the mutable default problem presented above is not resolved. 

## More restrictive - `const` forbids direct mutation

```
`const` x = []
x = {} # Fails, no rebinding allowed, raises
```
And:
```
`const` x = []
x.append(1) # Fails, modifying the object declared as `const`, illegal
```
And
```
class MyWidget:
  x: int 
  
  def update(self, x):
    self.x = x

m = MyWidget()
m.update(1) # 1, sound
m.update(2) # 2, sound 
`const` n = MyWidget()
n.update(1) # Fails, updating a `const` 
```
Variables marked as `const` cannot be updated, and raise upon updated 

# Usage

There are three primary uses of the `const` keyword proposed here:

- On function arguments
- On attributes and fields classes
- On variables 

## On function arguments

An argument marked as `const`, be it an arg or a kwarg, functions exactly as if you were to define a local variable at the top of the function as `const`. It cannot be modified, and the object it refers to cannot be updated or written to in any way. It can only be passed to functions that also expect it as "`const`" - that is, you cannot erase `const`ness once it is applied. It can be copied out to a non `const` variable, and that is the proposed analogue of `const`_cast here, the only way to un-`const` something is via a copy. 

Shadowing a name becomes an exception.

```
def foo(`const` bar, baz):
  bar = 3 # Fails, raises on shadowing
  return bar * baz
```

```
def boo(bat, bat):
  ... 

def foo(`const` bar, baz):
   boo(bar, bar) # Fails, raises on passing bar to boo's bat, which is not `const`
   ...
```

## On attributes and fields in classes

This makes the attribute only writable at __init__ time - or assignable with a default. It is illegal to modify a `const` variable after. 

```
class MyWidget:
  `const` x: int 
  
  def update(self, x):
    self.x = x # Fails, always raises, x is `const`

```

## On variables

Mostly covered above, but either a local or global can be declared `const`, and enforces renaming and update semantics described above.

Can only be passed functions where the argument is marked `const`.

# Compiler benefits

## Globals

If the compiler knows a global is const, it can bake its value directly into the bytecode of functions that use it, rather than emitting a LOAD_GLOBAL instruction.
```
DEBUG = False
def foo():
    if DEBUG:
        ...
    if DEBUG:
        ...
```
Looks like:
```
Disassembly of <code object foo at 0x561367afd590, file "example.py", line 2>:
  2           RESUME                   0

  3           LOAD_GLOBAL              0 (DEBUG)
              TO_BOOL
              POP_JUMP_IF_FALSE        1 (to L1)

  4           NOP

  5   L1:     LOAD_GLOBAL              0 (DEBUG)
              TO_BOOL
              POP_JUMP_IF_FALSE        1 (to L2)

  6           RETURN_CONST             0 (None)

  5   L2:     RETURN_CONST             0 (None)
```
Today, when, you could store the value once and skip the LOAD_GLOBALS, as well as the control flow (in this case). Further static analysis features could then kick in to mark the dead branch as dead.

## Class safety / MRO optimization

If a class method is marked const, the compiler knows it will never be overridden by a subclass or shadowed by an instance attribute.
When you call my_obj.const_method(), the compiler doesn't need to check the instance dictionary or walk the MRO. It can compile a direct call to that exact function object.

## Guarding Jits

JITs that rely on guards (Cpython jit, torchdynamo, etc) could emit less guards 

# Non compiler benefits

Cleaner, more readable code.

Stronger invariants at a language level.


