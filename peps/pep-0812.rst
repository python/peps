PEP: 812
Title: Immutable variables with const keyword
Author: Michael Voznesensky <mvoz@google.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 31-Oct-2025

Abstract
========

Today, python variables are wonderfully mutable - this is a super power of the language. However, in larger codebases, or more complex implementations, there is often a need to mark a variable as immutable. This is useful in two major ways, the first of which is general to programming, and not specific to python - assurances of objects staying identical for their lifetimes is a powerful hint to both the programmer, and the compiler. Potential compiler opitmizations aside, ``const`` hints ignal to programmers that the original author of the code intended this object not to change, which, like c++'s ``const`` corectness ideas, promotes safety and readability. Potential general programming benefits aside, a far more specific python "Gotcha", is mutable defaults.

This PEP proposes a ``const`` keyword that can be inserted in function arguments, defaults, and in scopes that declares an object as immutable.

Proposal
========

A ``const`` keyword that applies to functions, class attributes, and variables.

Motivation
==========

To elaborate on the cases above, consider the following code::

    def add_item_to_cart(item, cart=[]):
        """
        Adds an item to a user's cart.
        If no cart is provided, starts a new one.
        """
        cart.append(item)
        return cart

cart is evaluated *once* when the function is defined - this means that a second caller appending to the cart is going to see the first item, and so forth, - a common mistake.

Or::

    def analyze_latest_scores(current_scores):
        original_order = current_scores
        current_scores.sort(reverse=True)
        return {
            "top_score": current_scores[0],
            "first_entry": original_order[0]
        }

It looks like we are saving a snapshot of the data as it came in... but .sort() modifies the list *in-place*. Because 'original_order' is just a reference to 'current_scores', the returned "first_entry" field is will be the top score, not the first entry!

And, aside from these edge cases of mutability, just general readability and safety added to python.

What does ``const`` mean?
=========================

There are two tiers of ``const``-ness - this proposal pushes for the strictest version of it.

Less restrictive - ``const`` only forbids rebinding
---------------------------------------------------

In this variant of ``const``, we limit it to mean rebinding. It is closer spiritually to "final" in certain other languages.

.. code-block:: python

    const x = []
    x = {}  # Fails, no rebinding allowed, raises

However::

    const x = []
    x.append(1)  # Sound, allowed, as the name `x` stays the same type and object, it merely got mutated

In this case, theres not much to do with function arguments, except catch shadowing as an exception.
In this case, the mutable default problem presented above is not resolved.

More restrictive - ``const`` forbids direct mutation
----------------------------------------------------

.. code-block:: python

    const x = []
    x = {}  # Fails, no rebinding allowed, raises

And::

    const x = []
    x.append(1)  # Fails, modifying the object declared as const, illegal

And::

    class MyWidget:
        x: int

        def update(self, x):
            self.x = x

    m = MyWidget()
    m.update(1)  # 1, sound
    m.update(2)  # 2, sound
    const n = MyWidget()
    n.update(1)  # Fails, updating a const

Variables marked as ``const`` cannot be updated, and raise upon updated

Usage
=====

There are three primary uses of the ``const`` keyword proposed here:

* On function arguments
* On attributes and fields classes
* On variables

Function Arguments
------------------

An argument marked as ``const`` (whether a positional argument or a keyword argument) functions exactly as if a local variable were defined at the top of the function as ``const``.

Key behaviors include:

*   **Immutability**: The variable cannot be modified, and the object it refers to cannot be updated or written to in any way.
*   **Transitive Constness**: A ``const`` argument can only be passed to other functions that also expect it as ``const``. You cannot erase "constness" once it is applied.
*   **Explicit Copying**: It can be copied out to a non-``const`` variable. This is the proposed analogue to C++'s ``const_cast``; the only way to "un-const" something is via a copy.

Reassignment and Shadowing
^^^^^^^^^^^^^^^^^^^^^^^^^^


Shadowing or reassigning a ``const`` name is treated as an exception.

.. code-block:: python

   def foo(const bar, baz):
       bar = 3  # Fails, raises on reassignment/shadowing
       return bar * baz

When passing a ``const`` variable to another function, the receiving function's arguments must also be marked ``const``.

.. code-block:: python

   # Standard function with mutable arguments
   def boo(bat, man):
       ...

   def foo(const bar, baz):
      boo(bar, baz) # Fails: raises on passing 'bar' to boo's 'bat',
                    # because 'bat' is not marked 'const'.
      ...

Class Attributes and Fields
---------------------------

Marking an attribute as ``const`` makes it writable only at ``__init__`` time (or assignable via a default value). It is illegal to modify a ``const`` attribute after initialization.

.. code-block:: python

   class MyWidget:
       const x: int

       def update(self, x):
           self.x = x # Fails: always raises as 'self.x' is const

Variables
---------

As covered in previous sections, both local and global variables can be declared ``const``. This enforces the renaming and update semantics described above.

Critically, these variables can only be passed to functions where the corresponding argument is also marked ``const``.

Benefits
========

Compiler Benefits
-----------------

Globals Optimization
^^^^^^^^^^^^^^^^^^^^

If the compiler knows a global is ``const``, it can bake its value directly into the bytecode of functions that use it, rather than emitting ``LOAD_GLOBAL`` instructions.

Consider the following standard Python code:

.. code-block:: python

   DEBUG = False
   def foo():
       if DEBUG:
           ...
       if DEBUG:
           ...

Currently, this results in repeated ``LOAD_GLOBAL`` instructions and runtime checks:

.. code-block:: text

   Disassembly of <code object foo at 0x561367afd590, file "example.py", line 2>:
     2           RESUME                   0

     3           LOAD_GLOBAL              0 (DEBUG)
                 TO_BOOL
                 POP_JUMP_IF_FALSE        1 (to L1)

     4           NOP

     5   L1:     LOAD_GLOBAL              0 (DEBUG)
                 TO_BOOL
                 POP_JUMP_IF_FALSE        1 (to L2)

     6           RETURN_CONST             0 (None)

     5   L2:     RETURN_CONST             0 (None)

With a ``const`` global, the compiler can store the value once, skip the ``LOAD_GLOBAL`` opcodes, and potentially use static analysis to identify and remove the dead branches entirely.

Class Safety and MRO Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If a class method is marked ``const``, the compiler guarantees it will never be overridden by a subclass or shadowed by an instance attribute.

When calling ``my_obj.const_method()``, the compiler does not need to check the instance dictionary or walk the Method Resolution Order (MRO). It can compile a direct call to that exact function object.

JIT Guard Reduction
~~~~~~~~~~~~~~~~~~~
JIT compilers that rely on guards (such as CPython's JIT, torchdynamo, etc.) can emit fewer guards, as the invariants provided by ``const`` reduce the number of state changes that need monitoring.

Non-Compiler Benefits
---------------------

*   **Readability**: Code becomes cleaner and easier to reason about.
*   **Invariants**: Provides stronger invariants at the language level, reducing classes of bugs related to accidental mutation.


Back-compat
===========

Should be entirely sound - except for cases where someone is using ``const`` as a variable name. This should become a SyntaxError, which should be relatively trivial to fix, and can be detected entirely statically (linting, etc).


Implementation / Open questions 
===============================

Note - this section needs further exploration and is a WIP. 

Basics
------
The implementation would require adding const to the python grammar, updating the ast, and all other language level structures that handle keywords.

Less restrictive / phase 1
--------------------------
The first phase, rebinding, (or, breaking rebinding, aka, the final keyword like work described above) - seems relatively straightforward. Bytecodes used for assignment (store_fast, etc) - would be extended to look up our const tagging and fail according to the descriptions above.   


Frozen objects / phase 2
------------------------
For the second phase, more akin to a frozen object, we would need to come up with new bytecodes that set flags that propagate the constness of the object to the underlying implementation. I think we would start with builtin types (PyList, PyDict) and start exploring intercessions into functions like PyList_Append to respect the constness of the object.


Viral constness / phase 3
-------------------------
Viral constness seems tricky to implement, as it would incur a type check on every function call with const keywords in it. 

