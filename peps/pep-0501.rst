PEP: 501
Title: General purpose template literal strings
Author: Alyssa Coghlan <ncoghlan@gmail.com>, Nick Humrich <nick@humrich.us>
Discussions-To: https://discuss.python.org/t/pep-501-reopen-general-purpose-string-template-literals/24625
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Requires: 701
Created: 08-Aug-2015
Python-Version: 3.12
Post-History: `08-Aug-2015 <https://mail.python.org/archives/list/python-dev@python.org/thread/EAZ3P2M3CDDIQFR764NF6FXQHWXYMKJF/>`__,
              `05-Sep-2015 <https://mail.python.org/archives/list/python-dev@python.org/thread/ILVRPS6DTFZ7IHL5HONDBB6INVXTFOZ2/>`__,
              `09-Mar-2023 <https://discuss.python.org/t/pep-501-reopen-general-purpose-string-template-literals/24625>`__,

.. TODO: Start new PEP 501 d.p.o thread once these updates have been merged

Abstract
========

Though easy and elegant to use, Python :term:`f-string`\s
can be vulnerable to injection attacks when used to construct
shell commands, SQL queries, HTML snippets and similar
(for example, ``os.system(f"echo {message_from_user}")``).
This PEP introduces template literal strings (or "t-strings"),
which have the same syntax and semantics but with rendering deferred
until :func:`format` or another template rendering function is called on them.
This will allow standard library calls, helper functions
and third party tools to safety and intelligently perform
appropriate escaping and other string processing on inputs
while retaining the usability and convenience of f-strings.


Relationship with other PEPs
============================

This PEP is inpired by and builds on top of the f-string syntax first implemented
in :pep:`498` and formalised in :pep:`701`.

This PEP complements the literal string typing support added to Python's formal type
system in :pep:`675` by introducing a *safe* way to do dynamic interpolation of runtime
values into security sensitive strings.

This PEP competes with some aspects of the tagged string proposal in :pep:`750`
(most notably in whether template rendering is expressed as `render(t"template literal")`
or as `render"template literal"`), but also shares *many* common features (after :pep:`750`
was published, this PEP was updated with
`several new changes <https://github.com/python/peps/issues/3904>`__
inspired by the tagged strings proposal).

This PEP does NOT propose an alternative to :pep:`292` for user interface
internationalization use cases (but does note the potential for future syntactic
enhancements aimed at that use case that would benefit from the compiler-support
value interpolation machinery that this PEP and :pep:`750` introduce).


Motivation
==========

:pep:`498` added new syntactic support for string interpolation that is
transparent to the compiler, allowing name references from the interpolation
operation full access to containing namespaces (as with any other expression),
rather than being limited to explicit name references. These are referred
to in the PEP as "f-strings" (a mnemonic for "formatted strings").

Since acceptance of :pep:`498`, f-strings have become well-established and very popular.
F-strings became even more useful and flexible with the formalised grammar in :pep:`701`.
While f-strings are great, eager rendering has its limitations. For example, the
eagerness of f-strings has made code like the following unfortunately plausible:

.. code-block:: python

    os.system(f"echo {message_from_user}")

This kind of code is superficially elegant, but poses a significant problem
if the interpolated value ``message_from_user`` is in fact provided by an
untrusted user: it's an opening for a form of code injection attack, where
the supplied user data has not been properly escaped before being passed to
the ``os.system`` call.

While the `LiteralString` type annotation introduced in :pep:`675` means that typecheckers
are able to report a type error for this kind of unsafe function usage, those errors don't
help make it easier to write code that uses safer alternatives (such as `subprocess.run`).

To address that problem (and a number of other concerns), this PEP proposes
the complementary introduction of "t-strings" (a mnemonic for "template literal strings"),
where ``format(t"Message with {data}")`` would produce the same result as
``f"Message with {data}"``, but the interpolation template instance could instead be passed
to other template rendering functions which processed the contents of the template
differently.


Proposal
========

Dedicated template literal syntax
---------------------------------

This PEP proposes a new string prefix that declares the
string to be a template literal rather than an ordinary string:

.. code-block:: python

    template = t"Substitute {names:>{field_width}} and {expressions()!r} at runtime"

This would be effectively interpreted as:

.. code-block:: python

    template = TemplateLiteral(
        r"Substitute {names:>{field_width}} and {expressions()} at runtime",
        TemplateLiteralText(r"Substitute "),
        TemplateLiteralField("names", names, f">{field_width}", ""),
        TemplateLiteralText(r" and "),
        TemplateLiteralField("expressions()", expressions(), f"", "r"),
    )

(Note: this is an illustrative example implementation. The exact compile time construction
syntax of ``types.TemplateLiteral`` is considered an implementation detail not specified by
the PEP. In particular, the compiler may bypass the default constructor's runtime logic that
detects consecutive text segments and merges them into a single text segment)

The ``__format__`` method on ``types.TemplateLiteral`` would then
implement the following :meth:`str.format` inspired semantics:

.. code-block:: python-console

  >>> import datetime
  >>> name = 'Jane'
  >>> age = 50
  >>> anniversary = datetime.date(1991, 10, 12)
  >>> format(t'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.')
  'My name is Jane, my age next year is 51, my anniversary is Saturday, October 12, 1991.'
  >>> format(t'She said her name is {name!r}.')
  "She said her name is 'Jane'."

The syntax of template literals would be based on :pep:`701`, and largely use the same
syntax for the string portion of the template. Aside from using a different prefix, the one
other syntactic change is in the definition and handling of conversion specifiers, both to
allow `!()` as a standard conversion specifier to request evaluation of a field at
rendering time, and to allow custom renderers to also define custom conversion specifiers.

This PEP does not propose to remove or deprecate any of the existing
string formatting mechanisms, as those will remain valuable when formatting
strings that are not present directly in the source code of the application.


Lazy field evaluation conversion specifier
------------------------------------------

In addition to the existing support for ``a``, ``r``, and ``s`` conversion specifiers,
``str.format`` and ``str.format_map`` will be updated to accept ``()`` as a conversion
specifier that means "call the interpolated value".

To support application of the standard conversion specifiers in custom template rendering
functions, a new ``operator.convert_field`` function will be added:

.. code-block:: python

    def convert_field(value, conversion_spec=''):
        """Apply the given string formatting conversion specifier to the given value"""
        match conversion_spec:
            case '':
                return value
            case 'a':
                return ascii(value)
            case 'r':
                return repr(value)
            case 's':
                return str(value)
            case '()':
                return value()
        err = f"Invalid conversion specifier {conversion_spec!r}: expected '', 'a', 'r', 's' or '()'"
        raise ValueError(err)

The signature and behaviour of the ``format`` builtin will also be updated:

.. code-block:: python

    def format(value, format_spec='', conversion_spec=''):
        if conversion_spec:
            value_to_format = operator.convert_field(value)
        else:
            value_to_format = value
        return type(value_to_format).__format__(value, format_spec)

If a non-empty conversion specifier is given, the value  will be converted with
``operator.convert_field`` before looking up the ``__format__`` method.


Background
==========

This PEP was initially proposed as a competitor to :pep:`498`. After it became clear that
the eager rendering proposal had sustantially more immediate support, it then spent several
years in a deferred state, pending further experience with :pep:`498`'s simpler approach of
only supporting eager rendering without the additional complexity of also supporting deferred
rendering.

Since then, f-strings have become very popular and :pep:`701` was introduced to tidy up some
rough edges and limitations in their syntax and semantics. The template literal proposal
was updated in 2023 to reflect current knowledge of f-strings, and improvements from
:pep:`701`.

In 2024, :pep:`750` was published, proposing a general purpose mechanism for custom tagged
string prefixes, rather than the narrower template literal proposal in this PEP. This PEP
was again updated, both to incorporate new ideas inspired by the tagged strings proposal,
and to describe the perceived benefits of the narrower template literal syntax proposal
in this PEP over the more general tagged string proposal.


Summary of differences from f-strings
-------------------------------------

The key differences between f-strings and t-strings are:

* the ``t`` (template literal) prefix indicates delayed rendering, but
  otherwise largely uses the same syntax and semantics as formatted strings
* template literals are available at runtime as a new kind of object
  (``types.TemplateLiteral``)
* the default rendering used by formatted strings is invoked on a
  template literal object by calling ``format(template)`` rather than
  being done implicitly in the compiled code
* unlike f-strings (where conversion specifiers are handled directly in the compiler),
  t-string conversion specifiers are handled at rendering time by the rendering function
* the new ``!()`` conversion specifier indicates that the field expression is a callable
  that should be called when using the default ``format`` rendering function. This specifier
  is specifically *not* being added to f-strings (since it is pointless there).
* while  f-string ``f"Message {here}"`` would be *semantically* equivalent to
  ``format(t"Message {here}")``, f-strings will continue to be supported directly in the
  compiler and hence avoid the runtime overhead of actually using the delayed rendering
  machinery that is needed for t-strings


Summary of differences from tagged strings
------------------------------------------

When tagged strings were
`first proposed <https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408>`__,
there were several notable differences from the proposal in PEP 501 beyond the surface
syntax difference between whether rendering function invocations are written as
`render(t"template literal")` or as `render"template literal"`.

Over the course of the initial PEP 750 discussion, many of those differences were eliminated,
either by PEP 501 adopting that aspect of PEP 750's proposal (such as lazily applying
conversion specifiers), or by PEP 750 changing to retain some aspect of PEP 501's proposal
(such as defining a dedicated type to hold template segments rather than representing them
as simple sequences).

The main remaining significant difference is that this PEP argues that adding *only* the
t-string prefix is a sufficient enhancement to give all the desired benefits described in
PEP 750. The expansion to a generalised "tagged string" syntax isn't necessary, and causes
additional problems that can be avoided.

The two PEPs also differ in their proposed approaches to handling lazy evaluation of template
fields.

While there *are* other differences between the two proposals, those differences are more
cosmetic than substantive. In particular:

* this PEP proposes different names for the structural typing protocols
* this PEP proposes specific names for the concrete implementation types
* this PEP proposes exact details for the proposed APIs of the concrete implementation types
  (including concatenation and repetition support, which are not part of the structural
  typing protocols)
* this PEP proposes changes to the existing ``format`` builtin to make it usable directly as
  template field renderer


Rationale
=========

F-strings (:pep:`498`) made interpolating values into strings with full access to Python's
lexical namespace semantics simpler, but it does so at the cost of creating a
situation where interpolating values into sensitive targets like SQL queries,
shell commands and HTML templates will enjoy a much cleaner syntax when handled
without regard for code injection attacks than when they are handled correctly.

This PEP proposes to provide the option of delaying the actual rendering
of a template literal to a formatted string to its ``__format__`` method, allowing the use
of other template renderers by passing the template around as a first class object.

While very different in the technical details, the
``types.TemplateLiteral`` interface proposed in this PEP is
conceptually quite similar to the ``FormattableString`` type underlying the
`native interpolation <https://msdn.microsoft.com/en-us/library/dn961160.aspx>`__
support introduced in C# 6.0, as well as the
`JavaScript template literals <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals>`__
introduced in ES6.

While not the original motivation for developing the proposal, many of the benefits for
defining domain specific languages described in :pep:`750` also apply to this PEP
(including the potential for per-DSL semantic highlighting in code editors based on the
type specifications of declared template variables and rendering function parameters).


Specification
=============

This PEP proposes a new ``t`` string prefix that
results in the creation of an instance of a new type,
``types.TemplateLiteral``.

Template literals are Unicode strings (bytes literals are not
permitted), and string literal concatenation operates as normal, with the
entire combined literal forming the template literal.

The template string is parsed into literals, expressions, format specifiers, and conversion
specifiers as described for f-strings in :pep:`498` and :pep:`701`. The syntax for conversion
specifiers is relaxed such that arbitrary strings are accepted (excluding those containing
``{``, ``}`` and ``:``) rather than being restricted to valid Python identifiers.

However, rather than being rendered directly into a formatted string, these
components are instead organised into instances of new types with the
following behaviour:

.. code-block:: python

    class TemplateLiteralText(str):
        # This is a renamed and extended version of the DecodedConcrete type in PEP 750
        # Real type would be implemented in C, this is an API compatible Python equivalent
        _raw: str

        def __new__(cls, raw: str):
            decoded = raw.encode("utf-8").decode("unicode-escape")
            if decoded == raw:
                decoded = raw
            text = super().__new__(cls, decoded)
            text._raw = raw
            return text

        @property
        def raw(self) -> str:
            return self._raw

        def __repr__(self) -> str:
            return f"{type(self).__name__(r{self._raw!r})}"

        def __add__(self, other:Any) -> TemplateLiteralText|NotImplemented:
            if isinstance(other, TemplateLiteralText):
                return TemplateLiteralText(self._raw + other._raw)
            return NotImplemented


        def __mul__(self, other:Any) -> TemplateLiteralText|NotImplemented:
            try:
                factor = operator.index(other)
            except TypeError:
                return NotImplemented
            return TemplateLiteralText(self._raw * factor)
        __rmul__ = __mul__

        @staticmethod
        def merge(text_segments:Sequence[TemplateLiteralText]) -> TemplateLiteralText:
            return TemplateLiteralText("".join(t._raw for t in text_segments))

    class TemplateLiteralField(NamedTuple):
        # This is mostly a renamed version of the InterpolationConcrete type in PEP 750
        # However:
        #    - value is eagerly evaluated (values were all originally lazy in PEP 750)
        #    - conversion specifiers are allowed to be arbitrary strings
        #    - order of fields is adjusted so the text form is the first field and the
        #      remaining parameters match the updated signature of the `*format` builtin
        # Real type would be implemented in C, this is an API compatible Python equivalent

        expr: str
        value: Any
        format_spec: str | None = None
        conversion_spec: str | None = None

        def __repr__(self) -> str:
            return (f"{type(self).__name__}({self.expr}, {self.value!r}, "
                    f"{self.format_spec!r}, {self.conversion_spec!r})")

        def __str__(self) -> str:
            return format(self.value, self.format_spec, self.conversion_spec)

        def __format__(self, format_override) -> str:
            if format_override:
                format_spec = format_override
            else:
                format_spec = self.format_spec
            return format(self.value, format_spec, self.conversion_spec)

    class TemplateLiteral:
        # This type corresponds to the TemplateConcrete type in PEP 750
        # Real type would be implemented in C, this is an API compatible Python equivalent
        _raw_template: str
        _segments = tuple[TemplateLiteralText|TemplateLiteralField]

        def __new__(cls, raw_template:str, *segments:TemplateLiteralText|TemplateLiteralField):
            self = super().__new__(cls)
            self._raw_template = raw_template
            # Ensure any consecutive runs of text fields are merged together
            merged_segments:list[TemplateLiteralText|TemplateLiteralField] = []
            pending_merge:list[TemplateLiteralText] = []
            for segment in segments:
                match segment:
                    case TemplateLiteralText() as text_segment:
                        pending_merge.append(text_segment)
                    case TemplateLiteralField():
                        if pending_merge:
                            merged_segments.append(TemplateLiteralText.merge(pending_merge))
                            pending_merge.clear()
                        merged_segments.append(segment)
                    case _:
                        raise TypeError("Template literal segments must be template literal text or field instances")
            if pending_merge:
                merged_segments.append(TemplateLiteralText.merge(pending_merge))
                pending_merge.clear()
            self._segments = tuple(merged_segments)
            return self

        @property
        def raw_template(self) -> str:
            return self._raw_template

        @property
        def segments(self) -> tuple[TemplateLiteralText|TemplateLiteralField]:
            return self._segments

        def __len__(self) -> int:
            return len(self._segments)

        def __iter__(self) -> Iterable[TemplateLiteralText|TemplateLiteralField]:
            return iter(self._segments)

        # Note: template literals do NOT define any relative ordering
        def __eq__(self, other):
            if not isinstance(other, TemplateLiteral):
                return NotImplemented
            return (
                self._raw_template == other._raw_template
                and self._segments == other._segments
                and self.field_values == other.field_values
                and self.format_specifiers == other.format_specifiers
            )

        def __repr__(self) -> str:
            return (f"{type(self).__name__}(r{self._raw!r}, "
                    f"{', '.join(map(repr, self._segments))})")

        def __format__(self, format_specifier) -> str:
            # When formatted, render to a string, and then use string formatting
            return format(self.render(), format_specifier)

        def render(self, *, render_template=''.join, render_text=str, render_field=format):
            ...  # See definition of the template rendering semantics below

        def __add__(self, other) -> TemplateLiteral|NotImplemented:
            if isinstance(other, TemplateLiteral):
                combined_raw_text = self._raw + other._raw
                combined_segments = self._segments + other._segments
                return TemplateLiteral(combined_raw_text, *combined_segments)
            if isinstance(other, str):
                # Treat the given string as a new raw text segment
                combined_raw_text = self._raw + other
                combined_segments = self._segments + (TemplateLiteralText(other),)
                return TemplateLiteral(combined_raw_text, *combined_segments)
            return NotImplemented

        def __radd__(self, other) -> TemplateLiteral|NotImplemented:
            if isinstance(other, str):
                # Treat the given string as a new raw text segment. This will likely never
                # run in practice due to https://github.com/python/cpython/issues/55686,
                # but it at least makes the *intended* behaviour in this case clear.
                combined_raw_text = other + self._raw
                combined_segments = (TemplateLiteralText(other),) + self._segments
                return TemplateLiteral(combined_raw_text, *combined_segments)
            return NotImplemented

        def __mul__(self, other) -> TemplateLiteral|NotImplemented:
            try:
                factor = operator.index(other)
            except TypeError:
                return NotImplemented
            if not self or factor == 1:
                return self
            if factor < 1:
                return TemplateLiteral("")
            repeated_text = self._raw_template * factor
            repeated_segments = self._segments * factor
            return TemplateLiteral(repeated_text, *repeated_segments)
        __rmul__ = __mul__

(Note: this is an illustrative example implementation, the exact compile time construction
method and internal data management details of ``types.TemplateLiteral`` are considered an
implementation detail not specified by the PEP. However, the expected post-construction
behaviour of the public APIs on ``types.TemplateLiteral`` instances is specified by the
above code, as is the constructor signature for building template instances at runtime)

The result of a template literal expression is an instance of this
type, rather than an already rendered string â€” rendering only takes
place when the instance's ``render`` method is called (either directly, or
indirectly via ``__format__``).

The compiler will pass the following details to the template literal for
later use:

* a string containing the raw template as written in the source code
* a sequence of template segments, with each segment being either:

  * a literal text segment (a regular Python string that also provides access
    to its raw form)
  * a parsed template interpolation field, specifying the text of the interpolated
    expression (as a regular string), its evaluated result, the format specifier text
    (with any substitution fields eagerly evaluated as an f-string), and the conversion
    specifier text (as a regular string)

The raw template is just the template literal as a string. By default,
it is used to provide a human-readable representation for the
template literal, but template renderers may also use it for other purposes (e.g. as a
cache lookup key).

The parsed template structure is taken from :pep:`750` and consists of a sequence of
template segments corresponding to the text segments and interpolation fields in the
template string.

This approach is designed to allow compilers to fully process each segment of the template
in order, before finally emitting code to pass all of the template segments to the template
literal constructor.

For example, assuming the following runtime values:

.. code-block:: python

    names = ["Alice", "Bob", "Carol", "Eve"]
    field_width = 10
    def expressions():
        return 42

The template from the proposal section would be represented at runtime as:

.. code-block:: python

    TemplateLiteral(
        r"Substitute {names:>{field_width}} and {expressions()!r} at runtime",
        TemplateLiteralText(r"Substitute "),
        TemplateLiteralField("names", ["Alice", "Bob", "Carol", "Eve"], ">10", ""),
        TemplateLiteralText(r" and "),
        TemplateLiteralField("expressions()", 42, "", "r"),
    )


Rendering templates
-------------------

The ``TemplateLiteral.render`` implementation defines the rendering
process in terms of the following renderers:

* an overall ``render_template`` operation that defines how the sequence of
  rendered text and field segments are composed into a fully rendered result.
  The default template renderer is string concatenation using ``''.join``.
* a per text segment ``render_text`` operation that receives the individual literal
  text segments within the template. The default text renderer is the builtin ``str``
  constructor.
* a per field segment ``render_field`` operation that receives the field value, format
  specifier, and conversion specifier for substitution fields within the template. The
  default field renderer is the ``format`` builtin.

Given the parsed template representation above, the semantics of template rendering would
then be equivalent to the following:

.. code-block:: python

    def render(self, *, render_template=''.join, render_text=str, render_field=format):
        rendered_segments = []
        for segment in self._segments:
            match segment:
                case TemplateLiteralText() as text_segment:
                    rendered_segments.append(render_text(text_segment))
                case TemplateLiteralField() as field_segment:
                    rendered_segments.append(render_field(*field_segment[1:]))
        return render_template(rendered_segments)


Format specifiers
----------------

The syntax and processing of field specifiers in t-strings is defined to be the same as it
is for f-strings.

This includes allowing field specifiers to themselves contain f-string substitution fields.
The raw text of the field specifiers (without processing any substitution fields) is
retained as part of the full raw template string.

The parsed field specifiers receive the field specifier string with those substitutions
already resolved. The `:` prefix is also omitted.

Aside from separating them out from the substitution expression during parsing,
format specifiers are otherwise treated as opaque strings by the interpolation
template parser - assigning semantics to those (or, alternatively,
prohibiting their use) is handled at rendering time by the field renderer.


Conversion specifiers
---------------------

Where :pep:`701` restricts conversion specifiers to ``NAME`` tokens, this PEP will instead
allow ``FSTRING_MIDDLE`` tokens (such that only ``{``, ``}`` and ``:`` are disallowed). This
change is made primarily to support lazy field rendering with the ``!()`` conversion
specifier, but also allows custom rendering functions more flexibility when defining their
own conversion specifiers in preference to those defined for the default ``format`` field
renderer.

Conversion specifiers are still handled as plain strings, and do NOT support the use
of substitution fields.

The parsed conversion specifiers receive the conversion specifier string with the
`!` prefix omitted.

To allow custom template renderers to define their own custom conversion specifiers, the
check for known conversion specifiers only takes place at rendering time (unlike f-strings,
the use of known conversion specifiers is NOT enforced by the compiler).

As described above, the default rendering supports the original ``!a``, ``!r`` and ``!s``
conversion specifiers defined in :pep:`3101`, together with the new `!()` lazy field
evaluation conversion specifier defined in this PEP.

The changes to the `format` builtin and the addition of `operator.convert_field` make it
straightforward for custom renderers to also support the standard conversion specifiers.

f-strings themselves will NOT support the new `!()` conversion specifier (as it is redundant
when value interpolation and value rendering always occur at the same time).


Structural typing and duck typing
---------------------------------

To allow custom renderers to accept alternative interpolation template implementations,
the following structural protocols will be added to the ``typing`` module:

.. code-block:: python

    @runtime_checkable
    class TemplateText(Protocol):
        # Renamed version of PEP 750's Decoded protocol
        def __str__(self) -> str:
            ...

        raw: str

    @runtime_checkable
    class TemplateField(Protocol):
        # Renamed and modified version of PEP 750's Interpolation protocol
        def __len__(self):
            ...

        def __getitem__(self, index: int):
            ...

        def __str__(self) -> str:
            ...

        expr: str
        value: Any
        format_spec: str | None = None
        conversion_spec: str | None = None

    @runtime_checkable
    class InterpolationTemplate(Protocol):
        # Corresponds to PEP 750's Template protocol
        def __iter__(self) -> Iterable[TemplateText|TemplateField]:
            ...

        raw_template: str

Note that the structural protocol APIs are substantially narrower than the full
implementation APIs defined for ``TemplateLiteralText``, ``TemplateLiteralField``,
and ``TemplateLiteral``.

Code that wants to accept interpolation templates and define specific handling for them
without introducing a dependency on the ``typing`` module, or restricting the code to
handling the concrete template literal types, should instead perform an attribute
existence check on ``raw_template``.


Writing custom renderers
------------------------

Writing a custom renderer doesn't require any special syntax. Instead,
custom renderers are ordinary callables that process an interpolation
template directly either by calling the ``render()`` method with alternate
``render_template``, ``render_text``, and/or ``render_field`` implementations, or by
accessing the template's data attributes directly.

For example, the following function would render a template using objects'
``repr`` implementations rather than their native formatting support:

.. code-block:: python

    def repr_format(template):
        def render_field(value, format_spec, conversion_spec):
            converted_value = operator.convert_field(value, conversion_spec)
            return format(repr(converted_value), specifier)
        return template.render(render_field=render_field)

The customer renderer shown respects the conversion specifiers in the original template, but
it is also possible to ignore them and render the interpolated values directly:

.. code-block:: python

    def input_repr_format(template):
        def render_field(value, format_spec, __):
            return format(repr(value), specifier)
        return template.render(render_field=render_field)

When writing custom renderers, note that the return type of the overall
rendering operation is determined by the return type of the passed in ``render_template``
callable. While this will still be a string for formatting related use cases, producing
non-string objects *is* permitted. For example, a custom SQL
template renderer could involve an ``sqlalchemy.sql.text`` call that produces
an `SQL Alchemy query object <http://docs.sqlalchemy.org/en/rel_1_0/core/tutorial.html#using-textual-sql>`__.
A subprocess invocation related template renderer could produce a string sequence suitable
for passing to ``subprocess.run``, or it could even call ``subprocess.run`` directly, and
return the result.

Non-strings may also be returned from ``render_text`` and ``render_field``, as long as
they are paired with a ``render_template`` implementation that expects that behaviour.

Customer renderers using the pattern matching style described in PEP 750 are also supported:

.. code-block:: python

    # Use the structural typing protocols rather than the concrete implementation types
    from typing import InterpolationTemplate, TemplateText, TemplateField

    def greet(template: InterpolationTemplate) -> str:
        """Render an interpolation template using structural pattern matching."""
        result = []
        for segment in template:
            match segment:
                match segment:
                    case TemplateText() as text_segment:
                        result.append(text_segment)
                    case TemplateField() as field_segment:
                        result.append(str(field_segment).upper())
        return f"{''.join(result)}!"


Expression evaluation
---------------------

As with f-strings, the subexpressions that are extracted from the interpolation
template are evaluated in the context where the template literal
appears. This means the expression has full access to local, nonlocal and global variables.
Any valid Python expression can be used inside ``{}``, including
function and method calls.

Because the substitution expressions are evaluated where the string appears in
the source code, there are no additional security concerns related to the
contents of the expression itself, as you could have also just written the
same expression and used runtime field parsing:

.. code-block:: python-console


  >>> bar=10
  >>> def foo(data):
  ...   return data + 20
  ...
  >>> str(t'input={bar}, output={foo(bar)}')
  'input=10, output=30'

Is essentially equivalent to:

.. code-block:: python-console

  >>> 'input={}, output={}'.format(bar, foo(bar))
  'input=10, output=30'


Handling code injection attacks
-------------------------------

The :pep:`498` formatted string syntax makes it potentially attractive to write
code like the following:

.. code-block:: python

    runquery(f"SELECT {column} FROM {table};")
    runcommand(f"cat {filename}")
    return_response(f"<html><body>{response.body}</body></html>")

These all represent potential vectors for code injection attacks, if any of the
variables being interpolated happen to come from an untrusted source. The
specific proposal in this PEP is designed to make it straightforward to write
use case specific renderers that take care of quoting interpolated values
appropriately for the relevant security context:

.. code-block:: python

    runquery(sql(t"SELECT {column} FROM {table} WHERE column={value};"))
    runcommand(sh(t"cat {filename}"))
    return_response(html(t"<html><body>{response.body}</body></html>"))

This PEP does not cover adding all such renderers to the standard library
immediately (though one for shell escaping is proposed), but rather proposes to ensure
that they can be readily provided by third party libraries, and potentially incorporated
into the standard library at a later date.

Over time, it is expected that APIs processing potentially dangerous string inputs may be
updated to accept interpolation templates natively, allowing problematic code examples to
be fixed simply by replacing the ``f`` string prefix with a ``t``:

.. code-block:: python

    runquery(t"SELECT {column} FROM {table};")
    runcommand(t"cat {filename}")
    return_response(t"<html><body>{response.body}</body></html>")

It is proposed that a renderer is included in the :mod:`shlex` module, aiming to offer a
more POSIX shell style experience for accessing external programs, without the significant
risks posed by running ``os.system`` or enabling the system shell when using the
``subprocess`` module APIs. This renderer will provide an interface for running external
programs inspired by that offered by the
`Julia programming language <https://docs.julialang.org/en/v1/manual/running-external-programs/>`__,
only with the backtick based ``\`cat $filename\``` syntax replaced by ``t"cat {filename}"``
style template literals. See more in the :ref:`501-shlex-module` section.


Error handling
--------------

Either compile time or run time errors can occur when processing interpolation
expressions. Compile time errors are limited to those errors that can be
detected when parsing a template string into its component tuples. These
errors all raise SyntaxError.

Unmatched braces:

.. code-block:: python-console

  >>> t'x={x'
    File "<stdin>", line 1
        t'x={x'
           ^
  SyntaxError: missing '}' in template literal expression

Invalid expressions:

.. code-block:: python-console

  >>> t'x={!x}'
    File "<fstring>", line 1
      !x
      ^
  SyntaxError: invalid syntax

Run time errors occur when evaluating the expressions inside a
template string before creating the template literal object. See :pep:`498`
for some examples.

Different renderers may also impose additional runtime
constraints on acceptable interpolated expressions and other formatting
details, which will be reported as runtime exceptions.


.. _501-shlex-module:

Renderer for shell escaping added to shlex
==========================================

As a reference implementation, a renderer for safe POSIX shell escaping can be added to
the :mod:`shlex` module. This renderer would be called ``sh`` and would be equivalent to
calling ``shlex.quote`` on each field value in the template literal.

Thus:

.. code-block:: python

  os.system(shlex.sh(t'cat {myfile}'))

would have the same behavior as:

.. code-block:: python

  os.system('cat ' + shlex.quote(myfile)))

The implementation would be:

.. code-block:: python

  def sh(template: TemplateLiteral):
      return template.render(render_field=quote)


Changes to subprocess module
============================

With the additional renderer in the shlex module, and the addition of template literals,
the :mod:`subprocess` module can be changed to handle accepting template literals
as an additional input type to ``Popen``, as it already accepts a sequence, or a string,
with different behavior for each.

With the addition of template literals, :class:`subprocess.Popen` (and in return, all its
higher level functions such as :func:`~subprocess.run`) could accept strings in a safe way.

For example:

.. code-block:: python

  subprocess.run(t'cat {myfile}', shell=True)

would automatically use the ``shlex.sh`` renderer provided in this PEP. Therefore, using
``shlex`` inside a ``subprocess.run`` call like so:

.. code-block:: python

  subprocess.run(shlex.sh(t'cat {myfile}'), shell=True)

would be redundant, as ``run`` would automatically render any template literals
through ``shlex.sh``


Alternatively, when ``subprocess.Popen`` is run without ``shell=True``, it could still
provide subprocess with a more ergonomic syntax. For example:

.. code-block:: python

  subprocess.run(t'cat {myfile} --flag {value}')

would be equivalent to:

.. code-block:: python

  subprocess.run(['cat', myfile, '--flag', value])

or, more accurately:

.. code-block:: python

  subprocess.run(shlex.split(f'cat {shlex.quote(myfile)} --flag {shlex.quote(value)}'))

It would do this by first using the ``shlex.sh`` renderer, as above, then using
``shlex.split`` on the result.

The implementation inside ``subprocess.Popen._execute_child`` would look like:

.. code-block:: python

  if hasattr(args, "raw_template"):
    import shlex
    if shell:
      args = [shlex.sh(args)]
    else:
      args = shlex.split(shlex.sh(args))


Possible integration with the logging module
============================================

One of the challenges with the logging module has been that we have previously
been unable to devise a reasonable migration strategy away from the use of
printf-style formatting. The runtime parsing and interpolation overhead for
logging messages also poses a problem for extensive logging of runtime events
for monitoring purposes.

While beyond the scope of this initial PEP, template literal support
could potentially be added to the logging module's event reporting APIs,
permitting relevant details to be captured using forms like:

.. code-block:: python

    logging.debug(t"Event: {event}; Details: {data}")
    logging.critical(t"Error: {error}; Details: {data}")

Rather than the historical mod-formatting style:

.. code-block:: python

    logging.debug("Event: %s; Details: %s", event, data)
    logging.critical("Error: %s; Details: %s", event, data)

(While the logging module does allow formatters to specify the use of ``str.format``
or ``string.Template`` style substitution, it can be awkward to ensure that messages
written that way are only ever processed by log record formatters that are expecting that
syntax)

As the template literal is passed in as an ordinary argument, other
keyword arguments would also remain available:

.. code-block:: python

    logging.critical(t"Error: {error}; Details: {data}", exc_info=True)

The approach to standardising lazy field evaluation described in this PEP is
primarily based on the anticipated needs of this hypothetical integration into
the logging module:

.. code-block:: python

    logging.debug(t"Eager evaluation of {expensive_call()}")
    logging.debug(t"Lazy evaluation of {expensive_call!()}")

    logging.debug(t"Eager evaluation of {expensive_call_with_args(x, y, z)}")
    logging.debug(t"Lazy evaluation of {(lambda: expensive_call_with_args(x, y, z))!()}")

It's an open question whether the definition of logging formatters would be updated to
support template strings, but if they were, the most likely way of defining fields which
should be :ref:`looked up on the log record <logrecord-attributes>` instead of being
interpreted eagerly is simply to escape them so they're available as part of the literal
text:

.. code-block:: python

    proc_id = get_process_id()
    formatter = logging.Formatter(t"{{asctime}}:{proc_id}:{{name}}:{{levelname}}{{message}}")


Discussion
==========

Refer to :pep:`498` for previous discussion, as several of the points there
also apply to this PEP. :pep:`750`'s design discussions are also highly relevant,
as that PEP inspired several aspects of the current design.

# TODO: review each of the discussion points in light of the PEP 750 inspired changes,
#       and add any new discussion points for comparison to that PEP

Support for binary interpolation
--------------------------------

As f-strings don't handle byte strings, neither will t-strings.

Interoperability with str-only interfaces
-----------------------------------------

For interoperability with interfaces that only accept strings, interpolation
templates can still be prerendered with ``format``, rather than delegating the
rendering to the called function.

This reflects the key difference from :pep:`498`, which *always* eagerly applies
the default rendering, without any way to delegate the choice of renderer to
another section of the code.

Preserving the raw template string
----------------------------------

Earlier versions of this PEP failed to make the raw template string available
on the template literal. Retaining it makes it possible to provide a more
attractive template representation, as well as providing the ability to
precisely reconstruct the original string, including both the expression text
and the details of any eagerly rendered substitution fields in format specifiers.

Creating a rich object rather than a global name lookup
-------------------------------------------------------

Earlier versions of this PEP used an ``__interpolate__`` builtin, rather than
a creating a new kind of object for later consumption by interpolation
functions. Creating a rich descriptive object with a useful default renderer
made it much easier to support customisation of the semantics of interpolation.

Building atop f-strings rather than replacing them
--------------------------------------------------

Earlier versions of this PEP attempted to serve as a complete substitute for
:pep:`498` (f-strings) . With the acceptance of that PEP and the more recent :pep:`701`,
this PEP can now build a more flexible delayed rendering capability
on top of the existing f-string eager rendering.

Assuming the presence of f-strings as a supporting capability simplified a
number of aspects of the proposal in this PEP (such as how to handle substitution
fields in format specifiers)

Deferring consideration of possible use in i18n use cases
---------------------------------------------------------

The initial motivating use case for this PEP was providing a cleaner syntax
for i18n translation, as that requires access to the original unmodified
template. As such, it focused on compatibility with the substitution syntax used
in Python's ``string.Template`` formatting and Mozilla's l20n project.

However, subsequent discussion revealed there are significant additional
considerations to be taken into account in the i18n use case, which don't
impact the simpler cases of handling interpolation into security sensitive
contexts (like HTML, system shells, and database queries), or producing
application debugging messages in the preferred language of the development
team (rather than the native language of end users).

Due to the original design of the ``str.format`` substitution syntax in :pep:`3101` being inspired by C#'s string formatting syntax, the specific field
substitution syntax used in :pep:`498` is consistent not only with Python's own ``str.format`` syntax, but also with string formatting in C#, including the
native "$-string" interpolation syntax introduced in C# 6.0 (released in July
2015).  The related ``IFormattable`` interface in C# forms the basis of a
`number of elements <https://msdn.microsoft.com/en-us/library/system.iformattable.aspx>`__ of C#'s internationalization and localization
support.

This means that while this particular substitution syntax may not
currently be widely used for translation of *Python* applications (losing out
to traditional %-formatting and the designed-specifically-for-i18n
``string.Template`` formatting), it *is* a popular translation format in the
wider software development ecosystem (since it is already the preferred
format for translating C# applications).

Acknowledgements
================

* Eric V. Smith for creating :pep:`498` and demonstrating the feasibility of
  arbitrary expression substitution in string interpolation
* Barry Warsaw, Armin Ronacher, and Mike Miller for their contributions to
  exploring the feasibility of using this model of delayed rendering in i18n
  use cases (even though the ultimate conclusion was that it was a poor fit,
  at least for current approaches to i18n in Python)

References
==========

* `%-formatting
  <https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting>`_

* `str.format
  <https://docs.python.org/3/library/string.html#formatstrings>`_

* `string.Template documentation
  <https://docs.python.org/3/library/string.html#template-strings>`_

* :pep:`215`: String Interpolation

* :pep:`292`: Simpler String Substitutions

* :pep:`3101`: Advanced String Formatting

* :pep:`498`: Literal string formatting

* :pep:`675`: Arbitrary Literal String Type

* :pep:`701`: Syntactic formalization of f-strings

* `FormattableString and C# native string interpolation
  <https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated>`_

* `IFormattable interface in C# (see remarks for globalization notes)
  <https://docs.microsoft.com/en-us/dotnet/api/system.iformattable>`_

* `TemplateLiterals in Javascript
  <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals>`_

* `Running external commands in Julia
  <https://docs.julialang.org/en/v1/manual/running-external-programs/>`_

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
