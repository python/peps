PEP: 751
Title: A file format to record Python dependencies for installation reproducibility
Author: Brett Cannon <brett@python.org>
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 24-Jul-2024
Post-History:
  `25-Jul-2024 <https://discuss.python.org/t/59173>`__
  `30-Oct-2024 <https://discuss.python.org/t/69721>`__
Replaces: 665

========
Abstract
========

This PEP proposes a new file format for dependency specification
to enable reproducible installation in a Python environment. The format is
designed to be human-readable and machine-generated. Installers consuming the
file should be able to calculate what to install without the need for dependency
resolution at install-time.


==========
Motivation
==========

Currently, no standard exists to create an immutable record, such as a lock
file, which specifies what direct and indirect dependencies should be installed
into a virtual environment.

Considering there are at least five well-known solutions to this problem in the
community (PDM_, ``pip freeze``, pip-tools_, Poetry_, and uv_), there seems to
be an appetite for lock files in general.

Those tools also vary in what locking scenarios they support. For instance,
``pip freeze`` and pip-tools only generate lock files for the current
environment while PDM, Poetry, and uv can/try to lock for multiple environments
at once. There's also concerns around the lack of secure defaults in the face of
supply chain attacks (e.g., always including hashes for files).

The lack of a standard also has some drawbacks. For instance, any tooling that
wants to work with lock files must choose which format to support, potentially
leaving users unsupported (e.g., Dependabot_ only supporting select tools,
same for cloud providers who can do dependency installations on your behalf,
etc.). It also impacts portability between tools, which causes vendor lock-in.
By not having compatibility and interoperability it fractures tooling around
lock files where both users and tools have to choose what lock file format to
use upfront and making it costly to use/switch to other formats. Rallying
around a single format removes that cost/barrier.

The closest the community has to a standard are pip's `requirements files`_
which all the aforementioned tools either use directly as their file format or
export to (i.e. ``requirements.txt``). Unfortunately the format is not a
standard but is supported by convention. It's also designed very much for pip's
needs, limiting its flexibility and ease of use (e.g., it's a bespoke file
format). Lastly, it is not secure by default (e.g., file hash support is
entirely an opt-in feature, you have to tell pip to not look for external
dependencies instead of the file encoding such details, etc.).

.. note::

   Much of the motivation from :pep:`665` also applies to this PEP.


=========
Rationale
=========

The file format is designed to be human-readable. This is so that the contents
of the file can be audited by a human to make sure no undesired dependencies end
up being included in the lock file.

The file format is also designed to not require a resolver at install time. This
greatly simplifies reasoning about what would be installed when consuming a lock
file. It should also lead to faster installs which are much more frequent than
creating a lock file.

The data in the file should be consumable by tools not written in Python. This
allows for e.g., clould hosting providers to write their own tool to perform
installations in their preferred programming language.

The file format should promote good security defaults. As the format is not
meant to be human-writable, this means providing tools the ability to include
relevant details to perform installs securely.

The contents of a lock file should be able to replace the vast majority of uses
of `requirements files`_ that are used as a lock file (e.g., what
pip-tools_ and ``pip freeze`` emit). This means the file format specified by
this PEP can, at minimum, act as an export target for tools which have their own
internal lock file format.


=============
Specification
=============

---------
File Name
---------

A lock file MUST be named :file:`pylock.toml` or match the regular expression
``r"pylock\.(.+)\.toml"`` if a name for the lock file is desired or if multiple
lock files exist. The use of the ``.toml`` file extension is to make syntax
highlighting in editors easier and to reinforce the fact that the file format is
meant to be human-readable. The prefix and suffix of a named file MUST be
lowercase when possible for easy detection and stripping off to find the name,
e.g.:

.. code-block:: Python

  if filename.startswith("pylock.") and filename.endswith(".toml"):
      name = filename.removeprefix("pylock.").removesuffix(".toml")

The lock file(s) SHOULD be located in the directory as appropriate for the scope
of the lock file. Locking against a single ``pyproject.toml``, for instance,
would place the ``pylock.toml`` in the same directory. If the lock file covered
multiple projects in a monorepo, then the expectation is the ``pylock.toml``
file would be in the directory that held all the projects being locked.


-----------
File Format
-----------

The format of the file is TOML_.

Tools SHOULD write their lock files in a consistent way to minmize noise in diff
output. Keys in tables -- including the top-level table -- SHOULD be recorded in
a consistent order. As well, tools SHOULD sort arrays in consistent order. Usage
of inline tables should also be kept consistent.


``metadata-version``
====================

- **Type**: string; value of ``"1.0"``
- **Required?**: yes
- **Inspiration**: :ref:`packaging:core-metadata-metadata-version`
- Record the file format version that the file adheres to.
- This PEP specifies the initial version -- and only valid value until future
  updates to the standard change it -- as ``"1.0"``.
- If an tool supports the major version but not the minor version, a tool
  SHOULD warn when an unknown key is seen.
- If an tool doesn't support a major version, it MUST raise an error.


``environments``
================

- **Type**: Array of strings
- **Required?**: no
- **Inspiration**: uv_
- A list of :ref:`packaging:dependency-specifiers-environment-markers`_ for
  which the lock file is considered compatible with.
- Tools SHOULD write exclusive/non-overlapping environment markers to ease in
  understanding.


``requires-python``
===================

- **Type**: string
- **Required?**: no
- **Inspiration**: PDM_, Poetry_, uv_
- Specifies the :ref:`packaging:core-metadata-requires-python` for the minimum
  Python version compatibility for any environment supported by the lock file.


``[[packages]]``
================

- **Type**: array of tables
- **Required?**: yes
- **Inspiration**: PDM_, Poetry_, uv_
- An array containing all packages that _may_ be installed.
- Packages MAY be listed multiple times with varying data, but all packages to
  be installed MUST narrow down to a single entry at install time.


.. Identification

``packages.name``
-----------------

- **Type**: string
- **Required?**: yes
- **Inspiration**: :ref:`packaging:core-metadata-name`
- The name of the package :ref:`normalized <packaging:name-normalization>`.


``packages.version``
--------------------

- **Type**: string
- **Required?**: no
- **Inspiration**: :ref:`packaging:core-metadata-version`
- The version of the package.
- The version SHOULD be specified when the version is known to be stable
  (i.e. when an :ref:`sdist <packaging:source-distribution-format>` or
  :ref:`wheels <packaging:binary-distribution-format>` are specified).
- The version MUST NOT be included when it cannot be guaranteed to be consistent
  with the code used (i.e. when a
  :ref:`packaging:source-distribution-format-source-tree` is used).


.. Requirements

``packages.marker``
-------------------

- **Type**: string
- **Required?**: no
- **Inspiration**: PDM_
- The :ref:`packaging:dependency-specifiers-environment-markers` which specify
  when the package should be installed.


``packages.requires-python``
----------------------------

- **Type**: string
- **Required?**: no
- **Inspiration**: :ref:`packaging:core-metadata-requires-python`
- Holds the :ref:`packaging:version-specifiers` for Python version compatibility
  for the package and version.
- The value MUST match what's provided by the referenced package.


.. Installation

``packages.direct``
-------------------

- **Type**: boolean
- **Required?**: no; defaults to ``false``
- **Inspiration**: :ref:`packaging:direct-url`
- Represents whether the installation is via a
  :ref:`direct URL reference <packaging:direct-url>`.


.. Source

``[packaging.vcs]``
-------------------

- **Type**: table
- **Required?**: no; mutually-exclusive with ``packaging.directory``,
  ``packaging.archive``, ``packaging.sdist``, and ``packaging.wheels``
- **Inspiration**: :ref:`packaging:direct-url-data-structure`
- Record the version control system details for the
  :ref:`packaging:source-distribution-format-source-tree` it contains.
- Tools MAY choose to not support version control systems, both from a locking
  and/or installation perspective.
- Tools SHOULD provide a way for users to opt out of using version control
  systems.


``packaging.vcs.type``
''''''''''''''''''''''

- **Type**: string; supported values specified in
  :ref:`packaging:direct-url-data-structure-registered-vcs`
- **Required?**: yes
- **Inspiration**: :ref:`packaging:direct-url-data-structure-vcs`
- The type of version control system used.


``packaging.vcs.url``
'''''''''''''''''''''

- **Type**: string
- **Required?**: if ``path`` is not specified
- **Inspiration**: :ref:`packaging:direct-url-data-structure-vcs`
- The URL to the repository.


``packaging.vcs.path``
''''''''''''''''''''''

- **Type**: string
- **Required?**: if ``url`` is not specified
- **Inspiration**: :ref:`packaging:direct-url-data-structure-vcs`
- The path to the local directory of the repository.
- If a relative path is used it MUST be relative to the location of this file.
- If the path is relative it MAY use POSIX-style path separators for
  portability.


``packaging.vcs.requested-revision``
''''''''''''''''''''''''''''''''''''

- **Type**: string
- **Required?**: no
- **Inspiration**: :ref:`packaging:direct-url-data-structure-vcs`
- The branch/tag/ref/commit/revision/etc. that the user requested.


``packaging.vcs.commit-id``
'''''''''''''''''''''''''''

- **Type**: string
- **Required?**: yes
- **Inspiration**: :ref:`packaging:direct-url-data-structure-vcs`
- The exact commit/revision number that is to be installed.
- If the VCS supports commit-hash based revision identifiers, such commit-hash
  MUST be used as the commit id in order to reference an immutable version of
  the source code.


``packaging.vcs.subdirectory``
''''''''''''''''''''''''''''''

- **Type**: string
- **Required?**: no
- **Inspiration**: :ref:`packaging:direct-url-data-structure-subdirectories`
- The subdirectory within the
  :ref:`packaging:source-distribution-format-source-tree` where the project root
  of the project is (e.g., the location of the ``pyproject.toml`` file).
- The path MUST be relative to the root of the source tree structure.


``[packaging.directory]``
-------------------------

- **Type**: table
- **Required?**: no; mutually-exclusive with ``packaging.vcs``,
  ``packaging.archive``, ``packaging.sdist``, and ``packaging.wheels``
- **Inspiration**: :ref:`packaging:direct-url-data-structure-local-directory`
- Record the local directory details for the
  :ref:`packaging:source-distribution-format-source-tree` it contains.
- Tools MAY choose to not support local directories, both from a locking
  and/or installation perspective.
- Tools SHOULD provide a way for users to opt out of using local directories.


``packaging.directory.path``
''''''''''''''''''''''''''''

- **Type**: string
- **Required?**: yes
- **Inspiration**: :ref:`packaging:direct-url-data-structure-local-directory`
- The local directory where the source tree is.
- If the path is relative it MUST be relative to the location of the lock file.
- If the path is relative it MAY use POSIX-style path separators for
  portability.


``packaging.directory.editable``
''''''''''''''''''''''''''''''''

- **Type**: boolean
- **Required?**: no; defaults to ``false``
- **Inspiration**: :ref:`packaging:direct-url-data-structure-local-directory`
- A flag representing whether the source tree should be installed as editable.


``packaging.directory.subdirectory``
''''''''''''''''''''''''''''''''''''

See ``packaging.vcs.subdirectory``.


``[packaging.archive]``
-----------------------

- **Type**: table
- **Required?**: no
- **Inspiration**: :ref:`packaging:direct-url-data-structure-archive`
- An archive file containing a
  :ref:`packaging:source-distribution-format-source-tree`.
- Tools MAY choose to not support archive files, both from a locking
  and/or installation perspective.
- Tools SHOULD provide a way for users to opt out of using archive files.


``packaging.archive.url``
'''''''''''''''''''''''''

See ``packaging.vcs.url``.


``packaging.archive.path``
''''''''''''''''''''''''''

See ``packaging.vcs.path``.


``packaging.archive.size``
''''''''''''''''''''''''''

- **Type**: integer
- **Required?**: yes
- **Inspiration**: uv_, :ref:`packaging:simple-repository-api`
- The size of the archive file.


``[packaging.archive.hashes]``
''''''''''''''''''''''''''''''

- **Type**: Table of strings
- **Required?**: yes
- **Inspiration**: PDM_, Poetry_, uv_, :ref:`packaging:simple-repository-api`
- A table listing known hash values of the file where the key is the hash
  algorithm and the value is the hash value.
- The table MUST contain at least one entry.
- Hash algorithm keys SHOULD be lowercase.
- At least one secure algorithm from :py:data:`hashlib.algorithms_guaranteed`
  SHOULD always be included (at time of writing, sha256 specifically is
  recommended.


``packaging.archive.subdirectory``
''''''''''''''''''''''''''''''''''

See ``packaging.vcs.subdirectory``.


``packages.index``
------------------

- **Type**: string
- **Required?**: no
- **Inspiration**: uv_
- The base URL for the package index from :ref:`packaging:simple-repository-api`
  where the sdist and/or wheels were found (e.g., ``https://pypi.org/simple/``).
- When possible, this SHOULD be specified to assist with generating
  `software bill of materials`_ (aka SBOMs).


``[packages.sdist]``
--------------------

- **Type**: table
- **Required?**: no; mutually-exclusive with ``packaging.vcs``,
  ``packaging.directory``, and ``packaging.archive``
- **Inspiration**: uv_
- Details of a :ref:`packaging:source-distribution-format-sdist` for the
  package.
- Tools MAY choose to not support sdist files, both from a locking
  and/or installation perspective.
- Tools SHOULD provide a way for users to opt out of using sdist files.


``packages.sdist.name``
'''''''''''''''''''''''

- **Type**: string
- **Required?**: no
- **Inspiration**: PDM_, Poetry_, uv_
- The file name of the :ref:`packaging:source-distribution-format-sdist` file.
- The name SHOULD be recorded when it does not follow the standard outlined in
  :ref:`packaging:source-distribution-format-sdist`.


``packages.sdist.upload-time``
''''''''''''''''''''''''''''''

- **Type**: datetime
- **Required?**: no
- **Inspiration**: :ref:`packaging:simple-repository-api`
- The time the file was uploaded.
- The date and time MUST be recorded in UTC.


``packages.sdist.url``
''''''''''''''''''''''

See ``packaging.archive.url``.


``packages.sdist.path``
'''''''''''''''''''''''

See ``packaging.archive.path``.


``packages.sdist.size``
'''''''''''''''''''''''

See ``packaging.archive.size``.


``packages.sdist.hashes``
'''''''''''''''''''''''''

See ``packaging.archive.hashes``.



``[[packages.wheels]]``
-----------------------

- **Type**: array of tables
- **Required?**: no; mutually-exclusive with ``packaging.vcs``,
  ``packaging.directory``, and ``packaging.archive``
- **Inspiration**: PDM_, Poetry_, uv_
- For recording the wheel files as specified by
  :ref:`packaging:binary-distribution-format` for the package.
- Tools MUST support wheel files, both from a locking and installation
  perspective.


``packages.wheels.name``
''''''''''''''''''''''''

- **Type**: string
- **Required?**: yes
- **Inspiration**: PDM_, Poetry_, uv_
- The file name of the :ref:`packaging:binary-distribution-format` file.


``packages.wheels.upload-time``
'''''''''''''''''''''''''''''''

See ``packages.sdist.upload-time``.


``packages.wheels.url``
'''''''''''''''''''''''

See ``packaging.archive.url``.


``packages.wheels.path``
''''''''''''''''''''''''

See ``packaging.archive.path``.


``packages.wheels.size``
''''''''''''''''''''''''

See ``packaging.archive.size``.


``packages.wheels.hashes``
''''''''''''''''''''''''''

See ``packaging.archive.hashes``.



``[packages.tool]``
-------------------

- **Type**: table
- **Required?**: no
- **Inspiration**: :ref:`packaging:pyproject-tool-table`
- Similar usage as that of the ``[tool]`` table from the
  :ref:`packaging:pyproject-toml-spec`, but at the package version level instead
  of at the lock file level (which is also available via ``[tool]``).
- Useful for scoping package version/release details (e.g., recording signing
  identities to then use to verify package integrity separately from where the
  package is hosted, prototyping future extensions to this file format, etc.).


``[tool]``
==========

- **Type**: table
- **Required?**: no
- **Inspiration**: :ref:`packaging:pyproject-tool-table`
- Same usage as that of the equivalent ``[tool]`` table from the
  :ref:`packaging:pyproject-toml-spec`.


-------
Example
-------

.. code-block:: TOML

  XXX


------------
Installation
------------

The following outlines the steps to be taken to install from a lock file:

1. Check if the metadata version specified by ``metadata-version`` is supported;
   raise an error or warning MUST be raised as appropriate.
1. If ``requires-python`` is specified, check that the environment being
   installed for meets the requirement; error MUST be raised if it is not met.
1. If ``environments`` is specified, check that at least one of the environment
   marker expressions is satisfied; error MUST be raised if no expression is
   satisfied.
1. For each package listed in ``[[packages]]``:
   1. If ``marker`` is specified, check if it is satisfied; it it isn't,
      skip to the next package.
   1. If ``requires-python`` is specified, check if it is satisfied; an error
      MUST be raised if it isn't.
   1. Check that the source of the package is specified appropriately (i.e.
      there are not conflicting sources); an error MUST be raised if any issues
      are found.
   1. Add the package to the set of packages to install.
1. Check that there is only one instance of any package in the set of packages
   to install; an error MUST be raised  sif any ambiguity is found in terms of
   multiple versions, multiple sources, etc.
1. For each package to be installed:
   - If ``vcs`` is set:
     1. Clone the repository to the commit ID specified in ``commit-id``.
     1. Build the package, respecting ``subdirectory``.
     1. Install.
   - Else if ``directory`` is set:
     1. Build the package, respecting ``subdirectory``.
     1. Install.
   - Else if ``archive`` is set:
     1. Get the file.
     1. Build the package, respecting ``subdirectory``.
     1. Install.
   - Else if there are entries for ``wheels``:
     1. Look for the appropriate wheel file based on ``name``; if one is not
        found then either move on to ``sdist`` or an error MUST be raised.
     1. Get the file.
     1. Install.
   - Else if no ``wheel`` file is found or ``sdist`` is solely set:
     1. 1. Get the file.
     1. Install.


----------------------------------------------------
Semantic differences with ``requirements.txt`` files
----------------------------------------------------

Ignoring formatting, there are a few differences between lock files as proposed
by this PEP and those that are possible via a `requirements files`_.

One is the aspects in regards to security. Requiring hashes, file
sizes, and where a file was found -- both the index and the location of the file
itself -- help with auditing and validating the files that were locked against
and are to be installed. Compare that with requirements files which can
optionally include hashes, but it is an opt-in feature and can be bypassed. The
optional inclusion of a file's upload time is also different.

Being explicit about the supported Python versions and environments is also
unique to this PEP. This is to alleviate the issue of not knowing when a
requirements file targets a specific platform.

The ``[tool]`` tables don't have a direct correlation on requirements files.
They do support comments, but they are not inherently structured like the
``[tool]`` table is thanks to being in TOML.

While comments in a requirements file could record details that are helpful for
auditing and understanding what the lock file contains, providing the structured
support to record such things makes auditing easier. Recording the required
Python version upfront helps with this as well as erroring out sooner if an
install is going to fail instead of having to separately fetch the package
metadata to make the same determination. Recording the wheel file name separate
from the URL or path is also to help make reading the list of wheel files easier
as it encodes information that can be useful when understanding and auditing a
file. Recording the sdist file name is for the same reason.


=======================
Backwards Compatibility
=======================

Because there is no preexisting lock file format, there are no explicit
backwards-compatibility concerns in terms of Python packaging standards.

As for packaging tools themselves, that will be a per-tool decision. For tools
that don't document their lock file format, they could choose to simply start
using the format internally and then transition to saving their lock files with
a name supported by this PEP. For tools with a preexisting, documented format,
they could provide an option to choose which format to emit.


=====================
Security Implications
=====================

The hope is that by standardizing on a lock file format that starts from a
security-first posture it will help make overall packaging installation safer.
However, this PEP does not solve all potential security concerns.

One potential concern is tampering with a lock file. If a lock file is not kept
in source control and properly audited, a bad actor could change the file in
nefarious ways (e.g. point to a malware version of a package). Tampering could
also occur in transit to e.g. a cloud provider who will perform an installation
on the user's behalf. Both could be mitigated by signing the lock file either
within the file in a ``[tool]`` entry or via a side channel external to the lock
file itself.

This PEP does not do anything to prevent a user from installing incorrect
packages. While including many details to help in auditing a package's inclusion,
there isn't any mechanism to stop e.g., name confusion attacks via
typosquatting. Tools may be able to provide some UX to help with this (e.g., by
providing download counts for a package).


=================
How to Teach This
=================

Users should be informed that when they ask to install some package, that
package may have its own dependencies, those dependencies may have dependencies,
and so on. Without writing down what gets installed as part of installing the
package they requested, things could change from underneath them (e.g., package
versions). Changes to the underlying dependencies can lead to accidental
breakage of their code. Lock files help deal with that by providing a way to
write down what was (and should be) installed.

Having what to install written down also helps in collaborating with others. By
agreeing to a lock file's contents, everyone ends up with the same packages
installed. This helps make sure no one relies on e.g. an API that's only
available in a certain version that not everyone working on the project has
installed.

Lock files also help with security by making sure you always get the same files
installed and not a malicious one that someone may have slipped in. It also
lets one be more deliberate in upgrading their dependencies and thus making sure
the change is on purpose and not one slipped in by a bad actor.


========================
Reference Implementation
========================

A proof-of-concept implementing most of this PEP for wheels for various versions
of this PEP can be found at
https://github.com/brettcannon/mousebender/tree/pep . While the various
implementations have not matched the exact format of this PEP, the general
semantic requirements have been covered before.

Prior to acceptance the PoC will be updated to match this PEP.


==============
Rejected Ideas
==============

--------------------------------------------------------
Recording the dependency graph for installation purposes
--------------------------------------------------------

A previous version of this PEP recorded the dependency graph of packages instead
of a set of packages to install. The idea was that by recording the dependency
graph you not only got more information, but it provided more flexibility by
supporting more features innately (e.g., platform-specific dependencies without
explicitly propagating markers).

In the end, though, it was deemed to add complexity that wasn't worth the cost
(e.g., it impacted the ease of auditing for details which were not necessary
for this PEP to reach its goals).


-------------------------------------------------------------------------------------
Specifying a new core metadata version that requires consistent metadata across files
-------------------------------------------------------------------------------------

At one point, to handle the issue of metadata varying between files and thus
require examining every released file for a package and version for accurate
locking results, the idea was floated to introduce a new core metadata version
which would require all metadata for all wheel files be the same for a single
version of a packages. Ultimately, though, it was deemed unnecessary as this PEP
will put pressure on people to make files consistent for performance reasons or
to make indexes provide all the metadata separate from the wheel files
themselves. As well, there's no easy enforcement mechanism, and so community
expectation would work as well as a new metadata version.


-------------------------------------------
Have the installer do dependency resolution
-------------------------------------------

In order to support a format more akin to how Poetry worked when this PEP was
drafted, it was suggested that lockers effectively record the packages and their
versions which may be necessary to make an install work in any possible
scenario, and then the installer resolves what to install. But that complicates
auditing a lock file by requiring much more mental effort to know what packages
may be installed in any given scenario. Also, one of the Poetry developers
`suggested <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__
that markers as represented in the package locking approach of this PEP may be
sufficient to cover the needs of Poetry. Not having the installer do a
resolution also simplifies their implementation, centralizing complexity in
lockers.


-----------------------------------------
Requiring specific hash algorithm support
-----------------------------------------

It was proposed to require a baseline hash algorithm for the files. This was
rejected as no other Python packaging specification requires specific hash
algorithm support. As well, the minimum hash algorithm suggested may eventually
become an outdated/unsafe suggestion, requiring further updates. In order to
promote using the best algorithm at all times, no baseline is provided to avoid
simply defaulting to the baseline in tools without considering the security
ramifications of that hash algorithm.


------------------------------------
Require a URL or file path for files
------------------------------------

Originally references to files were required, e.g., ``packages.sdist.url`` or
``packages.sdist.path``. But at least
`one use-case <https://discuss.python.org/t/pep-751-now-with-graphs/69721/34>`__
surfaced during discussions about this PEP where statically specifying the
location of files would be problematic. And in earlier discussions the idea of
the location being a hint wasn't preferred. Hence the PEP now makes the data
optional, but considers the locations accurate if specified.


-----------
File naming
-----------

Using ``*.pylock.toml`` as the file name
========================================

It was proposed to put the ``pylock`` constant part of the file name after the
identifier for the purpose of the lock file. It was decided not to do this so
that lock files would sort together when looking at directory contents instead
of purely based on their purpose which could spread them out in a directory.


Using ``*.pylock`` as the file name
===================================

Not using ``.toml`` as the file extension and instead making it ``.pylock``
itself was proposed. This was decided against so that code editors would know
how to provide syntax highlighting to a lock file without having special
knowledge about the file extension.


Not having a naming convention for the file
===========================================

Having no requirements or guidance for a lock file's name was considered, but
ultimately rejected. By having a standardized naming convention it makes it easy
to identify a lock file for both a human and a code editor. This helps
facilitate discovery when e.g. a tool wants to know all of the lock files that
are available.


-----------
File format
-----------

Use JSON over TOML
==================

Since having a format that is machine-writable was a goal of this PEP, it was
suggested to use JSON. But it was deemed less human-readable than TOML while
not improving on the machine-writable aspect enough to warrant the change.


Use YAML over TOML
==================

Some argued that YAML met the machine-writable/human-readable requirement in a
better way than TOML. But as that's subjective and ``pyproject.toml`` already
existed as the human-writable file used by Python packaging standards it was
deemed more important to keep using TOML.


----------
Other keys
----------

==========================================
A single hash algorithm for the whole file
==========================================

Earlier versions of this PEP proposed having a single hash algrorithm be
specified per file instead of any number of algorithms per file. The thinking
was that by specifying a single algorithm it would help with auditing the file
when a specific hash algorithm was mandated for use.

In then end there was some objection to this idea. Typically it centered around
the cost of rehashing large wheel files (e.g., PyTorch). There was also concern
about making hashing decisions upfront on the installer's behalf which they may
disagree with. In the end it was deemed better to have flexibility and let
people audit the lock file as they see fit.


Hashing the contents of the lock file itself
============================================

Hashing the contents of the bytes of the file and storing hash value within the
file itself was proposed at some point. This was removed to make it easier
when merging changes to the lock file as each merge would have to recalculate
the hash value to avoid a merge conflict.

Hashing the semantic contents of the file was also proposed, but it would lead
to the same merge conflict issue.

Regardless of which contents were hashed, either approach could have the hash
value stored outside of the file if such a hash was desired.


Recording the creation date of the lock file
============================================

To know how potentially stale the lock file was, an earlier proposal suggested
recording the creation date of the lock file. But for some same merge conflict
reasons as storing the hash of the file contents, this idea was dropped.


Recording the package indexes used in searching
===============================================

Recording what package indexes were used by the locker to decide what to lock
for was considered. In the end, though, it was rejected as it was deemed
unnecessary bookkeeping.


Locking build requirements for sdists
=====================================

An earlier version of this PEP tried to lock the build requirements for sdists
under a ``packages.build-requires`` key. Unfortunately it confused enough people
about how it was expected to operate and there were enough edge case issues to
decide it wasn't worth trying to do in this PEP upfront. Instead, a future PEP
could propose a solution.


===========
Open Issues
===========

XXX


================
Acknowledgements
================

Thanks to everyone who participated in the discussions on discuss.python.org.
Also thanks to Randy Döring, Seth Michael Larson, Paul Moore, and Ofek Lev for
providing feedback on a draft version of this PEP before going public.


=========
Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.

.. _Dependabot: https://docs.github.com/en/code-security/dependabot
.. _PDM: https://pypi.org/project/pdm/
.. _pip-tools: https://pypi.org/project/pip-tools/
.. _Poetry: https://python-poetry.org/
.. _requirements files: https://pip.pypa.io/en/stable/reference/requirements-file-format/
.. _software bill of materials: https://www.cisa.gov/sbom
.. _TOML: https://toml.io/
.. _uv: https://github.com/astral-sh/uv
