PEP: 751
Title: A file format to record Python dependencies for installation reproducibility
Author: Brett Cannon <brett@python.org>
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 24-Jul-2024
Post-History: `25-Jul-2024 <https://discuss.python.org/t/59173>`__
Replaces: 665

========
Abstract
========

This PEP proposes a new file format for dependency specification
to enable reproducible installation in a Python environment. The format is
designed to be human-readable and machine-generated. Installers consuming the
file should be able to calculate what to install without the need for dependency
resolution at install-time.


==========
Motivation
==========

Currently, no standard exists to create an immutable record, such as a lock
file, which specifies what direct and indirect dependencies should be installed
into a virtual environment.

Considering there are at least five well-known solutions to this problem in the
community (``pip freeze``, pip-tools_, uv_, Poetry_, and PDM_), there seems to
be an appetite for lock files in general.

Those tools also vary in what locking scenarios they support. For instance,
``pip freeze`` and pip-tools only generate lock files for the current
environment while PDM and Poetry try to lock for *any* environment to some
degree. There's also concerns around the lack of secure defaults in the face of
supply chain attacks (e.g., always including hashes for files).

The lack of a standard also has some drawbacks. For instance, any tooling that
wants to work with lock files must choose which format to support, potentially
leaving users unsupported (e.g., Dependabot_ only supporting select tools,
same for cloud providers who can do dependency installations on your behalf,
etc.). It also impacts portability between tools, which causes vendor lock-in.
By not having compatibility and interoperability it fractures tooling around
lock files where both users and tools have to choose what lock file format to
use upfront and making it costly to use/switch to other formats. Rallying
around a single format removes that cost/barrier.

.. note::

   Much of the motivation from :pep:`665` also applies to this PEP.


=========
Rationale
=========

The format is designed so that a *locker* which produces the lock file
and an *installer* which consumes the lock file can be separate tools. This
allows for situations such as cloud hosting providers to use their own installer
that's optimized for their system which is independent of what locker the user
used to create their lock file.

The file format is designed to be human-readable. This is so that the contents
of the file can be audited by a human to make sure no undesired dependencies end
up being included in the lock file.

The file format is also designed to not require a resolver at install time. This
greatly simplifies installers and thus reasoning about what would be installed
when consuming a lock file. It should also lead to faster installs which are
much more frequent than creating a lock file.

Finally, the lock file is meant to be flexible enough to meets the various needs
tools have for choosing what to install. That means the lock file records the
dependency graph of what _may_ be installed. This allows tools to enter the
graph at any point and still have reproducible results from that root of the
graph. Flexibility also means supporting different installation scenarios within
the same lock file (e.g., with or without test dependencies).


=============
Specification
=============

---------
File Name
---------

A lock file MUST be named :file:`pylock.toml` or match the regular expression
``r"pylock\.(.+)\.toml"`` if a name for the lock file is desired or if multiple
lock files exist. The use of the ``.toml`` file extension is to make syntax
highlighting in editors easier and to reinforce the fact that the file format is
meant to be human-readable. The prefix and suffix of a named file MUST be
lowercase for easy detection and stripping off to find the name, e.g.::

  if filename.startswith("pylock.") and filename.endswith(".toml"):
      name = filename.removeprefix("pylock.").removesuffix(".toml")

This PEP has no opinion as to the location of lock files (i.e. in the root or a
subdirectory of a project).


-----------
File Format
-----------

The format of the file is TOML_.

All keys listed below are required unless otherwise noted. If two keys are
mutually exclusive to one another, then one of the keys is required while the
other is disallowed.

Keys in tables -- including the top-level table -- SHOULD be emitted by lockers
in the order they are listed in this PEP when applicable unless another sort
order is specified to minimize noise in diffs. If the keys are not explicitly
specified in this PEP, then the keys SHOULD be sorted by lexicographic order.

As well, lockers SHOULD sort arrays in lexicographic order unless otherwise
specified for the same reason.


``version``
===========

- String
- The version of the lock file format.
- This PEP specifies the initial version -- and only valid value until future
  updates to the standard change it -- as ``"1.0"``.
- If an installer supports the major version but not the minor version, a tool
  SHOULD warn when an unknown key is seen.
- If an installer doesn't support a major version, it MUST raise an error.


``hash-algorithm``
==================

- String
- The name of the hash algorithm used for calculating all hash values.
- Only a single hash algorithm is used for the entire file to allow hash values
  to be written in inline tables for readability and compactness purposes by
  only listing a single hash value instead of multiple values based on multiple
  hash algorithms.
- Specifying a single hash algorithm guarantees that an algorithm that the user
  prefers is used consistently throughout the file without having to audit
  each file hash value separately.
- Allows for updating the entire file to a new hash algorithm without running
  the risk of accidentally leaving an old hash value in the file.
- :ref:`packaging:simple-repository-api-json` and the ``hashes`` dictionary of
  of the ``files`` dictionary of the Project Details dictionary specifies what
  values are valid and guidelines on what hash algorithms to use.
- Failure to validate any hash values for any file that is to be installed MUST
  raise an error.


``[[groups]]``
==============

- Array of tables
- A named subset of packages as found in ``[[packages]]``.
- Act as roots into the dependency graph.
- Installers MUST allow the user to select one or more groups by name to
  install all relevant packages together.
- Installers SHOULD let the user skip specifying a name if there is only one
  entry in the array.


``groups.name``
---------------

- String
- The name of the group.


``groups.project``
------------------

- Mutually-exclusive with ``requirements``
- String
- The name of a package to act as the starting point into the dependency graph.
- Installers MUST let a user specify any optional features/extras that the
  package provides.
- Lockers MUST NOT allow for ambiguity by specifying multiple package versions
  of the same package under the same group name when a package is listed in any
  ``project`` key.


``groups.requirements``
-----------------------

- Mutually-exclusive with ``project``
- Array of tables
- Represents the installation requirements for the group.
- Lockers MUST make sure that resolving any requirement for any environment does
  not lead to ambiguity by having multiple values in ``[[packages]]`` match the
  same requirement.
- Values in the array SHOULD be written as inline tables, sorted
  lexicographically by ``name``, then by ``feature`` with the lack of that key
  sorting first.


``groups.requirements.name``
''''''''''''''''''''''''''''''

- String
- Normalized name of the package.


``groups.requirements.extras``
'''''''''''''''''''''''''''''''

- Optional
- Array of strings
- The names of the extras specified for the requirement
  (i.e. what comes between ``[...]``).


``groups.requirements.version``
'''''''''''''''''''''''''''''''''

- Optional
- String
- The `version specifiers`_ for the requirement.


``groups.requirements.marker``
''''''''''''''''''''''''''''''''

- Optional
- String
- The `environment marker`_ for the requirement.


``[[packages]]``
================

- Array of tables
- The array contains all data on the nodes of the dependency graph.
- Lockers SHOULD record packages in order by ``name``
  lexicographically, ``version`` by its Python `version specifiers`
  ordering, and then by ``groups`` following Python's sort order for lists of
  strings (i.e. item by item, then by length as a tiebreaker).


.. Identification

``packages.name``
-----------------

- String
- The `normalized name`_ of the package.


``packages.version``
--------------------

- String
- The version of the package.


``packages.groups``
-------------------

- Array of strings
- Associates this table with the ``group.name`` entries of the same names.


``packages.index-url``
----------------------

- Optional
- String
- Stores the `project index`_ URL from the `Simple Repository API`_.
- Useful for generating Packaging URLs (aka PURLs).
- When possible, lockers SHOULD include this to assist with generating
  `software bill of materials`_ (aka SBOMs).


``packages.direct``
-------------------

- Optional (defaults to ``false``)
- Boolean
- Represents whether the installation is via a `direct URL reference`_.


.. Requirements

``packages.requires-python``
----------------------------

- String
- Holds the `version specifiers`_ for Python version compatibility for the
  package and version.
- The value MUST match what's provided by the package version, if available, via
  :ref:`packaging:core-metadata-requires-python`.


``[[packages.dependencies]]``
-----------------------------

- Array of tables
- A record of the dependency requirements of the package and version.
- The values MUST semantically match what's provided by the package version via
  :ref:`packaging:core-metadata-requires-dist`.
- Values in the array SHOULD be written as inline tables, sorted
  lexicographically by ``name``, then by ``feature`` with the lack of that key
  sorting first.


``packages.dependencies.name``
''''''''''''''''''''''''''''''

See ``groups.requirements.name``.


``packages.dependenciss.extras``
''''''''''''''''''''''''''''''''

See ``groups.requirements.extras``.


``packages.dependencies.version``
'''''''''''''''''''''''''''''''''

See ``groups.requirements.version``.


``packages.dependencies.marker``
''''''''''''''''''''''''''''''''

See ``groups.requirements.marker``.


``packages.dependencies.feature``
'''''''''''''''''''''''''''''''''

- Optional
- String
- The optional feature/:ref:`packaging:core-metadata-provides-extra` that this
  requirement is conditional on.


.. Installing

``packages.editable``
---------------------

- Optional (defaults to ``false``)
- Boolean
- Specifies whether the package should be installed in editable mode.


``[packages.source-tree]``
--------------------------

- Optional
- Table
- For recording where to find the `source tree` for the package version.
- Lockers SHOULD write this table inline.
- Support for source trees by installers is optional.
- If support is provided by an installer it SHOULD be opt-in.
- If multiple source trees are provided, installers MUST prefer either the
  ``vcs`` option or a file for security/reproducibility due to their commit or
  hash, respectively.


``packages.source-tree.vcs``
''''''''''''''''''''''''''''

- Optional
- String
- If specifying a VCS, the type of version control system used.
- The valid values are specified by the
  `registered VCSs <https://packaging.python.org/en/latest/specifications/direct-url-data-structure/#registered-vcs>`__
  of the direct URL data structure.


``packages.source-tree.path``
'''''''''''''''''''''''''''''

- Required if ``url`` is not set
- String
- A path to the source tree, which may be absolute or relative.
- If the path is relative it MUST be relative to the lock file.
- The path may either be to a directory, file archive, or VCS checkout if
  ``vcs`` if is specified.


``packages.source-tree.url``
''''''''''''''''''''''''''''

- Required if ``path`` is not set
- String
- A URL to a file archive containing the source tree, or a VCS checkout if
  ``vcs`` is specified.


``packages.source-tree.commit``
'''''''''''''''''''''''''''''''

- Required if ``vcs`` is set
- String
- The commit ID for the repository which represents the package and version.
- The value MUST be immutable for the VCS for security purposes
  (e.g. no Git tags).


``packages.source-tree.hash``
'''''''''''''''''''''''''''''

- Required if ``url`` or ``path`` points to a file
- String
- The hash value of the file contents using the hash algorithm specified by
  ``hash-algorithm``.
- Installers MUST verify the hash matches the file.


``[packages.sdist]``
--------------------

- Optional
- Table
- The location of a source distribution as specified by
  :ref:`packaging:source-distribution-format`.
- Lockers SHOULD write the table inline.
- Support for source distributions by installers is optional.
- If support is provided by an installer it SHOULD be opt-in.


``packages.sdist.url``
''''''''''''''''''''''

- Required if ``path`` is not set
- String
- The URL to the file.


``packages.sdist.path``
'''''''''''''''''''''''

- Required if ``url`` is not set
- String
- A path to the file, which may be absolute or relative.
- If the path is relative it MUST be relative to the lock file.


``packages.sdist.upload-time``
''''''''''''''''''''''''''''''

- Optional and only applicable when ``url`` is specified
- Offset date time
- The upload date and time of the file as specified by a valid ISO 8601
  date/time string for the ``.files[]."upload-time"`` field in the JSON
  version of :ref:`packaging:simple-repository-api`.

``packages.sdist.size``
'''''''''''''''''''''''

- Optional
- Integer
- The size of the file in bytes.


``packages.sdist.hash``
'''''''''''''''''''''''

- String
- The hash value of the file contents using the hash algorithm specified by
  ``hash-algorithm``.
- Installers MUST verify the hash matches the file.


``[[packages.wheels]]``
-----------------------

- Optional
- Array of tables
- For recording the wheel files as specified by
  :ref:`packaging:binary-distribution-format` for the package version.
- Lockers SHOULD write the table inline.
- Lockers SHOULD sort the array values lexicographically by ``tag``.


``packages.wheels.tag``
''''''''''''''''''''''''

- String
- The compressed tag portion of the wheel file: Python, ABI, and platform.
- Lockers MUST make sure the tag value is unique within the ``packages.wheels``
  array.


``packages.wheels.build``
'''''''''''''''''''''''''

- Optional
- String
- The build tag for the wheel file (if appropriate).


``packages.wheels.url``
'''''''''''''''''''''''

See ``packages.sdist.url``.


``packages.wheels.path``
''''''''''''''''''''''''

See ``packages.sdist.path``.


``packages.wheels.upload-time``
'''''''''''''''''''''''''''''''

See ``packages.sdist.upload-time``.


``packages.wheels.size``
''''''''''''''''''''''''

See ``packages.sdist.size``.


``packages.wheels.hash``
'''''''''''''''''''''''

See ``packages.sdist.hash``.


``[packages.tool]``
-------------------

- Optional
- Table
- Similar usage as that of the ``[tool]`` table from the
  `pyproject.toml specification`_ , but at the package version level instead of
  at the lock file level (which is also available via ``[tool]``).
- Useful for scoping package version/release details (e.g., recording signing
  identities to then use to verify package integrity separately from where the
  package is hosted, prototyping future extensions to this file format, etc.).


``[tool]``
==========

- Optional
- Table
- Same usage as that of the equivalent ``[tool]`` table from the
  `pyproject.toml specification`_.


--------
Examples
--------

XXX


------------------------
Expectations for Lockers
------------------------

- Lockers MUST make sure that entering the dependency graph via any group will
  not lead to ambiguity for installers as to which value in ``[[packages]]``
  to install for any environment (this can be controlled for via
  ``packages.version`` and ``packages.groups``).
- Lockers MAY try to lock for multiple environments in a single lock file.
- Lockers MAY want to provide a way to let users provide the information
  necessary to lock for other environments, e.g., supporting a JSON
  file format which specifies wheel tags and marker values.

.. code-block:: JSON

    {
        "marker-values": {"<marker>": "<value>"},
        "wheel-tags": ["<tag>"]
    }


---------------------------
Expectations for Installers
---------------------------

XXX

- Installers MAY support installation of non-binary files
  (i.e. source trees and source distributions), but are not required to.
- Installers MUST provide a way to avoid non-binary file installation for
  reproducibility and security purposes.
- Installers SHOULD make it opt-in to use non-binary file installation to
  facilitate a secure-by-default approach.


Pseudo-Code
===========

.. code-block:: Python

    def satisfy(group, locked_packages):
        available_packages = XXX filter based on group name, then group by name

        packages = {}
        stack = []
        if project := group.get("project"):
            requirement = {"name": project["name"]}
            # Pretend the installer added this key based on what the user requested.
            if extras := project.get("extras"):
                requirement["extras"] = extras
            stack.append(requirement)
        else:
            for requirement in group["requirements"]:
                stack.append(requirement)

        while stack:
            requirement = stack.pop()
            XXX find the best package that satisfies the requirement


    def install(*groups, locked_packages):
        packages = {}
        for group in groups:
            group_packages = satisfy(group, locked_packages)
            for group_package in group_packages:
                if package := packages.get(group_package["name"]):
                    if package["version"] != group_package["version"]:
                        raise AmbiguityError(f"conflicting package versions for {group_package['name']!r}: {package['version']!r} and {group_package['version']!r}")
                else:
                    packages[group_package["name"]] = group_package

        for package in packages.values():
            print(f"Installing {package['name']} {package['version']}")
            ...


=======================
Backwards Compatibility
=======================

Because there is no preexisting lock file format, there are no explicit
backwards-compatibility concerns in terms of Python packaging standards.

As for packaging tools themselves, that will be a per-tool decision. For tools
that don't document their lock file format, they could choose to simply start
using the format internally and then transition to saving their lock files with
a name supported by this PEP. For tools with a preexisting, documented format,
they could provide an option to choose which format to emit.


=====================
Security Implications
=====================

The hope is that by standardizing on a lock file format that starts from a
security-first posture it will help make overall packaging installation safer.
However, this PEP does not solve all potential security concerns.

One potential concern is tampering with a lock file. If a lock file is not kept
in source control and properly audited, a bad actor could change the file in
nefarious ways (e.g. point to a malware version of a package). Tampering could
also occur in transit to e.g. a cloud provider who will perform an installation
on the user's behalf. Both could be mitigated by signing the lock file either
within the file in a ``[tool]`` entry or via a side channel external to the lock
file itself.

This PEP does not do anything to prevent a user from installing an incorrect
packages. While including many details to help in auditing a package's inclusion,
there isn't any mechanism to stop e.g. name confusion attacks via typosquatting.
Lockers may be able to provide some UX to help with this (e.g. by providing
download counts for a package).


=================
How to Teach This
=================

Users should be informed that when they ask to install some package, that
package may have its own dependencies, those dependencies may have dependencies,
and so on. Without writing down what gets installed as part of installing the
package they requested, things could change from underneath them (e.g., package
versions). Changes to the underlying dependencies can lead to accidental
breakage of their code. Lock files help deal with that by providing a way to
write down what was (and should be) installed.

Having what to install written down also helps in collaborating with others. By
agreeing to a lock file's contents, everyone ends up with the same packages
installed. This helps make sure no one relies on e.g. an API that's only
available in a certain version that not everyone working on the project has
installed.

Lock files also help with security by making sure you always get the same files
installed and not a malicious one that someone may have slipped in. It also
lets one be more deliberate in upgrading their dependencies and thus making sure
the change is on purpose and not one slipped in by a bad actor.


========================
Reference Implementation
========================

XXX

A rough proof-of-concept for per-file locking can be found at
https://github.com/brettcannon/mousebender/tree/pep. An example lock file can
be seen at
https://github.com/brettcannon/mousebender/blob/pep/pylock.example.toml.

For per-package locking, PDM_ indirectly proves the approach works as this PEP
maintains equivalent data as PDM does for its lock files (whose format was
inspired by Poetry_). Some of the details of PDM's approach are covered in
https://frostming.com/en/2024/pdm-lockfile/ and
https://frostming.com/en/2024/pdm-lock-strategy/.


==============
Rejected Ideas
==============

XXX per-file locking
XXX flattened list of packages to install
XXX set of packages instead of a graph


-------------------------------------------------------------------------------------
Specifying a new core metadata version that requires consistent metadata across files
-------------------------------------------------------------------------------------

At one point, to handle the issue of metadata varying between files and thus
require examining every released file for a package and version for accurate
locking results, the idea was floated to introduce a new core metadata version
which would require all metadata for all wheel files be the same for a single
version of a packages. Ultimately, though, it was deemed unnecessary as this PEP
will put pressure on people to make files consistent for performance reasons or
to make indexes provide all the metadata separate from the wheel files
themselves. As well, there's no easy enforcement mechanism, and so community
expectation would work as well as a new metadata version.


-------------------------------------------
Have the installer do dependency resolution
-------------------------------------------

In order to support a format more akin to how Poetry worked when this PEP was
drafted, it was suggested that lockers effectively record the packages and their
versions which may be necessary to make an install work in any possible
scenario, and then the installer resolves what to install. But that complicates
auditing a lock file by requiring much more mental effort to know what packages
may be installed in any given scenario. Also, one of the Poetry developers
`suggested <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__
that markers as represented in the package locking approach of this PEP may be
sufficient to cover the needs of Poetry. Not having the installer do a
resolution also simplifies their implementation, centralizing complexity in
lockers.


-----------------------------------------
Requiring specific hash algorithm support
-----------------------------------------

It was proposed to require a baseline hash algorithm for the files. This was
rejected as no other Python packaging specification requires specific hash
algorithm support. As well, the minimum hash algorithm suggested may eventually
become an outdated/unsafe suggestion, requiring further updates. In order to
promote using the best algorithm at all times, no baseline is provided to avoid
simply defaulting to the baseline in tools without considering the security
ramifications of that hash algorithm.


-----------
File naming
-----------

Using ``*.pylock.toml`` as the file name
========================================

It was proposed to put the ``pylock`` constant part of the file name after the
identifier for the purpose of the lock file. It was decided not to do this so
that lock files would sort together when looking at directory contents instead
of purely based on their purpose which could spread them out in a directory.


Using ``*.pylock`` as the file name
===================================

Not using ``.toml`` as the file extension and instead making it ``.pylock``
itself was proposed. This was decided against so that code editors would know
how to provide syntax highlighting to a lock file without having special
knowledge about the file extension.


Not having a naming convention for the file
===========================================

Having no requirements or guidance for a lock file's name was considered, but
ultimately rejected. By having a standardized naming convention it makes it easy
to identify a lock file for both a human and a code editor. This helps
facilitate discovery when e.g. a tool wants to know all of the lock files that
are available.


-----------
File format
-----------

Use JSON over TOML
==================

Since having a format that is machine-writable was a goal of this PEP, it was
suggested to use JSON. But it was deemed less human-readable than TOML while
not improving on the machine-writable aspect enough to warrant the change.


Use YAML over TOML
==================

Some argued that YAML met the machine-writable/human-readable requirement in a
better way than TOML. But as that's subjective and ``pyproject.toml`` already
existed as the human-writable file used by Python packaging standards it was
deemed more important to keep using TOML.


----------
Other keys
----------

Multiple hashes per file
========================

An initial version of this PEP proposed supporting multiple hashes per file. The
idea was to allow one to choose which hashing algorithm they wanted to go with
when installing. But upon reflection it seemed like an unnecessary complication
as there was no guarantee the hashes provided would satisfy the user's needs.
As well, if the single hash algorithm used in the lock file wasn't sufficient,
rehashing the files involved as a way to migrate to a different algorithm didn't
seem insurmountable.


Hashing the contents of the lock file itself
============================================

Hashing the contents of the bytes of the file and storing hash value within the
file itself was proposed at some point. This was removed to make it easier
when merging changes to the lock file as each merge would have to recalculate
the hash value to avoid a merge conflict.

Hashing the semantic contents of the file was also proposed, but it would lead
to the same merge conflict issue.

Regardless of which contents were hashed, either approach could have the hash
value stored outside of the file if such a hash was desired.


Recording the creation date of the lock file
============================================

To know how potentially stale the lock file was, an earlier proposal suggested
recording the creation date of the lock file. But for some same merge conflict
reasons as storing the hash of the file contents, this idea was dropped.


Recording the package indexes used
==================================

Recording what package indexes were used by the locker to decide what to lock
for was considered. In the end, though, it was rejected as it was deemed
unnecessary bookkeeping.


Locking build requirements for sdists
=====================================

An earlier version of this PEP tried to lock the build requirements for sdists
under a ``packages.build-requires`` key. Unfortunately it confused enough people
about how it was expected to operate and there were enough edge case issues to
decide it wasn't worth trying to do in this PEP upfront. Instead, a future PEP
could propose a solution.


===========
Open Issues
===========

-----------------------------------------
Should lock files specify a default root?
-----------------------------------------

If a default root of the dependency graph were to be chosen, it could either
come from outside the lock file -- e.g., ``pyproject.toml`` -- or from within
the lock file itself by recording the default root. Leaving that to something
external to the lock file means it is more of a UX decision for the installer,
treating the lock file as just a recorded dependency graph.
But recording the default root in the file means it is self-contained and would
communicate on its own what the baseline expectation is for what is to be
installed if the user made no explicit choice of what to install.


-----------------------------------------------------
How to tell where one can enter the dependency graph?
-----------------------------------------------------

As currently proposed, every package listed in ``[[packages]]`` must list all
of its dependency requirements even if the lock file doesn't have enough
information to support installing those dependencies (e.g., the locker only
locked for a single platform, none of the optional features that weren't used
weren't locked for, etc.). That allows one to at least inspect any package in
the dependency graph to see if the lock file contains enough data to do an
install into an environment and thus enter the graph at that package (i.e.
noticing that an edge in the graph is dangling while being required for an
environment).

Another option is to explicitly denote every package that can act as a root in
the dependency graph. That would tell a user upfront what is considered a valid
point to enter the dependency graph. But if lockers were allowed to also leave
out unused dependency data, then some information would be required upfront to
determine whether a critical dependency was left out for an environment (i.e.
recording what environments a lock file supported).

Another option is to list all dependencies **and** also denote supported roots
in the dependency graph.


----------------------------------------------
Specify ``requires-python`` at the file level?
----------------------------------------------

The lock file formats from PDM_, Poetry_, and uv_ all specify
``requires-python`` at the top level for the absolute minimum Python version
needed for the lock file. This can be inferred, though, by examining all
``packages.requires-python`` values. The global value might also not be
accurate for all platforms depending on how environment markers influence what
package versions are installed.


================
Acknowledgements
================

Thanks to everyone who participated in the discussions on discuss.python.org.
Also thanks to Randy Döring, Seth Michael Larson, Paul Moore, and Ofek Lev for
providing feedback on a draft version of this PEP.


=========
Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


.. _core metadata: https://packaging.python.org/en/latest/specifications/core-metadata/
.. _Dependabot: https://docs.github.com/en/code-security/dependabot
.. _dependency specifiers: https://packaging.python.org/en/latest/specifications/dependency-specifiers/
.. _direct URL reference: https://packaging.python.org/en/latest/specifications/direct-url/
.. _environment markers: https://packaging.python.org/en/latest/specifications/dependency-specifiers/#environment-markers
.. _normalized name: https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization
.. _PDM: https://pypi.org/project/pdm/
.. _pip-tools: https://pypi.org/project/pip-tools/
.. _Poetry: https://python-poetry.org/
.. _project index: https://packaging.python.org/en/latest/specifications/simple-repository-api/#project-list
.. _pyproject.toml specification: https://packaging.python.org/en/latest/specifications/pyproject-toml/#pyproject-toml-specification
.. _Simple Repository API: https://packaging.python.org/en/latest/specifications/simple-repository-api/
.. _software bill of materials: https://www.cisa.gov/sbom
.. _source tree: https://packaging.python.org/en/latest/specifications/source-distribution-format/#source-trees
.. _TOML: https://toml.io/
.. _uv: https://github.com/astral-sh/uv
.. _version specifiers: https://packaging.python.org/en/latest/specifications/version-specifiers/
.. _wheel tags: https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/
