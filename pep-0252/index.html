
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 252 – Making Types Look More Like Classes | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0252/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 252 – Making Types Look More Like Classes | peps.python.org'>
    <meta property="og:description" content="This PEP proposes changes to the introspection API for types that makes them look more like classes, and their instances more like class instances.  For example, type(x) will be equivalent to x.__class__ for most built-in types.  When C is x.__class__, ...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0252/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP proposes changes to the introspection API for types that makes them look more like classes, and their instances more like class instances.  For example, type(x) will be equivalent to x.__class__ for most built-in types.  When C is x.__class__, ...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 252</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 252 – Making Types Look More Like Classes" data-pagefind-weight="10" class="visually-hidden">PEP 252 – Making Types Look More Like Classes</span>
            <section id="pep-content">
<h1 class="page-title">PEP 252 – Making Types Look More Like Classes</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">19-Apr-2001</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">2.2</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#introspection-apis">Introspection APIs</a></li>
<li><a class="reference internal" href="#specification-of-the-class-based-introspection-api">Specification of the class-based introspection API</a></li>
<li><a class="reference internal" href="#specification-of-the-attribute-descriptor-api">Specification of the attribute descriptor API</a></li>
<li><a class="reference internal" href="#static-methods-and-class-methods">Static methods and class methods</a></li>
<li><a class="reference internal" href="#c-api">C API</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
<li><a class="reference internal" href="#warnings-and-errors">Warnings and Errors</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes changes to the introspection API for types that
makes them look more like classes, and their instances more like
class instances.  For example, <code class="docutils literal notranslate"><span class="pre">type(x)</span></code> will be equivalent to
<code class="docutils literal notranslate"><span class="pre">x.__class__</span></code> for most built-in types.  When C is <code class="docutils literal notranslate"><span class="pre">x.__class__</span></code>,
<code class="docutils literal notranslate"><span class="pre">x.meth(a)</span></code> will generally be equivalent to <code class="docutils literal notranslate"><span class="pre">C.meth(x,</span> <span class="pre">a)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">C.__dict__</span></code> contains x’s methods and other attributes.</p>
<p>This PEP also introduces a new approach to specifying attributes,
using attribute descriptors, or descriptors for short.
Descriptors unify and generalize several different common
mechanisms used for describing attributes: a descriptor can
describe a method, a typed field in the object structure, or a
generalized attribute represented by getter and setter functions.</p>
<p>Based on the generalized descriptor API, this PEP also introduces
a way to declare class methods and static methods.</p>
<p>[Editor’s note: the ideas described in this PEP have been incorporated
into Python.  The PEP no longer accurately describes the implementation.]</p>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#introduction" role="doc-backlink">Introduction</a></h2>
<p>One of Python’s oldest language warts is the difference between
classes and types.  For example, you can’t directly subclass the
dictionary type, and the introspection interface for finding out
what methods and instance variables an object has is different for
types and for classes.</p>
<p>Healing the class/type split is a big effort, because it affects
many aspects of how Python is implemented.  This PEP concerns
itself with making the introspection API for types look the same
as that for classes.  Other PEPs will propose making classes look
more like types, and subclassing from built-in types; these topics
are not on the table for this PEP.</p>
</section>
<section id="introspection-apis">
<h2><a class="toc-backref" href="#introspection-apis" role="doc-backlink">Introspection APIs</a></h2>
<p>Introspection concerns itself with finding out what attributes an
object has.  Python’s very general getattr/setattr API makes it
impossible to guarantee that there always is a way to get a list
of all attributes supported by a specific object, but in practice
two conventions have appeared that together work for almost all
objects.  I’ll call them the class-based introspection API and the
type-based introspection API; class API and type API for short.</p>
<p>The class-based introspection API is used primarily for class
instances; it is also used by Jim Fulton’s ExtensionClasses.  It
assumes that all data attributes of an object x are stored in the
dictionary <code class="docutils literal notranslate"><span class="pre">x.__dict__</span></code>, and that all methods and class variables
can be found by inspection of x’s class, written as <code class="docutils literal notranslate"><span class="pre">x.__class__</span></code>.
Classes have a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute, which yields a dictionary
containing methods and class variables defined by the class
itself, and a <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attribute, which is a tuple of base
classes that must be inspected recursively.  Some assumptions here
are:</p>
<ul class="simple">
<li>attributes defined in the instance dict override attributes
defined by the object’s class;</li>
<li>attributes defined in a derived class override attributes
defined in a base class;</li>
<li>attributes in an earlier base class (meaning occurring earlier
in <code class="docutils literal notranslate"><span class="pre">__bases__</span></code>) override attributes in a later base class.</li>
</ul>
<p>(The last two rules together are often summarized as the
left-to-right, depth-first rule for attribute search.  This is the
classic Python attribute lookup rule.  Note that <a class="pep reference internal" href="../pep-0253/" title="PEP 253 – Subtyping Built-in Types">PEP 253</a> will
propose to change the attribute lookup order, and if accepted,
this PEP will follow suit.)</p>
<p>The type-based introspection API is supported in one form or
another by most built-in objects.  It uses two special attributes,
<code class="docutils literal notranslate"><span class="pre">__members__</span></code> and <code class="docutils literal notranslate"><span class="pre">__methods__</span></code>.  The <code class="docutils literal notranslate"><span class="pre">__methods__</span></code> attribute, if
present, is a list of method names supported by the object.  The
<code class="docutils literal notranslate"><span class="pre">__members__</span></code> attribute, if present, is a list of data attribute
names supported by the object.</p>
<p>The type API is sometimes combined with a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> that works the
same as for instances (for example for function objects in
Python 2.1, <code class="docutils literal notranslate"><span class="pre">f.__dict__</span></code> contains f’s dynamic attributes, while
<code class="docutils literal notranslate"><span class="pre">f.__members__</span></code> lists the names of f’s statically defined
attributes).</p>
<p>Some caution must be exercised: some objects don’t list their
“intrinsic” attributes (like <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> and <code class="docutils literal notranslate"><span class="pre">__doc__</span></code>) in <code class="docutils literal notranslate"><span class="pre">__members__</span></code>,
while others do; sometimes attribute names occur both in
<code class="docutils literal notranslate"><span class="pre">__members__</span></code> or <code class="docutils literal notranslate"><span class="pre">__methods__</span></code> and as keys in <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>, in which case
it’s anybody’s guess whether the value found in <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> is used
or not.</p>
<p>The type API has never been carefully specified.  It is part of
Python folklore, and most third party extensions support it
because they follow examples that support it.  Also, any type that
uses <code class="docutils literal notranslate"><span class="pre">Py_FindMethod()</span></code> and/or <code class="docutils literal notranslate"><span class="pre">PyMember_Get()</span></code> in its tp_getattr
handler supports it, because these two functions special-case the
attribute names <code class="docutils literal notranslate"><span class="pre">__methods__</span></code> and <code class="docutils literal notranslate"><span class="pre">__members__</span></code>, respectively.</p>
<p>Jim Fulton’s ExtensionClasses ignore the type API, and instead
emulate the class API, which is more powerful.  In this PEP, I
propose to phase out the type API in favor of supporting the class
API for all types.</p>
<p>One argument in favor of the class API is that it doesn’t require
you to create an instance in order to find out which attributes a
type supports; this in turn is useful for documentation
processors.  For example, the socket module exports the SocketType
object, but this currently doesn’t tell us what methods are
defined on socket objects.  Using the class API, SocketType would
show exactly what the methods for socket objects are, and we can
even extract their docstrings, without creating a socket.  (Since
this is a C extension module, the source-scanning approach to
docstring extraction isn’t feasible in this case.)</p>
</section>
<section id="specification-of-the-class-based-introspection-api">
<h2><a class="toc-backref" href="#specification-of-the-class-based-introspection-api" role="doc-backlink">Specification of the class-based introspection API</a></h2>
<p>Objects may have two kinds of attributes: static and dynamic.  The
names and sometimes other properties of static attributes are
knowable by inspection of the object’s type or class, which is
accessible through <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> or <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.  (I’m using type
and class interchangeably; a clumsy but descriptive term that fits
both is “meta-object”.)</p>
<p>(XXX static and dynamic are not great terms to use here, because
“static” attributes may actually behave quite dynamically, and
because they have nothing to do with static class members in C++
or Java.  Barry suggests to use immutable and mutable instead, but
those words already have precise and different meanings in
slightly different contexts, so I think that would still be
confusing.)</p>
<p>Examples of dynamic attributes are instance variables of class
instances, module attributes, etc.  Examples of static attributes
are the methods of built-in objects like lists and dictionaries,
and the attributes of frame and code objects (<code class="docutils literal notranslate"><span class="pre">f.f_code</span></code>,
<code class="docutils literal notranslate"><span class="pre">c.co_filename</span></code>, etc.).  When an object with dynamic attributes
exposes these through its <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute, <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> is a static
attribute.</p>
<p>The names and values of dynamic properties are typically stored in
a dictionary, and this dictionary is typically accessible as
<code class="docutils literal notranslate"><span class="pre">obj.__dict__</span></code>.  The rest of this specification is more concerned
with discovering the names and properties of static attributes
than with dynamic attributes; the latter are easily discovered by
inspection of <code class="docutils literal notranslate"><span class="pre">obj.__dict__</span></code>.</p>
<p>In the discussion below, I distinguish two kinds of objects:
regular objects (like lists, ints, functions) and meta-objects.
Types and classes are meta-objects.  Meta-objects are also regular
objects, but we’re mostly interested in them because they are
referenced by the <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute of regular objects (or by
the <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attribute of other meta-objects).</p>
<p>The class introspection API consists of the following elements:</p>
<ul class="simple">
<li>the <code class="docutils literal notranslate"><span class="pre">__class__</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attributes on regular objects;</li>
<li>the <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attributes on meta-objects;</li>
<li>precedence rules;</li>
<li>attribute descriptors.</li>
</ul>
<p>Together, these not only tell us about <strong>all</strong> attributes defined by
a meta-object, but they also help us calculate the value of a
specific attribute of a given object.</p>
<ol class="arabic">
<li>The <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute on regular objects<p>A regular object may have a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute.  If it does,
this should be a mapping (not necessarily a dictionary)
supporting at least <code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>, <code class="docutils literal notranslate"><span class="pre">keys()</span></code>, and <code class="docutils literal notranslate"><span class="pre">has_key()</span></code>.  This
gives the dynamic attributes of the object.  The keys in the
mapping give attribute names, and the corresponding values give
their values.</p>
<p>Typically, the value of an attribute with a given name is the
same object as the value corresponding to that name as a key in
the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.  In other words, <code class="docutils literal notranslate"><span class="pre">obj.__dict__['spam']</span></code> is <code class="docutils literal notranslate"><span class="pre">obj.spam</span></code>.
(But see the precedence rules below; a static attribute with
the same name <strong>may</strong> override the dictionary item.)</p>
</li>
<li>The <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute on regular objects<p>A regular object usually has a <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute.  If it
does, this references a meta-object.  A meta-object can define
static attributes for the regular object whose <code class="docutils literal notranslate"><span class="pre">__class__</span></code> it
is.  This is normally done through the following mechanism:</p>
</li>
<li>The <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute on meta-objects<p>A meta-object may have a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute, of the same form
as the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute for regular objects (a mapping but
not necessarily a dictionary).  If it does, the keys of the
meta-object’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> are names of static attributes for the
corresponding regular object.  The values are attribute
descriptors; we’ll explain these later.  An unbound method is a
special case of an attribute descriptor.</p>
<p>Because a meta-object is also a regular object, the items in a
meta-object’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> correspond to attributes of the
meta-object; however, some transformation may be applied, and
bases (see below) may define additional dynamic attributes.  In
other words, <code class="docutils literal notranslate"><span class="pre">mobj.spam</span></code> is not always <code class="docutils literal notranslate"><span class="pre">mobj.__dict__['spam']</span></code>.
(This rule contains a loophole because for classes, if
<code class="docutils literal notranslate"><span class="pre">C.__dict__['spam']</span></code> is a function, <code class="docutils literal notranslate"><span class="pre">C.spam</span></code> is an unbound method
object.)</p>
</li>
<li>The <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attribute on meta-objects<p>A meta-object may have a <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attribute.  If it does, this
should be a sequence (not necessarily a tuple) of other
meta-objects, the bases.  An absent <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> is equivalent to
an empty sequence of bases.  There must never be a cycle in the
relationship between meta-objects defined by <code class="docutils literal notranslate"><span class="pre">__bases__</span></code>
attributes; in other words, the <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attributes define a
directed acyclic graph, with arcs pointing from derived
meta-objects to their base meta-objects.  (It is not
necessarily a tree, since multiple classes can have the same
base class.)  The <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attributes of a meta-object in the
inheritance graph supply attribute descriptors for the regular
object whose <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute points to the root of the
inheritance tree (which is not the same as the root of the
inheritance hierarchy – rather more the opposite, at the
bottom given how inheritance trees are typically drawn).
Descriptors are first searched in the dictionary of the root
meta-object, then in its bases, according to a precedence rule
(see the next paragraph).</p>
</li>
<li>Precedence rules<p>When two meta-objects in the inheritance graph for a given
regular object both define an attribute descriptor with the
same name, the search order is up to the meta-object.  This
allows different meta-objects to define different search
orders.  In particular, classic classes use the old
left-to-right depth-first rule, while new-style classes use a
more advanced rule (see the section on method resolution order
in <a class="pep reference internal" href="../pep-0253/" title="PEP 253 – Subtyping Built-in Types">PEP 253</a>).</p>
<p>When a dynamic attribute (one defined in a regular object’s
<code class="docutils literal notranslate"><span class="pre">__dict__</span></code>) has the same name as a static attribute (one defined
by a meta-object in the inheritance graph rooted at the regular
object’s <code class="docutils literal notranslate"><span class="pre">__class__</span></code>), the static attribute has precedence if it
is a descriptor that defines a <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method (see below);
otherwise (if there is no <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method) the dynamic attribute
has precedence.  In other words, for data attributes (those
with a <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method), the static definition overrides the
dynamic definition, but for other attributes, dynamic overrides
static.</p>
<p>Rationale: we can’t have a simple rule like “static overrides
dynamic” or “dynamic overrides static”, because some static
attributes indeed override dynamic attributes; for example, a
key ‘__class__’ in an instance’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> is ignored in favor
of the statically defined <code class="docutils literal notranslate"><span class="pre">__class__</span></code> pointer, but on the other
hand most keys in <code class="docutils literal notranslate"><span class="pre">inst.__dict__</span></code> override attributes defined in
<code class="docutils literal notranslate"><span class="pre">inst.__class__</span></code>.  Presence of a <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method on a descriptor
indicates that this is a data descriptor.  (Even read-only data
descriptors have a <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method: it always raises an
exception.)  Absence of a <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method on a descriptor
indicates that the descriptor isn’t interested in intercepting
assignment, and then the classic rule applies: an instance
variable with the same name as a method hides the method until
it is deleted.</p>
</li>
<li>Attribute descriptors<p>This is where it gets interesting – and messy.  Attribute
descriptors (descriptors for short) are stored in the
meta-object’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> (or in the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> of one of its
ancestors), and have two uses: a descriptor can be used to get
or set the corresponding attribute value on the (regular,
non-meta) object, and it has an additional interface that
describes the attribute for documentation and introspection
purposes.</p>
<p>There is little prior art in Python for designing the
descriptor’s interface, neither for getting/setting the value
nor for describing the attribute otherwise, except some trivial
properties (it’s reasonable to assume that <code class="docutils literal notranslate"><span class="pre">__name__</span></code> and <code class="docutils literal notranslate"><span class="pre">__doc__</span></code>
should be the attribute’s name and docstring).  I will propose
such an API below.</p>
<p>If an object found in the meta-object’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> is not an
attribute descriptor, backward compatibility dictates certain
minimal semantics.  This basically means that if it is a Python
function or an unbound method, the attribute is a method;
otherwise, it is the default value for a dynamic data
attribute.  Backwards compatibility also dictates that (in the
absence of a <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> method) it is legal to assign to an
attribute corresponding to a method, and that this creates a
data attribute shadowing the method for this particular
instance.  However, these semantics are only required for
backwards compatibility with regular classes.</p>
</li>
</ol>
<p>The introspection API is a read-only API.  We don’t define the
effect of assignment to any of the special attributes (<code class="docutils literal notranslate"><span class="pre">__dict__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__class__</span></code> and <code class="docutils literal notranslate"><span class="pre">__bases__</span></code>), nor the effect of assignment to the
items of a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.  Generally, such assignments should be
considered off-limits.  A future PEP may define some semantics for
some such assignments.  (Especially because currently instances
support assignment to <code class="docutils literal notranslate"><span class="pre">__class__</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>, and classes support
assignment to <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> and <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.)</p>
</section>
<section id="specification-of-the-attribute-descriptor-api">
<h2><a class="toc-backref" href="#specification-of-the-attribute-descriptor-api" role="doc-backlink">Specification of the attribute descriptor API</a></h2>
<p>Attribute descriptors may have the following attributes.  In the
examples, x is an object, C is <code class="docutils literal notranslate"><span class="pre">x.__class__</span></code>, <code class="docutils literal notranslate"><span class="pre">x.meth()</span></code> is a method,
and <code class="docutils literal notranslate"><span class="pre">x.ivar</span></code> is a data attribute or instance variable.  All
attributes are optional – a specific attribute may or may not be
present on a given descriptor.  An absent attribute means that the
corresponding information is not available or the corresponding
functionality is not implemented.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">__name__</span></code>: the attribute name.  Because of aliasing and renaming,
the attribute may (additionally or exclusively) be known under a
different name, but this is the name under which it was born.
Example: <code class="docutils literal notranslate"><span class="pre">C.meth.__name__</span> <span class="pre">==</span> <span class="pre">'meth'</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">__doc__</span></code>: the attribute’s documentation string.  This may be
None.</li>
<li><code class="docutils literal notranslate"><span class="pre">__objclass__</span></code>: the class that declared this attribute.  The
descriptor only applies to objects that are instances of this
class (this includes instances of its subclasses).  Example:
<code class="docutils literal notranslate"><span class="pre">C.meth.__objclass__</span> <span class="pre">is</span> <span class="pre">C</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">__get__()</span></code>: a function callable with one or two arguments that
retrieves the attribute value from an object.  This is also
referred to as a “binding” operation, because it may return a
“bound method” object in the case of method descriptors.  The
first argument, X, is the object from which the attribute must
be retrieved or to which it must be bound.  When X is None, the
optional second argument, T, should be meta-object and the
binding operation may return an <strong>unbound</strong> method restricted to
instances of T.  When both X and T are specified, X should be an
instance of T.  Exactly what is returned by the binding
operation depends on the semantics of the descriptor; for
example, static methods and class methods (see below) ignore the
instance and bind to the type instead.</li>
<li><code class="docutils literal notranslate"><span class="pre">__set__()</span></code>: a function of two arguments that sets the attribute
value on the object.  If the attribute is read-only, this method
may raise a TypeError or <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> exception (both are
allowed, because both are historically found for undefined or
unsettable attributes).  Example:
<code class="docutils literal notranslate"><span class="pre">C.ivar.set(x,</span> <span class="pre">y)</span> <span class="pre">~~</span> <span class="pre">x.ivar</span> <span class="pre">=</span> <span class="pre">y</span></code>.</li>
</ul>
</section>
<section id="static-methods-and-class-methods">
<h2><a class="toc-backref" href="#static-methods-and-class-methods" role="doc-backlink">Static methods and class methods</a></h2>
<p>The descriptor API makes it possible to add static methods and
class methods.  Static methods are easy to describe: they behave
pretty much like static methods in C++ or Java.  Here’s an
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;staticmethod&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Both the call <code class="docutils literal notranslate"><span class="pre">C.foo(1,</span> <span class="pre">2)</span></code> and the call <code class="docutils literal notranslate"><span class="pre">c.foo(1,</span> <span class="pre">2)</span></code> call <code class="docutils literal notranslate"><span class="pre">foo()</span></code> with
two arguments, and print “staticmethod 1 2”.  No “self” is declared in
the definition of <code class="docutils literal notranslate"><span class="pre">foo()</span></code>, and no instance is required in the call.</p>
<p>The line “foo = staticmethod(foo)” in the class statement is the
crucial element: this makes <code class="docutils literal notranslate"><span class="pre">foo()</span></code> a static method.  The built-in
<code class="docutils literal notranslate"><span class="pre">staticmethod()</span></code> wraps its function argument in a special kind of
descriptor whose <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> method returns the original function
unchanged.  Without this, the <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> method of standard
function objects would have created a bound method object for
‘c.foo’ and an unbound method object for ‘C.foo’.</p>
<p>(XXX Barry suggests to use “sharedmethod” instead of
“staticmethod”, because the word static is being overloaded in so
many ways already.  But I’m not sure if shared conveys the right
meaning.)</p>
<p>Class methods use a similar pattern to declare methods that
receive an implicit first argument that is the <em>class</em> for which
they are invoked.  This has no C++ or Java equivalent, and is not
quite the same as what class methods are in Smalltalk, but may
serve a similar purpose.  According to Armin Rigo, they are
similar to “virtual class methods” in Borland Pascal dialect
Delphi.  (Python also has real metaclasses, and perhaps methods
defined in a metaclass have more right to the name “class method”;
but I expect that most programmers won’t be using metaclasses.)
Here’s an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;classmethod&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">y</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Both the call <code class="docutils literal notranslate"><span class="pre">C.foo(1)</span></code> and the call <code class="docutils literal notranslate"><span class="pre">c.foo(1)</span></code> end up calling <code class="docutils literal notranslate"><span class="pre">foo()</span></code>
with <strong>two</strong> arguments, and print “classmethod __main__.C 1”.  The
first argument of <code class="docutils literal notranslate"><span class="pre">foo()</span></code> is implied, and it is the class, even if
the method was invoked via an instance.  Now let’s continue the
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">D</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This prints “classmethod __main__.D 1” both times; in other words,
the class passed as the first argument of <code class="docutils literal notranslate"><span class="pre">foo()</span></code> is the class
involved in the call, not the class involved in the definition of
<code class="docutils literal notranslate"><span class="pre">foo()</span></code>.</p>
<p>But notice this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">E</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="c1"># override C.foo</span>
        <span class="nb">print</span> <span class="s2">&quot;E.foo() called&quot;</span>
        <span class="n">C</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="n">E</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">E</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, the call to <code class="docutils literal notranslate"><span class="pre">C.foo()</span></code> from <code class="docutils literal notranslate"><span class="pre">E.foo()</span></code> will see class C
as its first argument, not class E.  This is to be expected, since
the call specifies the class C.  But it stresses the difference
between these class methods and methods defined in metaclasses,
where an upcall to a metamethod would pass the target class as an
explicit first argument.  (If you don’t understand this, don’t
worry, you’re not alone.)  Note that calling <code class="docutils literal notranslate"><span class="pre">cls.foo(y)</span></code> would be a
mistake – it would cause infinite recursion.  Also note that you
can’t specify an explicit ‘cls’ argument to a class method.  If
you want this (e.g. the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method in <a class="pep reference internal" href="../pep-0253/" title="PEP 253 – Subtyping Built-in Types">PEP 253</a> requires this),
use a static method with a class as its explicit first argument
instead.</p>
</section>
<section id="c-api">
<h2><a class="toc-backref" href="#c-api" role="doc-backlink">C API</a></h2>
<p>XXX The following is VERY rough text that I wrote with a different
audience in mind; I’ll have to go through this to edit it more.
XXX It also doesn’t go into enough detail for the C API.</p>
<p>A built-in type can declare special data attributes in two ways:
using a struct memberlist (defined in structmember.h) or a struct
getsetlist (defined in descrobject.h).  The struct memberlist is
an old mechanism put to new use: each attribute has a descriptor
record including its name, an enum giving its type (various C
types are supported as well as <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>), an offset from the
start of the instance, and a read-only flag.</p>
<p>The struct getsetlist mechanism is new, and intended for cases
that don’t fit in that mold, because they either require
additional checking, or are plain calculated attributes.  Each
attribute here has a name, a getter C function pointer, a setter C
function pointer, and a context pointer.  The function pointers
are optional, so that for example setting the setter function
pointer to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> makes a read-only attribute.  The context pointer
is intended to pass auxiliary information to generic getter/setter
functions, but I haven’t found a need for this yet.</p>
<p>Note that there is also a similar mechanism to declare built-in
methods: these are <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structures, which contain a name
and a C function pointer (and some flags for the calling
convention).</p>
<p>Traditionally, built-in types have had to define their own
<code class="docutils literal notranslate"><span class="pre">tp_getattro</span></code> and <code class="docutils literal notranslate"><span class="pre">tp_setattro</span></code> slot functions to make these attribute
definitions work (<code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> and struct memberlist are quite
old).  There are convenience functions that take an array of
<code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> or memberlist structures, an object, and an attribute
name, and return or set the attribute if found in the list, or
raise an exception if not found.  But these convenience functions
had to be explicitly called by the <code class="docutils literal notranslate"><span class="pre">tp_getattro</span></code> or <code class="docutils literal notranslate"><span class="pre">tp_setattro</span></code>
method of the specific type, and they did a linear search of the
array using <code class="docutils literal notranslate"><span class="pre">strcmp()</span></code> to find the array element describing the
requested attribute.</p>
<p>I now have a brand spanking new generic mechanism that improves
this situation substantially.</p>
<ul>
<li>Pointers to arrays of <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code>, memberlist, getsetlist
structures are part of the new type object (<code class="docutils literal notranslate"><span class="pre">tp_methods</span></code>,
<code class="docutils literal notranslate"><span class="pre">tp_members</span></code>, <code class="docutils literal notranslate"><span class="pre">tp_getset</span></code>).</li>
<li>At type initialization time (in <code class="docutils literal notranslate"><span class="pre">PyType_InitDict()</span></code>), for each
entry in those three arrays, a descriptor object is created and
placed in a dictionary that belongs to the type (<code class="docutils literal notranslate"><span class="pre">tp_dict</span></code>).</li>
<li>Descriptors are very lean objects that mostly point to the
corresponding structure.  An implementation detail is that all
descriptors share the same object type, and a discriminator
field tells what kind of descriptor it is (method, member, or
getset).</li>
<li>As explained in <a class="pep reference internal" href="../pep-0252/" title="PEP 252 – Making Types Look More Like Classes">PEP 252</a>, descriptors have a <code class="docutils literal notranslate"><span class="pre">get()</span></code> method that
takes an object argument and returns that object’s attribute;
descriptors for writable attributes also have a <code class="docutils literal notranslate"><span class="pre">set()</span></code> method
that takes an object and a value and set that object’s
attribute.  Note that the <code class="docutils literal notranslate"><span class="pre">get()</span></code> object also serves as a <code class="docutils literal notranslate"><span class="pre">bind()</span></code>
operation for methods, binding the unbound method implementation
to the object.</li>
<li>Instead of providing their own tp_getattro and tp_setattro
implementation, almost all built-in objects now place
<code class="docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr</span></code> and (if they have any writable
attributes) <code class="docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr</span></code> in their <code class="docutils literal notranslate"><span class="pre">tp_getattro</span></code> and
<code class="docutils literal notranslate"><span class="pre">tp_setattro</span></code> slots.  (Or, they can leave these <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and inherit
them from the default base object, if they arrange for an
explicit call to <code class="docutils literal notranslate"><span class="pre">PyType_InitDict()</span></code> for the type before the first
instance is created.)</li>
<li>In the simplest case, <code class="docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code> does exactly one
dictionary lookup: it looks up the attribute name in the type’s
dictionary (obj-&gt;ob_type-&gt;tp_dict).  Upon success, there are two
possibilities: the descriptor has a get method, or it doesn’t.
For speed, the get and set methods are type slots: <code class="docutils literal notranslate"><span class="pre">tp_descr_get</span></code>
and <code class="docutils literal notranslate"><span class="pre">tp_descr_set</span></code>.  If the <code class="docutils literal notranslate"><span class="pre">tp_descr_get</span></code> slot is non-NULL, it is
called, passing the object as its only argument, and the return
value from this call is the result of the getattr operation.  If
the <code class="docutils literal notranslate"><span class="pre">tp_descr_get</span></code> slot is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, as a fallback the descriptor
itself is returned (compare class attributes that are not
methods but simple values).</li>
<li><code class="docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code> works very similar but uses the
<code class="docutils literal notranslate"><span class="pre">tp_descr_set</span></code> slot and calls it with the object and the new
attribute value; if the <code class="docutils literal notranslate"><span class="pre">tp_descr_set</span></code> slot is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, an
<code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> is raised.</li>
<li>But now for a more complicated case.  The approach described
above is suitable for most built-in objects such as lists,
strings, numbers.  However, some object types have a dictionary
in each instance that can store arbitrary attributes.  In fact,
when you use a class statement to subtype an existing built-in
type, you automatically get such a dictionary (unless you
explicitly turn it off, using another advanced feature,
<code class="docutils literal notranslate"><span class="pre">__slots__</span></code>).  Let’s call this the instance dict, to distinguish
it from the type dict.</li>
<li>In the more complicated case, there’s a conflict between names
stored in the instance dict and names stored in the type dict.
If both dicts have an entry with the same key, which one should
we return?  Looking at classic Python for guidance, I find
conflicting rules: for class instances, the instance dict
overrides the class dict, <strong>except</strong> for the special attributes
(like <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> and <code class="docutils literal notranslate"><span class="pre">__class__</span></code>), which have priority over the
instance dict.</li>
<li>I resolved this with the following set of rules, implemented in
<code class="docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code>:<ol class="arabic simple">
<li>Look in the type dict.  If you find a <strong>data</strong> descriptor, use
its <code class="docutils literal notranslate"><span class="pre">get()</span></code> method to produce the result.  This takes care of
special attributes like <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> and <code class="docutils literal notranslate"><span class="pre">__class__</span></code>.</li>
<li>Look in the instance dict.  If you find anything, that’s it.
(This takes care of the requirement that normally the
instance dict overrides the class dict.)</li>
<li>Look in the type dict again (in reality this uses the saved
result from step 1, of course).  If you find a descriptor,
use its <code class="docutils literal notranslate"><span class="pre">get()</span></code> method; if you find something else, that’s it;
if it’s not there, raise <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>.</li>
</ol>
<p>This requires a classification of descriptors as data and
nondata descriptors.  The current implementation quite sensibly
classifies member and getset descriptors as data (even if they
are read-only!)  and method descriptors as nondata.
Non-descriptors (like function pointers or plain values) are
also classified as non-data (!).</p>
</li>
<li>This scheme has one drawback: in what I assume to be the most
common case, referencing an instance variable stored in the
instance dict, it does <strong>two</strong> dictionary lookups, whereas the
classic scheme did a quick test for attributes starting with two
underscores plus a single dictionary lookup.  (Although the
implementation is sadly structured as <code class="docutils literal notranslate"><span class="pre">instance_getattr()</span></code> calling
<code class="docutils literal notranslate"><span class="pre">instance_getattr1()</span></code> calling <code class="docutils literal notranslate"><span class="pre">instance_getattr2()</span></code> which finally
calls <code class="docutils literal notranslate"><span class="pre">PyDict_GetItem()</span></code>, and the underscore test calls
<code class="docutils literal notranslate"><span class="pre">PyString_AsString()</span></code> rather than inlining this.  I wonder if
optimizing the snot out of this might not be a good idea to
speed up Python 2.2, if we weren’t going to rip it all out. :-)</li>
<li>A benchmark verifies that in fact this is as fast as classic
instance variable lookup, so I’m no longer worried.</li>
<li>Modification for dynamic types: step 1 and 3 look in the
dictionary of the type and all its base classes (in MRO
sequence, or course).</li>
</ul>
</section>
<section id="discussion">
<h2><a class="toc-backref" href="#discussion" role="doc-backlink">Discussion</a></h2>
<p>XXX</p>
</section>
<section id="examples">
<h2><a class="toc-backref" href="#examples" role="doc-backlink">Examples</a></h2>
<p>Let’s look at lists.  In classic Python, the method names of
lists were available as the __methods__ attribute of list objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[]</span><span class="o">.</span><span class="n">__methods__</span>
<span class="go">[&#39;append&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;,</span>
<span class="go">&#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Under the new proposal, the __methods__ attribute no longer exists:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[]</span><span class="o">.</span><span class="n">__methods__</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;list&#39; object has no attribute &#39;__methods__&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Instead, you can get the same information from the list type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="p">[]</span><span class="o">.</span><span class="vm">__class__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>                <span class="c1"># like T.__dict__.keys(), but sorted</span>
<span class="go">[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__eq__&#39;, &#39;__ge__&#39;,</span>
<span class="go">&#39;__getattr__&#39;, &#39;__getitem__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;,</span>
<span class="go">&#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__le__&#39;, &#39;__len__&#39;,</span>
<span class="go">&#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__radd__&#39;,</span>
<span class="go">&#39;__repr__&#39;, &#39;__rmul__&#39;, &#39;__setitem__&#39;, &#39;__setslice__&#39;, &#39;append&#39;,</span>
<span class="go">&#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;,</span>
<span class="go">&#39;reverse&#39;, &#39;sort&#39;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The new introspection API gives more information than the old one:
in addition to the regular methods, it also shows the methods that
are normally invoked through special notations, e.g.  <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code>
(<code class="docutils literal notranslate"><span class="pre">+=</span></code>), <code class="docutils literal notranslate"><span class="pre">__len__</span></code> (<code class="docutils literal notranslate"><span class="pre">len</span></code>), <code class="docutils literal notranslate"><span class="pre">__ne__</span></code> (<code class="docutils literal notranslate"><span class="pre">!=</span></code>).
You can invoke any method from this list directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tic&#39;</span><span class="p">,</span> <span class="s1">&#39;tac&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>          <span class="c1"># same as len(a)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;toe&#39;</span><span class="p">)</span>    <span class="c1"># same as a.append(&#39;toe&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>This is just like it is for user-defined classes.</p>
<p>Notice a familiar yet surprising name in the list: <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.  This
is the domain of <a class="pep reference internal" href="../pep-0253/" title="PEP 253 – Subtyping Built-in Types">PEP 253</a>.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards compatibility</a></h2>
<p>XXX</p>
</section>
<section id="warnings-and-errors">
<h2><a class="toc-backref" href="#warnings-and-errors" role="doc-backlink">Warnings and Errors</a></h2>
<p>XXX</p>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h2>
<p>A partial implementation of this PEP is available from CVS as a
branch named “descr-branch”.  To experiment with this
implementation, proceed to check out Python from CVS according to
the instructions at <a class="reference external" href="http://sourceforge.net/cvs/?group_id=5470">http://sourceforge.net/cvs/?group_id=5470</a> but
add the arguments “-r descr-branch” to the cvs checkout command.
(You can also start with an existing checkout and do “cvs update
-r descr-branch”.)  For some examples of the features described
here, see the file Lib/test/test_descr.py.</p>
<p>Note: the code in this branch goes way beyond this PEP; it is also
the experimentation area for <a class="pep reference internal" href="../pep-0253/" title="PEP 253 – Subtyping Built-in Types">PEP 253</a> (Subtyping Built-in Types).</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<p>XXX</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0252.rst">https://github.com/python/peps/blob/main/peps/pep-0252.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0252.rst">2025-02-01 08:55:40 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#introspection-apis">Introspection APIs</a></li>
<li><a class="reference internal" href="#specification-of-the-class-based-introspection-api">Specification of the class-based introspection API</a></li>
<li><a class="reference internal" href="#specification-of-the-attribute-descriptor-api">Specification of the attribute descriptor API</a></li>
<li><a class="reference internal" href="#static-methods-and-class-methods">Static methods and class methods</a></li>
<li><a class="reference internal" href="#c-api">C API</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
<li><a class="reference internal" href="#warnings-and-errors">Warnings and Errors</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0252.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>